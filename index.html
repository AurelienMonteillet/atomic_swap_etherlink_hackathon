<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etherlink x Jstz | Atomic Swap</title>
    
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        ether: {
                            green: '#80F89B', // Etherlink Brand Green (approx)
                            dark: '#020202',
                            card: '#111111',
                            border: '#222222',
                            text: '#e2e8f0'
                        },
                        jstz: {
                            accent: '#FFD700' // Gold/Yellow for Jstz
                        }
                    },
                    fontFamily: {
                        sans: ['"Plus Jakarta Sans"', 'Inter', 'sans-serif'],
                        mono: ['"JetBrains Mono"', 'monospace'],
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 6s ease-in-out infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        }
                    }
                }
            }
        }
    </script>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    
    <!-- Jstz Wallet Extension Integration -->
    <script>
        // Jstz Signer Extension Types and Functions
        const JstzSignerEventTypes = {
            SIGN: 'JSTZ_SIGN_REQUEST_TO_EXTENSION',
            GET_ADDRESS: 'JSTZ_GET_ADDRESS_REQUEST_TO_EXTENSION',
            SIGN_RESPONSE: 'JSTZ_SIGN_RESPONSE_FROM_EXTENSION',
            GET_ADDRESS_RESPONSE: 'JSTZ_GET_ADDRESS_RESPONSE_FROM_EXTENSION'
        };

        // Check if Jstz extension is installed
        function isJstzExtensionInstalled() {
            try {
                return typeof window.jstzCallSignerExtension === 'function';
            } catch (e) {
                return false;
            }
        }

        // Request address from Jstz wallet extension
        async function getJstzAddress() {
            if (!isJstzExtensionInstalled()) {
                throw new Error('Jstz wallet extension not installed. Please install from: https://github.com/jstz-dev/dev-wallet/releases');
            }
            
            try {
                const response = await window.jstzCallSignerExtension({
                    type: JstzSignerEventTypes.GET_ADDRESS
                });
                return response.data;
            } catch (error) {
                throw new Error(`Failed to get Jstz address: ${error.message}`);
            }
        }

        // Request signature from Jstz wallet extension
        async function requestJstzSignature(operation) {
            if (!isJstzExtensionInstalled()) {
                throw new Error('Jstz wallet extension not installed');
            }
            
            try {
                const response = await window.jstzCallSignerExtension({
                    type: JstzSignerEventTypes.SIGN,
                    content: operation
                });
                return response.data;
            } catch (error) {
                throw new Error(`Failed to sign Jstz operation: ${error.message}`);
            }
        }

        // Inject and poll Jstz operation
        async function injectJstzOperation(operation, signature, rpcUrl = 'https://privatenet.jstz.info') {
            const response = await fetch(`${rpcUrl}/operations`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    inner: operation,
                    signature: signature
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Jstz injection failed: ${errorText}`);
            }
            
            return await response.json();
        }

        // Poll for operation result
        async function pollJstzOperation(operationHash, rpcUrl = 'https://privatenet.jstz.info', maxAttempts = 30) {
            for (let i = 0; i < maxAttempts; i++) {
                try {
                    const response = await fetch(`${rpcUrl}/operations/${operationHash}`);
                    if (response.ok) {
                        const result = await response.json();
                        if (result.status === 'applied' || result.status === 'failed') {
                            return result;
                        }
                    }
                } catch (e) {
                    // Continue polling
                }
                await new Promise(r => setTimeout(r, 1000));
            }
            throw new Error('Operation polling timeout');
        }
    </script>
    <!-- Automated Test Suite (run runAllTests() in console) -->
    <script src="test-scenarios.js"></script>

    <style>
        body {
            background-color: #020202;
            /* Etherlink-style diagonal glow */
            background-image: 
                radial-gradient(circle at 20% 0%, rgba(128, 248, 155, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 100%, rgba(128, 248, 155, 0.05) 0%, transparent 50%);
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #80F89B; }

        .glass-card {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
        }

        .neon-text {
            text-shadow: 0 0 20px rgba(128, 248, 155, 0.4);
        }
        
        .input-field {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        .input-field:focus {
            border-color: #80F89B;
            box-shadow: 0 0 15px rgba(128, 248, 155, 0.1);
        }

        .btn-primary {
            background: #80F89B;
            color: #000;
            font-weight: 600;
            letter-spacing: -0.02em;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .btn-primary::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: 0.5s;
        }
        .btn-primary:hover::after {
            left: 100%;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(128, 248, 155, 0.3);
            background: #6ee786;
        }

        .step-line-bg {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 0;
            transform: translateY(-50%);
        }
        .step-progress {
            position: absolute;
            top: 50%;
            left: 0;
            height: 1px;
            background: #80F89B;
            box-shadow: 0 0 10px rgba(128, 248, 155, 0.5);
            z-index: 0;
            transform: translateY(-50%);
            width: 0%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .step-dot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            z-index: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: #111;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #666;
        }
        
        .step-dot.active {
            background: #80F89B;
            color: #000;
            border-color: #80F89B;
            box-shadow: 0 0 20px rgba(128, 248, 155, 0.3);
            transform: scale(1.1);
        }

        .step-dot.completed {
            background: #000;
            color: #80F89B;
            border-color: #80F89B;
        }

        .step-label {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #666;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .step-dot.active + .step-label {
            color: #80F89B;
            text-shadow: 0 0 10px rgba(128, 248, 155, 0.3);
        }
        .step-dot.completed + .step-label {
            color: #e2e8f0;
        }

        /* Secret Blur */
        .secret-blur {
            filter: blur(8px);
            cursor: pointer;
            transition: filter 0.3s;
            user-select: none;
        }
        .secret-blur:hover, .secret-blur.revealed {
            filter: blur(0);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Navigation -->
    <nav class="w-full border-b border-white/5 bg-ether-card/50 backdrop-blur-md fixed top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
        <div class="flex items-center gap-3">
                    <!-- Logo Placeholder -->
                    <div class="w-8 h-8 rounded bg-ether-green flex items-center justify-center text-black font-bold text-lg shadow-[0_0_15px_rgba(128,248,155,0.4)]">
                        <i class="fa-solid fa-arrow-right-arrow-left"></i>
                    </div>
                    <span class="text-xl font-bold tracking-tight text-white">Etherlink <span class="text-gray-500 mx-1">x</span> <span class="text-jstz-accent">Jstz</span></span>
                </div>
                
                <div class="hidden md:flex items-center space-x-4">
                    <div id="network-badge" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-white/10 cursor-pointer hover:border-ether-green/50 transition" onclick="switchToEtherlink(128123)" title="Click to switch to Etherlink Testnet">
                        <div id="network-dot" class="w-2 h-2 rounded-full bg-gray-500"></div>
                        <span id="network-name" class="text-xs text-gray-400">Not Connected</span>
                    </div>
                    <button id="wallet-etherlink" class="flex items-center gap-2 px-4 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 transition text-sm font-medium">
                        <i class="fa-brands fa-ethereum text-ether-green"></i>
                        <span id="wallet-etherlink-text">Connect Etherlink</span>
                        <span id="wallet-balance" class="hidden text-ether-green font-mono text-xs"></span>
                    </button>
                    <button id="wallet-jstz" class="flex items-center gap-2 px-4 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 transition text-sm font-medium">
                        <i class="fa-solid fa-bolt text-jstz-accent"></i>
                        <span id="wallet-jstz-text">Connect Jstz</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow pt-24 pb-12 px-4 flex flex-col items-center justify-center relative overflow-hidden">
        
        <!-- Decorative Elements -->
        <div class="absolute top-1/4 left-10 w-64 h-64 bg-green-500/10 rounded-full blur-3xl animate-pulse-slow"></div>
        <div class="absolute bottom-1/4 right-10 w-96 h-96 bg-yellow-500/5 rounded-full blur-3xl animate-pulse-slow" style="animation-delay: 1.5s;"></div>

        <div class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-12 gap-8 z-10">
            
            <!-- Left Column: Swap Interface -->
            <div class="lg:col-span-7 flex flex-col gap-6">
                
                <!-- Progress Stepper -->
                <div class="glass-card rounded-2xl p-8 relative overflow-hidden">
                    <div class="flex justify-between items-center mb-8">
                        <h3 class="text-xs font-bold text-gray-400 uppercase tracking-[0.2em]">Swap Status</h3>
                        <div class="flex items-center gap-2 text-[10px] text-gray-500">
                            <div class="w-1.5 h-1.5 rounded-full bg-ether-green animate-pulse"></div>
                            LIVE
                        </div>
                    </div>

                    <div class="relative px-4 pb-4">
                        <div class="step-line-bg"></div>
                        <div class="step-progress" id="progress-bar"></div>
                        
                        <div class="flex justify-between items-center relative z-10">
                            <div class="relative group cursor-default" id="step-1">
                                <div class="step-dot">1</div>
                                <span class="step-label">Initiate</span>
                            </div>
                            <div class="relative group cursor-default" id="step-2">
                                <div class="step-dot">2</div>
                                <span class="step-label">Participate</span>
                            </div>
                            <div class="relative group cursor-default" id="step-3">
                                <div class="step-dot">3</div>
                                <span class="step-label">Redeem</span>
                            </div>
                            <div class="relative group cursor-default" id="step-4">
                                <div class="step-dot">4</div>
                                <span class="step-label">Complete</span>
                        </div>
                        </div>
                    </div>
                </div>

                <!-- Main Swap Card -->
                <div class="glass-card rounded-2xl p-1">
                    <!-- Tabs -->
                    <div class="grid grid-cols-4 gap-1 p-1 bg-black/20 rounded-t-xl">
                        <button onclick="setTab('create')" id="tab-create" class="flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-ether-border shadow-lg transition-all">
                            Initiate
                        </button>
                        <button onclick="setTab('join')" id="tab-join" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            Join
                        </button>
                        <button onclick="setTab('redeem')" id="tab-redeem" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            Redeem
                        </button>
                        <button onclick="setTab('myswaps')" id="tab-myswaps" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            My Swaps
                        </button>
                    </div>

                    <div class="p-6 sm:p-8">
                        
                        <!-- INITIATE & JOIN CONTENT -->
                        <div id="initiate-join-content" class="space-y-6">
                            <!-- Chain Selection -->
                            <div class="grid grid-cols-2 gap-4 p-1 bg-black/20 rounded-xl">
                            <button onclick="setChain('etherlink')" id="chain-etherlink" class="relative py-3 rounded-lg border border-ether-green bg-ether-green/10 text-white transition-all group overflow-hidden">
                                <div class="flex items-center justify-center gap-2 relative z-10">
                                    <i class="fa-brands fa-ethereum text-ether-green"></i>
                                    <span class="text-sm font-bold">From Etherlink</span>
                                    <i class="fa-solid fa-arrow-right text-gray-500 text-xs"></i>
                                    <i class="fa-solid fa-layer-group text-gray-500 text-xs"></i>
                                </div>
                                <div class="absolute inset-0 bg-ether-green/5 opacity-0 group-hover:opacity-100 transition"></div>
                            </button>
                            <button onclick="setChain('jstz')" id="chain-jstz" class="relative py-3 rounded-lg border border-transparent text-gray-400 hover:text-white hover:bg-white/5 transition-all group">
                                <div class="flex items-center justify-center gap-2 relative z-10">
                                    <i class="fa-solid fa-layer-group text-jstz-accent"></i>
                                    <span class="text-sm font-bold">From Jstz</span>
                                    <i class="fa-solid fa-arrow-right text-gray-500 text-xs"></i>
                                    <i class="fa-brands fa-ethereum text-gray-500 text-xs"></i>
                                </div>
                            </button>
                        </div>

                        <!-- Secret Generator Section -->
                        <div id="secret-section" class="p-5 rounded-xl bg-gradient-to-br from-white/5 to-transparent border border-white/5 relative overflow-hidden group transition-all duration-300">
                            <div class="absolute top-0 right-0 p-3 opacity-50 group-hover:opacity-100 transition">
                                <i class="fa-solid fa-lock text-ether-green"></i>
                            </div>
                            <label class="text-xs font-bold text-ether-green uppercase tracking-widest mb-3 block">
                                <i class="fa-solid fa-key mr-1"></i> Cryptographic Proof
                            </label>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="proof-inputs">
                                <div id="secret-container">
                                    <span class="text-[10px] text-gray-400 uppercase block mb-1">Secret (Preimage) - <span class="text-red-400">Keep Safe</span></span>
                                    <div class="relative">
                                        <input type="text" id="secret-input" class="w-full input-field rounded-lg p-3 text-sm font-mono text-white secret-blur" readonly value="Generating...">
                                        <button onclick="copyToClipboard('secret-input')" class="absolute right-2 top-2 text-gray-500 hover:text-white"><i class="fa-regular fa-copy"></i></button>
                                    </div>
                                </div>
                                <div id="hash-container">
                                    <span class="text-[10px] text-gray-400 uppercase block mb-1">HashLock (Public)</span>
                                    <div class="relative">
                                        <input type="text" id="hash-input" class="w-full input-field rounded-lg p-3 text-sm font-mono text-gray-300" readonly value="Waiting...">
                                        <button id="copy-hash-btn" onclick="copyToClipboard('hash-input')" class="absolute right-2 top-2 text-gray-500 hover:text-white"><i class="fa-regular fa-copy"></i></button>
                                    </div>
                                </div>
                            </div>
                            <button id="regen-secret-btn" onclick="generateNewSecret()" class="mt-3 text-xs text-gray-400 hover:text-white underline decoration-dotted underline-offset-4">
                                Generate New Secret
                            </button>
                        </div>

                        <!-- Input Fields -->
                        <div class="space-y-4">
                            <div class="grid grid-cols-2 gap-4">
                                <div class="relative">
                                    <label class="block text-sm text-gray-400 mb-1">Asset</label>
                                    <div onclick="toggleTokenSelector()" class="flex items-center gap-2 input-field rounded-lg p-3 cursor-pointer hover:bg-white/10 transition">
                                        <img src="https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026" class="w-6 h-6 rounded-full bg-white p-0.5" id="asset-icon">
                                        <span class="font-bold text-white" id="asset-symbol">XTZ</span>
                                        <i class="fa-solid fa-chevron-down ml-auto text-xs text-gray-500"></i>
                                    </div>
                                    <!-- Token Dropdown -->
                                    <div id="token-dropdown" class="hidden absolute top-full left-0 right-0 mt-1 bg-ether-card border border-white/10 rounded-lg shadow-xl z-50 flex-col max-h-60 overflow-y-auto">
                                        <!-- Tokens will be rendered here by JS -->
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">Amount</label>
                                    <input type="number" id="amount-input" placeholder="0.00" class="w-full input-field rounded-lg p-3 text-white font-mono focus:outline-none">
                                    <div id="selected-token-balance" class="text-xs text-gray-500 mt-1">Balance: -- </div>
                                </div>
                            </div>

                <div>
                    <label class="block text-sm text-gray-400 mb-1 flex items-center gap-1">
                        Counterparty Address
                        <div class="relative group">
                            <span class="w-4 h-4 inline-flex items-center justify-center rounded-full bg-white/10 text-[10px] text-gray-400 cursor-help hover:bg-white/20 transition">?</span>
                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 border border-white/20 rounded-lg text-xs text-gray-300 w-64 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50 shadow-xl">
                                <div class="font-semibold text-white mb-1">Who receives the funds?</div>
                                <p><strong>As Alice (Initiator):</strong> Enter Bob's address on the destination chain (Jstz). This is who can claim your locked funds.</p>
                                <p class="mt-1"><strong>As Bob (Participant):</strong> Enter Alice's address on Etherlink. This is who can claim your locked funds.</p>
                                <p class="mt-1 text-gray-500">Leave empty if unknown (uses zero address).</p>
                                <div class="absolute top-full left-1/2 -translate-x-1/2 border-8 border-transparent border-t-gray-900"></div>
                            </div>
                        </div>
                    </label>
                    <input type="text" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                </div>

                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">Timelock (Mins)</label>
                                    <input type="number" id="timelock-input" value="60" class="w-full input-field rounded-lg p-3 text-white font-mono focus:outline-none">
                                </div>
                                <div class="flex items-end">
                                    <div class="text-xs text-gray-500 mb-3">
                                        <i class="fa-regular fa-clock mr-1"></i> Funds revert if not claimed.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Action Button -->
                        <button onclick="executeAction()" id="main-action-btn" class="btn-primary w-full py-4 rounded-xl text-lg shadow-[0_0_20px_rgba(57,255,20,0.2)] flex items-center justify-center gap-2 group">
                            <span>Initiate Swap</span>
                            <i class="fa-solid fa-arrow-right group-hover:translate-x-1 transition-transform"></i>
                        </button>
                        </div> <!-- End initiate-join-content -->

                        <!-- REDEEM / REFUND CONTENT -->
                        <div id="redeem-content" class="hidden space-y-6">
                            <div class="bg-black/20 rounded-xl p-4 border border-white/5">
                                <p class="text-sm text-gray-400 mb-4 text-center">
                                    <i class="fa-solid fa-circle-info mr-2"></i>
                                    Enter the Swap ID (HashLock) to claim or refund funds.
                                </p>
                                
                                <!-- Swap ID Input -->
                                <div class="mb-4">
                                    <label class="block text-xs text-gray-400 mb-1 flex items-center gap-1">
                                        Swap ID / HashLock
                                        <div class="relative group">
                                            <span class="w-3 h-3 inline-flex items-center justify-center rounded-full bg-white/10 text-[8px] text-gray-400 cursor-help">?</span>
                                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 border border-white/20 rounded text-[10px] text-gray-300 w-48 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50">
                                                The HashLock used when initiating the swap
                                            </div>
                                        </div>
                                    </label>
                                    <input type="text" id="swap-id-input" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                                </div>
                                
                                <!-- Secret Input -->
                                <div class="mb-6">
                                    <label class="block text-xs text-gray-400 mb-1 flex items-center gap-1">
                                        Secret (Required for Claim)
                                        <div class="relative group">
                                            <span class="w-3 h-3 inline-flex items-center justify-center rounded-full bg-white/10 text-[8px] text-gray-400 cursor-help">?</span>
                                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 border border-white/20 rounded text-[10px] text-gray-300 w-48 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50">
                                                The preimage/secret revealed by Alice to claim funds
                                            </div>
                                        </div>
                                    </label>
                                    <input type="text" id="secret-input-claim" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                                </div>

                                <!-- Action Buttons -->
                                <div class="grid grid-cols-2 gap-4">
                                    <button onclick="claimSwap()" id="claim-btn" class="py-4 px-4 rounded-xl bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-semibold flex flex-col items-center justify-center gap-1 transition-all shadow-lg shadow-green-500/20 group">
                                        <div class="flex items-center gap-2">
                                            <i class="fa-solid fa-hand-holding-dollar text-lg"></i>
                                            <span>Claim Funds</span>
                                        </div>
                                        <span class="text-[10px] opacity-70 font-normal">Using Secret</span>
                                    </button>
                                    
                                    <button onclick="refundSwap()" id="refund-btn" class="py-4 px-4 rounded-xl bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-semibold flex flex-col items-center justify-center gap-1 transition-all shadow-lg shadow-red-500/20 group">
                                        <div class="flex items-center gap-2">
                                            <i class="fa-solid fa-rotate-left text-lg"></i>
                                            <span>Refund</span>
                                        </div>
                                        <span class="text-[10px] opacity-70 font-normal">After Timeout</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- MY SWAPS CONTENT -->
                        <div id="myswaps-content" class="hidden space-y-4">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="text-sm font-bold text-gray-300 uppercase tracking-wider">
                                    <i class="fa-solid fa-clock-rotate-left mr-2 text-purple-400"></i>
                                    Your Active Swaps
                                </h3>
                                <button onclick="loadMySwaps()" class="text-xs px-3 py-1 rounded-lg bg-white/5 hover:bg-white/10 text-gray-400 hover:text-white transition">
                                    <i class="fa-solid fa-refresh mr-1"></i> Refresh
                                </button>
                            </div>
                            
                            <!-- Loading State -->
                            <div id="swaps-loading" class="hidden text-center py-8">
                                <i class="fa-solid fa-circle-notch fa-spin text-2xl text-purple-400 mb-2"></i>
                                <p class="text-gray-500 text-sm">Loading your swaps...</p>
                            </div>
                            
                            <!-- Empty State -->
                            <div id="swaps-empty" class="text-center py-8 bg-black/20 rounded-xl border border-dashed border-white/10">
                                <i class="fa-solid fa-inbox text-3xl text-gray-600 mb-2"></i>
                                <p class="text-gray-500 text-sm">No active swaps found</p>
                                <p class="text-gray-600 text-xs mt-1">Initiate or join a swap to see it here</p>
                            </div>
                            
                            <!-- Swaps List -->
                            <div id="swaps-list" class="space-y-3">
                                <!-- Swap cards will be inserted here -->
                            </div>
                        </div>

                    </div>
                </div>
        </div>

            <!-- Right Column: Info & Console -->
            <div class="lg:col-span-5 flex flex-col gap-6">
                
                <!-- Network Status -->
                <div class="glass-card rounded-2xl p-6">
                    <h3 class="text-sm font-mono text-gray-400 mb-4 uppercase tracking-wider">Network Bridge</h3>
            
                    <div class="flex items-center justify-between relative">
                        <!-- Left: Etherlink -->
                        <div class="text-center z-10">
                            <div class="w-14 h-14 rounded-2xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 flex items-center justify-center mx-auto mb-2 shadow-lg relative overflow-hidden group">
                                <div class="absolute inset-0 bg-green-500/10 group-hover:bg-green-500/20 transition"></div>
                                <i class="fa-brands fa-ethereum text-2xl text-green-400"></i>
                            </div>
                            <div class="text-sm font-bold text-gray-200">Etherlink</div>
                            <div class="text-[10px] text-green-500">Connected</div>
                        </div>

                        <!-- Center: Animation -->
                        <div class="flex-1 h-px bg-slate-700 mx-4 relative">
                            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 rounded-full bg-slate-900 border border-slate-700 flex items-center justify-center z-20">
                                <i class="fa-solid fa-arrow-right-arrow-left text-gray-500 text-xs"></i>
                    </div>
                            <div class="absolute top-0 left-0 h-full w-1/2 bg-gradient-to-r from-transparent to-green-500 opacity-50 animate-pulse"></div>
                        </div>

                        <!-- Right: Jstz -->
                        <div class="text-center z-10">
                            <div class="w-14 h-14 rounded-2xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 flex items-center justify-center mx-auto mb-2 shadow-lg relative overflow-hidden group">
                                <div class="absolute inset-0 bg-yellow-500/10 group-hover:bg-yellow-500/20 transition"></div>
                                <i class="fa-solid fa-layer-group text-2xl text-jstz-accent"></i>
                    </div>
                            <div class="text-sm font-bold text-gray-200">Jstz</div>
                            <div class="text-[10px] text-gray-500">Waiting...</div>
                        </div>
                    </div>
                </div>

                <!-- Terminal / Logs -->
                <div class="glass-card rounded-2xl flex flex-col flex-grow overflow-hidden h-96 lg:h-auto border-t-4 border-t-ether-green">
                    <div class="bg-black/40 p-3 flex items-center justify-between border-b border-white/5">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-red-500/50"></div>
                            <div class="w-3 h-3 rounded-full bg-yellow-500/50"></div>
                            <div class="w-3 h-3 rounded-full bg-green-500/50"></div>
                        </div>
                        <div class="text-[10px] font-mono text-gray-500">swap_daemon.js</div>
                    </div>
                    <div id="terminal-body" class="p-4 font-mono text-xs space-y-2 overflow-y-auto flex-grow bg-black/20 max-h-[400px]">
                        <div class="text-gray-500">Last login: <span id="login-time"></span> on tty1</div>
                        <div class="text-green-500/50">Initializing atomic swap protocol...</div>
                        <div class="text-green-500/50">Loaded JS environment.</div>
                        <div class="text-white">> Ready.</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="border-t border-white/5 bg-black/20 py-6 mt-auto">
        <div class="max-w-7xl mx-auto px-4 text-center">
            <p class="text-xs text-gray-500">Built for Etherlink Internal Hackathon</p>
        </div>
    </footer>

    <script>
        // --- REAL CONTRACT INTEGRATION ---

        // Contract Configuration - Per Network
        const NETWORK_CONFIG = {
            // Hardhat Local
            31337: {
                name: 'Hardhat Local',
                rpcUrl: 'http://127.0.0.1:8545',
                htlcAddress: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0',
                explorer: null
            },
            // Etherlink Testnet (Ghostnet) - SHA-256 compatible
            128123: {
                name: 'Etherlink Testnet',
                rpcUrl: 'https://node.ghostnet.etherlink.com',
                htlcAddress: '0x79826f6Ab82C24395123f8419E3aFb995d906bAd',
                explorer: 'https://testnet.explorer.etherlink.com'
            },
            // Etherlink Mainnet
            42793: {
                name: 'Etherlink Mainnet',
                rpcUrl: 'https://node.mainnet.etherlink.com',
                htlcAddress: null, // TODO: Deploy and fill this
                explorer: 'https://explorer.etherlink.com'
            }
        };

        // Default to testnet for real testing
        const DEFAULT_CHAIN_ID = 128123; // Etherlink Testnet

        const CONFIG = {
            // Current Etherlink config (will be updated based on connected network)
            etherlink: {
                contractAddress: NETWORK_CONFIG[DEFAULT_CHAIN_ID]?.htlcAddress || '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                rpcUrl: NETWORK_CONFIG[DEFAULT_CHAIN_ID]?.rpcUrl || 'http://127.0.0.1:8545',
                chainId: DEFAULT_CHAIN_ID,
                abi: [
                    "function initiateSwap(address recipient, bytes32 hashLock, uint256 expiration) external payable returns (bytes32)",
                    "function claimSwap(bytes32 swapId, bytes calldata secret) external returns (bool)",
                    "function refundSwap(bytes32 swapId) external returns (bool)",
                    "function getSwap(bytes32 swapId) external view returns (address recipient, address sender, uint256 amount, uint256 expiration, bytes32 hashLock, uint8 status)",
                    "function swapPresent(bytes32 swapId) external view returns (bool)",
                    "event SwapInitiated(bytes32 indexed swapId, address payable sender, address recipient, uint256 amount, bytes32 hashLock, uint256 expiration)",
                    "event SwapClaimed(bytes32 indexed swapId, address claimer, bytes secret)",
                    "event SwapRefunded(bytes32 indexed swapId, address sender, uint256 amount)"
                ]
            },
            // Jstz HTLC Smart Function
            jstz: {
                // Jstz Privatenet - accessible to everyone
                rpcUrl: 'https://privatenet.jstz.info',
                network: 'privatenet',
                functionAddress: 'jstz://htlc/',
                contractAddress: 'KT19cEGFQGsmtSimKJQFzi9WYrsHGXofq8Hb'
            }
        };

        // ERC20 ABI for token interactions
        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function symbol() view returns (string)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)"
        ];

        // Network Chain IDs
        const CHAIN_IDS = {
            HARDHAT_LOCAL: 31337,
            ETHERLINK_MAINNET: 42793,
            ETHERLINK_TESTNET: 128123
        };

        // Etherlink Tokens - Simplified for POC
        // Only XTZ (native) and WXTZ (wrapped) for atomic swap demonstration
        const TOKENS = {
            XTZ: {
                symbol: 'XTZ',
                name: 'Tezos (Native)',
                address: null, // Native token
                decimals: 18,
                icon: 'https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026',
                isNative: true,
                chains: [CHAIN_IDS.HARDHAT_LOCAL, CHAIN_IDS.ETHERLINK_MAINNET, CHAIN_IDS.ETHERLINK_TESTNET]
            },
            WXTZ: {
                symbol: 'WXTZ',
                name: 'Wrapped XTZ',
                // Addresses per network
                addresses: {
                    [CHAIN_IDS.ETHERLINK_MAINNET]: '0xc9B53AB2679f573e480d01e0f49e2B5CFB7a3EAb',
                    [CHAIN_IDS.ETHERLINK_TESTNET]: '0xB1Ea698633d57705e93b0E40c1077d46CD6A51d8'
                },
                decimals: 18,
                icon: 'https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026',
                isNative: false,
                chains: [CHAIN_IDS.ETHERLINK_MAINNET, CHAIN_IDS.ETHERLINK_TESTNET]
            }
        };

        // Helper to get token address for current network
        function getTokenAddress(tokenSymbol) {
            const token = TOKENS[tokenSymbol];
            if (!token || token.isNative) return null;
            
            // If token has per-network addresses
            if (token.addresses && state.currentChainId) {
                return token.addresses[state.currentChainId] || null;
            }
            // Fallback to single address
            return token.address || null;
        }

        // State
        const state = {
            mode: 'create', // 'create' | 'join'
            step: 1,
            secret: null,
            secretBytes: null,
            hash: null,
            chain: 'etherlink', // 'etherlink' (From Etherlink) | 'jstz' (From Jstz)
            connectedWallet: null, // 'etherlink' | 'jstz' | null
            etherlinkWallet: null,
            etherlinkAddress: null,
            jstzAddress: null,
            provider: null,
            signer: null,
            contract: null,
            currentSwapId: null,
            selectedToken: 'XTZ', // Default token
            tokenBalances: {},
            tokenSelectorOpen: false,
            currentChainId: null // Current network chain ID
        };

        // Utils
        const log = (msg, type = 'info') => {
            const term = document.getElementById('terminal-body');
            const line = document.createElement('div');
            const time = new Date().toLocaleTimeString([], {hour12: false});
            
            let color = 'text-gray-300';
            if (type === 'success') color = 'text-ether-green';
            if (type === 'error') color = 'text-red-400';
            if (type === 'warning') color = 'text-yellow-400';
            if (type === 'system') color = 'text-blue-400';

            line.className = `${color} hover:bg-white/5 p-0.5 rounded`;
            line.innerHTML = `<span class="opacity-50 mr-2">[${time}]</span>${msg}`;
            
            term.appendChild(line);
            term.scrollTop = term.scrollHeight;
        };

        // Helper: Log transaction with explorer link
        const logTx = (txHash, message = 'Transaction') => {
            const networkConfig = NETWORK_CONFIG[state.currentChainId];
            const explorer = networkConfig?.explorer;
            if (explorer) {
                const txUrl = `${explorer}/tx/${txHash}`;
                log(`${message}: <a href="${txUrl}" target="_blank" class="text-ether-green hover:underline">${txHash.substring(0, 18)}... üîó</a>`, 'success');
            } else {
                log(`${message}: ${txHash}`, 'success');
            }
        };

        document.getElementById('login-time').innerText = new Date().toDateString();

        // Generate secret using SHA-256 for cross-chain compatibility (Etherlink + Jstz)
        function generateNewSecret() {
            // Generate 32 random bytes as secret
            const randomBytes = ethers.utils.randomBytes(32);
            const secret = ethers.utils.hexlify(randomBytes);
            
            // Hash using SHA-256 (cross-chain compatible with Solidity and Jstz)
            const hash = ethers.utils.sha256(randomBytes);
            
            state.secret = secret;
            state.secretBytes = randomBytes;
            state.hash = hash;
            
            document.getElementById('secret-input').value = secret;
            document.getElementById('hash-input').value = hash;
            
            log(`Generated new Preimage/Hash pair.`, 'system');
            log(`Hash: ${hash.substring(0, 18)}...`, 'system');
        }

        // Connect to Etherlink (MetaMask or local)
        async function connectEtherlink() {
            try {
                console.log('[DEBUG] Starting Etherlink connection...');
                
                if (typeof window.ethereum !== 'undefined') {
                    // Use MetaMask
                    console.log('[DEBUG] MetaMask detected, requesting accounts...');
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    state.provider = new ethers.providers.Web3Provider(window.ethereum);
                    state.signer = state.provider.getSigner();
                    state.etherlinkAddress = await state.signer.getAddress();
                    console.log('[DEBUG] Connected address:', state.etherlinkAddress);
                    log(`MetaMask connected: ${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`, 'success');
                } else {
                    // Fallback to local Hardhat node
                    console.log('[DEBUG] No MetaMask, falling back to local node');
                    state.provider = new ethers.providers.JsonRpcProvider(CONFIG.etherlink.rpcUrl);
                    state.signer = state.provider.getSigner(0);
                    state.etherlinkAddress = await state.signer.getAddress();
                    log(`Connected to local node: ${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`, 'success');
                }
                
                // Get current chain ID
                const network = await state.provider.getNetwork();
                state.currentChainId = network.chainId;
                console.log('[DEBUG] Connected to chainId:', state.currentChainId);
                
                // Log network info
                const networkConfig = NETWORK_CONFIG[state.currentChainId];
                const networkName = networkConfig?.name || getNetworkName(state.currentChainId);
                log(`Network: ${networkName} (chainId: ${state.currentChainId})`, 'info');
                
                // Update network badge in header
                updateNetworkBadge(state.currentChainId, networkName);
                
                // Check if we're on the wrong network
                const isEtherlinkNetwork = [128123, 42793, 31337].includes(state.currentChainId);
                if (!isEtherlinkNetwork) {
                    log(`‚ö†Ô∏è Wrong network! You are on ${networkName} (chainId: ${state.currentChainId})`, 'warning');
                    log(`Click the network badge to switch to Etherlink Testnet`, 'system');
                    console.log('[DEBUG] Wrong network detected. Expected Etherlink (128123, 42793, or 31337), got:', state.currentChainId);
                }
                
                // Get HTLC contract address for this network
                const htlcAddress = networkConfig?.htlcAddress;
                if (!htlcAddress) {
                    log(`‚ö†Ô∏è HTLC contract not deployed on ${networkName}!`, 'warning');
                    log(`Deploy with: npx hardhat run scripts/deploy.js --network etherlinkTestnet`, 'system');
                    console.log('[DEBUG] No HTLC address for chainId:', state.currentChainId);
                }
                
                // Initialize contract (if address exists)
                if (htlcAddress) {
                    state.contract = new ethers.Contract(
                        htlcAddress,
                        CONFIG.etherlink.abi,
                        state.signer
                    );
                    log(`HTLC Contract: ${htlcAddress.substring(0, 10)}...`, 'success');
                    console.log('[DEBUG] Contract initialized at:', htlcAddress);
                } else {
                    state.contract = null;
                }
                
                // Fetch and log balance
                await fetchAndLogBalance();
                
                // Update UI to reflect connected wallet
                updateWalletConnectionUI('etherlink');
                
                return true;
            } catch (error) {
                console.error('[DEBUG] Connection error:', error);
                log(`Etherlink connection failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        /**
         * Update UI based on which wallet is connected
         * Disables the other wallet button and grays out incompatible options
         */
        function updateWalletConnectionUI(connectedWallet) {
            const etherlinkBtn = document.getElementById('wallet-etherlink');
            const jstzBtn = document.getElementById('wallet-jstz');
            const chainEtherlinkBtn = document.getElementById('chain-etherlink');
            const chainJstzBtn = document.getElementById('chain-jstz');
            
            if (connectedWallet === 'etherlink') {
                // Etherlink wallet connected
                state.connectedWallet = 'etherlink';
                
                // Disable Jstz wallet button
                if (jstzBtn) {
                    jstzBtn.disabled = true;
                    jstzBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    jstzBtn.title = 'Disconnect Etherlink first';
                }
                
                // Gray out Jstz chain option
                if (chainJstzBtn) {
                    chainJstzBtn.classList.add('opacity-40', 'pointer-events-none');
                    chainJstzBtn.title = 'Connect Jstz wallet to use this';
                }
                if (chainEtherlinkBtn) {
                    chainEtherlinkBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainEtherlinkBtn.title = '';
                }
                
                // Auto-select Etherlink chain
                if (state.chain !== 'etherlink') {
                    setChain('etherlink');
                }
                
                log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'system');
                log('üîó MODE ETHERLINK ACTIV√â (Vous √™tes ALICE)', 'success');
                log('üìç Direction: Etherlink ‚Üí Jstz', 'info');
                log('', 'system');
                log('‚úÖ Vous pouvez INITIER un nouveau swap:', 'success');
                log('   1. Cliquez "Initiate" pour g√©n√©rer un hash', 'system');
                log('   2. Cliquez "Initiate Swap" pour verrouiller vos XTZ', 'system');
                log('   3. Partagez le HASH avec Bob', 'system');
                log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'system');
                
            } else if (connectedWallet === 'jstz') {
                // Jstz wallet connected
                state.connectedWallet = 'jstz';
                
                // Disable Etherlink wallet button
                if (etherlinkBtn) {
                    etherlinkBtn.disabled = true;
                    etherlinkBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    etherlinkBtn.title = 'Disconnect Jstz first';
                }
                
                // Gray out Etherlink chain option
                if (chainEtherlinkBtn) {
                    chainEtherlinkBtn.classList.add('opacity-40', 'pointer-events-none');
                    chainEtherlinkBtn.title = 'Connect Etherlink wallet to use this';
                }
                if (chainJstzBtn) {
                    chainJstzBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainJstzBtn.title = '';
                }
                
                // Auto-select Jstz chain
                if (state.chain !== 'jstz') {
                    setChain('jstz');
                }
                
                log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'system');
                log('üîó MODE JSTZ ACTIV√â (Vous √™tes BOB)', 'warning');
                log('üìç Direction: Jstz ‚Üí Etherlink', 'info');
                log('', 'system');
                log('‚ö†Ô∏è IMPORTANT: Pour initier un swap depuis Jstz:', 'warning');
                log('   Alice doit d\'abord avoir lock√© sur Etherlink!', 'info');
                log('   Utilisez "Join" et collez le hash d\'Alice.', 'system');
                log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ', 'system');
                
            } else {
                // No wallet connected - enable both
                state.connectedWallet = null;
                
                // Re-enable both wallet buttons
                if (etherlinkBtn) {
                    etherlinkBtn.disabled = false;
                    etherlinkBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    etherlinkBtn.title = '';
                }
                if (jstzBtn) {
                    jstzBtn.disabled = false;
                    jstzBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    jstzBtn.title = '';
                }
                
                // Re-enable both chain options and reset to default (Etherlink active)
                if (chainEtherlinkBtn) {
                    chainEtherlinkBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainEtherlinkBtn.title = '';
                }
                if (chainJstzBtn) {
                    chainJstzBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainJstzBtn.title = '';
                }
                
                // Reset to default chain selection
                setChain('etherlink');
            }
        }
        
        /**
         * Disconnect wallet and reset UI
         */
        function disconnectWallet() {
            state.etherlinkAddress = null;
            state.jstzAddress = null;
            state.provider = null;
            state.signer = null;
            state.contract = null;
            state.connectedWallet = null;
            
            // Reset Etherlink button
            const etherlinkBtn = document.getElementById('wallet-etherlink');
            const etherlinkText = document.getElementById('wallet-etherlink-text');
            const balanceSpan = document.getElementById('wallet-balance');
            if (etherlinkBtn) {
                etherlinkText.textContent = 'Connect Etherlink';
                balanceSpan.classList.add('hidden');
            }
            
            // Reset Jstz button
            const jstzBtn = document.getElementById('wallet-jstz');
            const jstzText = document.getElementById('wallet-jstz-text');
            if (jstzBtn && jstzText) {
                jstzText.textContent = 'Connect Jstz';
            }
            
            // Re-enable both wallet buttons
            updateWalletConnectionUI(null);
            
            log('Wallet disconnected', 'info');
        }
        
        // Update the network badge in header
        function updateNetworkBadge(chainId, networkName) {
            const badge = document.getElementById('network-badge');
            const dot = document.getElementById('network-dot');
            const name = document.getElementById('network-name');
            
            if (!badge || !dot || !name) return;
            
            name.textContent = networkName;
            
            // Color based on network
            if (chainId === 128123) {
                // Etherlink Testnet - Green (correct network)
                dot.className = 'w-2 h-2 rounded-full bg-ether-green animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-ether-green/50 cursor-pointer hover:border-ether-green transition';
                name.className = 'text-xs text-ether-green';
            } else if (chainId === 42793) {
                // Etherlink Mainnet - Blue
                dot.className = 'w-2 h-2 rounded-full bg-blue-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-blue-500/50 cursor-pointer hover:border-blue-500 transition';
                name.className = 'text-xs text-blue-400';
            } else if (chainId === 31337) {
                // Hardhat Local - Yellow
                dot.className = 'w-2 h-2 rounded-full bg-yellow-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-yellow-500/50 cursor-pointer hover:border-yellow-500 transition';
                name.className = 'text-xs text-yellow-400';
            } else {
                // Wrong network - Red
                dot.className = 'w-2 h-2 rounded-full bg-red-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-red-500/50 cursor-pointer hover:border-red-500 transition';
                name.className = 'text-xs text-red-400';
            }
        }
        
        // Fetch and log balance with debug info
        async function fetchAndLogBalance() {
            if (!state.provider || !state.etherlinkAddress) {
                console.log('[DEBUG] Cannot fetch balance - provider or address missing');
                return;
            }
            
            try {
                console.log('[DEBUG] Fetching native balance for:', state.etherlinkAddress);
                const balance = await state.provider.getBalance(state.etherlinkAddress);
                const balanceEth = ethers.utils.formatEther(balance);
                console.log('[DEBUG] Native balance (wei):', balance.toString());
                console.log('[DEBUG] Native balance (XTZ):', balanceEth);
                log(`Balance: ${parseFloat(balanceEth).toFixed(4)} XTZ`, 'info');
                
                // Update balance display
                const balanceDisplay = document.querySelector('.text-gray-500');
                if (balanceDisplay && balanceDisplay.textContent.includes('Balance:')) {
                    balanceDisplay.textContent = `Balance: ${parseFloat(balanceEth).toFixed(4)} XTZ`;
                }
            } catch (error) {
                console.error('[DEBUG] Error fetching balance:', error);
                log(`Error fetching balance: ${error.message}`, 'error');
            }
        }

        // Add Etherlink network to MetaMask
        async function addEtherlinkToMetaMask(chainId = 128123) {
            if (typeof window.ethereum === 'undefined') {
                log('MetaMask not installed', 'error');
                return false;
            }
            
            const networkConfig = NETWORK_CONFIG[chainId];
            if (!networkConfig) {
                log('Unknown network', 'error');
                return false;
            }

            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: '0x' + chainId.toString(16),
                        chainName: networkConfig.name,
                        nativeCurrency: {
                            name: 'Tezos',
                            symbol: 'XTZ',
                            decimals: 18
                        },
                        rpcUrls: [networkConfig.rpcUrl],
                        blockExplorerUrls: networkConfig.explorer ? [networkConfig.explorer] : null
                    }]
                });
                log(`${networkConfig.name} added to MetaMask!`, 'success');
                return true;
            } catch (error) {
                log(`Failed to add network: ${error.message}`, 'error');
                return false;
            }
        }

        // Switch MetaMask to Etherlink network
        async function switchToEtherlink(chainId = 128123) {
            if (typeof window.ethereum === 'undefined') return false;
            
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x' + chainId.toString(16) }]
                });
                return true;
            } catch (error) {
                // Chain not added, try to add it
                if (error.code === 4902) {
                    return await addEtherlinkToMetaMask(chainId);
                }
                log(`Failed to switch network: ${error.message}`, 'error');
                return false;
            }
        }

        // Get human-readable network name
        function getNetworkName(chainId) {
            switch (chainId) {
                case CHAIN_IDS.HARDHAT_LOCAL: return 'Hardhat Local';
                case CHAIN_IDS.ETHERLINK_MAINNET: return 'Etherlink Mainnet';
                case CHAIN_IDS.ETHERLINK_TESTNET: return 'Etherlink Testnet';
                default: return `Unknown (${chainId})`;
            }
        }

        // Check if token is available on current network
        function isTokenAvailable(tokenSymbol) {
            const token = TOKENS[tokenSymbol];
            if (!token) {
                console.log(`[DEBUG] Token ${tokenSymbol} not found in TOKENS`);
                return false;
            }
            if (!state.currentChainId) {
                console.log(`[DEBUG] No chainId set, defaulting to native only for ${tokenSymbol}`);
                return token.isNative;
            }
            const available = token.chains.includes(state.currentChainId);
            console.log(`[DEBUG] Token ${tokenSymbol}: chainId=${state.currentChainId}, supportedChains=[${token.chains.join(',')}], available=${available}`);
            return available;
        }

        // Get available tokens for current network
        function getAvailableTokens() {
            return Object.entries(TOKENS)
                .filter(([symbol, token]) => isTokenAvailable(symbol))
                .reduce((acc, [symbol, token]) => {
                    acc[symbol] = token;
                    return acc;
                }, {});
        }

        // Jstz API calls
        /**
         * Jstz Request Handler
         * Uses Jstz wallet extension if available, otherwise shows CLI commands
         */
        const encoder = new TextEncoder();
        const decoder = new TextDecoder('utf-8');
        
        async function jstzRequest(method, path, body = null) {
            const contractAddress = CONFIG.jstz.contractAddress;
            const rpcUrl = CONFIG.jstz.rpcUrl;
            
            log(`üì§ Jstz: ${method} ${path}`, 'system');
            
            // Check if extension is available
            const hasExtension = isJstzExtensionInstalled();
            
            if (!hasExtension) {
                // No extension - show CLI command
                const cliCmd = `jstz run "jstz://${contractAddress}${path}" -n privatenet -m POST -d '${JSON.stringify(body || {})}'`;
                log(`‚ö†Ô∏è Jstz wallet extension not detected`, 'warning');
                log(`üìã Run this CLI command instead:`, 'system');
                log(`<code class="bg-black/50 px-2 py-1 rounded text-xs break-all">${cliCmd}</code>`, 'info');
                
                // Return simulated response for demo
                return simulateJstzResponse(path, body);
            }
            
            // Extension available - use it!
            try {
                log(`üîê Requesting signature from Jstz wallet...`, 'warning');
                
                // Build the operation
                const operation = {
                    _type: 'RunFunction',
                    uri: `jstz://${contractAddress}${path}`,
                    method: 'POST',
                    headers: {},
                    body: body ? Array.from(encoder.encode(JSON.stringify(body))) : [],
                    gasLimit: 100000
                };
                
                console.log('[JSTZ] Operation to sign:', operation);
                
                // Request signature from extension
                const signResponse = await requestJstzSignature(operation);
                
                log(`‚úÖ Signature received from ${signResponse.accountAddress.substring(0, 10)}...`, 'success');
                console.log('[JSTZ] Sign response:', signResponse);
                
                // Inject the signed operation
                log(`üì° Injecting operation to Jstz privatenet...`, 'warning');
                
                const injectResponse = await fetch(`${rpcUrl}/operations`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        inner: signResponse.operation,
                        signature: signResponse.signature
                    })
                });
                
                if (!injectResponse.ok) {
                    const errorText = await injectResponse.text();
                    throw new Error(`Injection failed: ${errorText}`);
                }
                
                const result = await injectResponse.json();
                console.log('[JSTZ] Injection result:', result);
                
                // Parse response body if present
                let parsedResult = result;
                if (result.result?.inner?.body) {
                    try {
                        const bodyBytes = new Uint8Array(result.result.inner.body);
                        parsedResult = JSON.parse(decoder.decode(bodyBytes));
                    } catch (e) {
                        // Keep original result
                    }
                }
                
                log(`‚úÖ Jstz operation successful!`, 'success');
                return parsedResult;
                
            } catch (error) {
                console.error('[JSTZ] Extension error:', error);
                log(`‚ùå Jstz error: ${error.message}`, 'error');
                
                // Fallback to CLI
                const cliCmd = `jstz run "jstz://${contractAddress}${path}" -n privatenet -m POST -d '${JSON.stringify(body || {})}'`;
                log(`üí° Fallback - use CLI: <code class="bg-black/50 px-2 py-1 rounded text-xs">${cliCmd}</code>`, 'system');
                
                throw error;
            }
        }
        
        // Simulate Jstz response for demo when extension not available
        function simulateJstzResponse(path, body) {
            if (path === '/initiate') {
                return {
                    success: true,
                    event: 'SwapInitiated',
                    data: {
                        hashlock: body?.hashLock || body?.hashlock,
                        sender: state.jstzAddress || 'tz1...',
                        amount: body?.amount,
                        status: 'OPEN'
                    },
                    simulated: true
                };
            }
            
            if (path === '/claim') {
                return {
                    success: true,
                    event: 'SwapClaimed',
                    data: { hashlock: body?.hashLock || body?.hashlock },
                    simulated: true
                };
            }
            
            if (path === '/refund') {
                return {
                    success: true,
                    event: 'SwapRefunded',
                    simulated: true
                };
            }
            
            return { found: false, simulated: true };
        }
        

        // ============================================
        // TOKEN & BALANCE MANAGEMENT
        // ============================================

        // Get balance for a specific token
        async function getTokenBalance(tokenSymbol) {
            if (!state.provider || !state.etherlinkAddress) return '0';
            
            const token = TOKENS[tokenSymbol];
            if (!token) return '0';
            
            // Check if token is available on current network
            if (!isTokenAvailable(tokenSymbol)) {
                return 'N/A';
            }

            try {
                if (token.isNative) {
                    // Native XTZ balance
                    const balance = await state.provider.getBalance(state.etherlinkAddress);
                    return ethers.utils.formatUnits(balance, token.decimals);
                } else {
                    // ERC20 token balance - use getTokenAddress for per-network addresses
                    const tokenAddress = getTokenAddress(tokenSymbol);
                    if (!tokenAddress) return 'N/A';
                    
                    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, state.provider);
                    const balance = await tokenContract.balanceOf(state.etherlinkAddress);
                    return ethers.utils.formatUnits(balance, token.decimals);
                }
            } catch (error) {
                // Token contract doesn't exist on this network
                console.warn(`Token ${tokenSymbol} not available on current network`);
                return 'N/A';
            }
        }

        // Fetch all token balances
        async function fetchAllBalances() {
            if (!state.provider || !state.etherlinkAddress) return;

            const availableTokens = getAvailableTokens();
            const tokenCount = Object.keys(availableTokens).length;
            log(`Fetching balances for ${tokenCount} token(s)...`, 'system');
            
            for (const [symbol, token] of Object.entries(TOKENS)) {
                if (isTokenAvailable(symbol)) {
                    const balance = await getTokenBalance(symbol);
                    state.tokenBalances[symbol] = balance;
                } else {
                    state.tokenBalances[symbol] = 'N/A';
                }
            }

            // Update UI
            updateBalanceDisplay();
            renderTokenDropdown(); // Re-render with updated balances
            log('Balances updated', 'success');
        }

        // Update balance display in UI
        function updateBalanceDisplay() {
            const balanceEl = document.getElementById('selected-token-balance');
            const walletBalanceEl = document.getElementById('wallet-balance');
            
            if (balanceEl && state.selectedToken) {
                const balance = state.tokenBalances[state.selectedToken];
                if (balance === 'N/A' || !isTokenAvailable(state.selectedToken)) {
                    balanceEl.innerText = `Balance: N/A (not on this network)`;
                } else {
                    const formatted = parseFloat(balance || '0').toFixed(4);
                    balanceEl.innerText = `Balance: ${formatted} ${state.selectedToken}`;
                }
            }
            
            // Update wallet button with XTZ balance
            if (walletBalanceEl && state.tokenBalances['XTZ'] && state.tokenBalances['XTZ'] !== 'N/A') {
                const xtzBalance = parseFloat(state.tokenBalances['XTZ']).toFixed(2);
                walletBalanceEl.innerText = `${xtzBalance} XTZ`;
            }
        }

        // Select a token
        function selectToken(symbol) {
            const token = TOKENS[symbol];
            if (!token) return;

            state.selectedToken = symbol;
            
            // Update UI
            document.getElementById('asset-icon').src = token.icon;
            document.getElementById('asset-symbol').innerText = token.symbol;
            
            // Close dropdown
            toggleTokenSelector(false);
            
            // Update balance display
            updateBalanceDisplay();
            
            log(`Selected token: ${token.name} (${token.symbol})`, 'info');
        }

        // Toggle token selector dropdown
        function toggleTokenSelector(forceState = null) {
            const dropdown = document.getElementById('token-dropdown');
            if (!dropdown) return;

            state.tokenSelectorOpen = forceState !== null ? forceState : !state.tokenSelectorOpen;
            
            if (state.tokenSelectorOpen) {
                dropdown.classList.remove('hidden');
                dropdown.classList.add('flex');
            } else {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('flex');
            }
        }

        // Render token list in dropdown
        function renderTokenDropdown() {
            const dropdown = document.getElementById('token-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';
            
            for (const [symbol, token] of Object.entries(TOKENS)) {
                const balance = state.tokenBalances[symbol] || '0';
                const isAvailable = isTokenAvailable(symbol);
                const isSelected = symbol === state.selectedToken;
                
                // Format balance
                let formattedBalance;
                if (!isAvailable || balance === 'N/A') {
                    formattedBalance = 'N/A';
                } else {
                    formattedBalance = parseFloat(balance).toFixed(4);
                }
                
                const item = document.createElement('div');
                item.className = `flex items-center justify-between p-3 transition ${
                    isAvailable 
                        ? `hover:bg-white/10 cursor-pointer ${isSelected ? 'bg-ether-green/10' : ''}` 
                        : 'opacity-40 cursor-not-allowed'
                }`;
                
                if (isAvailable) {
                    item.onclick = () => selectToken(symbol);
                }
                
                const tokenAddr = getTokenAddress(symbol);
                item.innerHTML = `
                    <div class="flex items-center gap-3">
                        <img src="${token.icon}" class="w-8 h-8 rounded-full bg-white p-0.5 ${!isAvailable ? 'grayscale' : ''}" alt="${token.symbol}">
                        <div>
                            <div class="font-bold ${isAvailable ? 'text-white' : 'text-gray-500'}">${token.symbol}</div>
                            <div class="text-xs text-gray-400">${token.name}</div>
                            ${!isAvailable ? '<div class="text-[10px] text-yellow-500">Not on this network</div>' : ''}
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-sm font-mono ${isAvailable ? 'text-white' : 'text-gray-500'}">${formattedBalance}</div>
                        ${!token.isNative && tokenAddr ? `<div class="text-[10px] text-gray-500 truncate max-w-[80px]">${tokenAddr.substring(0, 10)}...</div>` : ''}
                    </div>
                `;
                dropdown.appendChild(item);
            }
        }

        // Add to MetaMask wallet
        async function addTokenToWallet(symbol) {
            const token = TOKENS[symbol];
            if (!token || token.isNative) {
                log('Cannot add native token to wallet', 'warning');
                return;
            }

            if (typeof window.ethereum === 'undefined') {
                log('MetaMask not detected', 'error');
                return;
            }

            try {
                await window.ethereum.request({
                    method: 'wallet_watchAsset',
                    params: {
                        type: 'ERC20',
                        options: {
                            address: token.address,
                            symbol: token.symbol,
                            decimals: token.decimals,
                            image: token.icon
                        }
                    }
                });
                log(`${token.symbol} added to wallet`, 'success');
            } catch (error) {
                log(`Failed to add token: ${error.message}`, 'error');
            }
        }

        function setChain(chain) {
            // Check if switching to a chain requires the correct wallet
            if (chain === 'etherlink' && state.connectedWallet === 'jstz') {
                log('‚ö†Ô∏è Cannot select Etherlink chain with Jstz wallet connected', 'warning');
                return;
            }
            if (chain === 'jstz' && state.connectedWallet === 'etherlink') {
                log('‚ö†Ô∏è Cannot select Jstz chain with Etherlink wallet connected', 'warning');
                return;
            }
            
            state.chain = chain;
            const btnEth = document.getElementById('chain-etherlink');
            const btnJstz = document.getElementById('chain-jstz');

            // Reset styles
            const activeClass = "border-ether-green bg-ether-green/10 text-white";
            const inactiveClass = "border-transparent text-gray-400 hover:text-white hover:bg-white/5";
            const grayedClass = "opacity-40 pointer-events-none";

            if (chain === 'etherlink') {
                btnEth.className = `relative py-3 rounded-lg transition-all group overflow-hidden ${activeClass}`;
                // Keep jstz grayed if etherlink wallet connected
                const jstzClass = state.connectedWallet === 'etherlink' 
                    ? `relative py-3 rounded-lg transition-all group ${inactiveClass} ${grayedClass}`
                    : `relative py-3 rounded-lg transition-all group ${inactiveClass}`;
                btnJstz.className = jstzClass;
                log("üìç Direction: Etherlink ‚Üí Jstz", 'info');
            } else {
                btnJstz.className = `relative py-3 rounded-lg transition-all group overflow-hidden border-jstz-accent bg-jstz-accent/10 text-white`;
                // Keep etherlink grayed if jstz wallet connected
                const ethClass = state.connectedWallet === 'jstz'
                    ? `relative py-3 rounded-lg transition-all group ${inactiveClass} ${grayedClass}`
                    : `relative py-3 rounded-lg transition-all group ${inactiveClass}`;
                btnEth.className = ethClass;
                log("üìç Direction: Jstz ‚Üí Etherlink", 'info');
            }
            
            // Update balance display for selected token
            updateBalanceDisplay();
        }

        function setTab(mode) {
            state.mode = mode;
            const btnCreate = document.getElementById('tab-create');
            const btnJoin = document.getElementById('tab-join');
            const btnRedeem = document.getElementById('tab-redeem');
            const btnMySwaps = document.getElementById('tab-myswaps');
            const actionBtn = document.getElementById('main-action-btn');
            const secretSection = document.getElementById('secret-section');
            const timelockInput = document.getElementById('timelock-input');
            
            // Content Sections
            const initiateJoinContent = document.getElementById('initiate-join-content');
            const redeemContent = document.getElementById('redeem-content');
            const myswapsContent = document.getElementById('myswaps-content');
            
            // Input Containers
            const secretContainer = document.getElementById('secret-container');
            const hashContainer = document.getElementById('hash-container');
            const proofInputs = document.getElementById('proof-inputs');
            const hashInput = document.getElementById('hash-input');
            const copyHashBtn = document.getElementById('copy-hash-btn');
            const regenSecretBtn = document.getElementById('regen-secret-btn');

            // Reset Button State
            actionBtn.disabled = false;
            actionBtn.onclick = executeAction;
            actionBtn.classList.remove('bg-ether-green', 'text-black');

            // Reset Tab Styles
            const inactiveStyle = "flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all";
            btnCreate.className = inactiveStyle;
            btnJoin.className = inactiveStyle;
            btnRedeem.className = inactiveStyle;
            btnMySwaps.className = inactiveStyle;
            
            // Hide all content sections
            initiateJoinContent.classList.add('hidden');
            redeemContent.classList.add('hidden');
            myswapsContent.classList.add('hidden');

            if (mode === 'redeem') {
                // REDEEM MODE
                btnRedeem.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-purple-600 shadow-lg transition-all";
                redeemContent.classList.remove('hidden');
                log("Switched to Redeem / Refund Mode", 'info');
                return;
            }
            
            if (mode === 'myswaps') {
                // MY SWAPS MODE
                btnMySwaps.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-gradient-to-r from-purple-600 to-pink-600 shadow-lg transition-all";
                myswapsContent.classList.remove('hidden');
                log("Switched to My Swaps", 'info');
                // Auto-load swaps when tab is opened
                loadMySwaps();
                return;
            }
            
            // INITIATE or JOIN MODE
            initiateJoinContent.classList.remove('hidden');

            if (mode === 'create') {
                btnCreate.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-ether-border shadow-lg transition-all";
                
                // SHOW Secret Gen UI
                secretSection.classList.remove('opacity-50', 'pointer-events-none', 'grayscale');
                secretContainer.style.display = 'block';
                proofInputs.classList.remove('grid-cols-1');
                proofInputs.classList.add('md:grid-cols-2');
                
                regenSecretBtn.style.display = 'block';
                copyHashBtn.style.display = 'block';
                
                // Hash Input Readonly
                hashInput.readOnly = true;
                hashInput.classList.add('text-gray-300');
                hashInput.classList.remove('text-white', 'bg-white/5');
                
                generateNewSecret();
                
                // Reset Timelock
                if(timelockInput) timelockInput.value = 60;

                actionBtn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right group-hover:translate-x-1 transition-transform"></i>`;
                actionBtn.className = "btn-primary w-full py-4 rounded-xl text-lg shadow-[0_0_20px_rgba(57,255,20,0.2)] flex items-center justify-center gap-2 group";
                
                log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ", 'system');
                log("üë§ MODE: ALICE (Initiator)", 'success');
                log("üìã Vous CR√âEZ un nouveau swap", 'info');
                log("1Ô∏è‚É£ G√©n√©rez un secret et un hash", 'system');
                log("2Ô∏è‚É£ Cliquez 'Initiate Swap' pour verrouiller vos fonds", 'system');
                log("3Ô∏è‚É£ Partagez le HASH avec Bob (pas le secret!)", 'system');
                log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ", 'system');
            } else {
                btnJoin.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-black bg-jstz-accent shadow-lg transition-all";
                
                // HIDE Secret Gen UI, SHOW Manual Hash Input
                secretSection.classList.remove('opacity-50', 'pointer-events-none', 'grayscale'); // Keep active for input
                secretContainer.style.display = 'none';
                proofInputs.classList.remove('md:grid-cols-2');
                proofInputs.classList.add('grid-cols-1');
                
                regenSecretBtn.style.display = 'none';
                copyHashBtn.style.display = 'none';
                
                // Make Hash Input Editable
                hashInput.readOnly = false;
                hashInput.value = "";
                hashInput.placeholder = "Paste HashLock here (0x...)";
                hashInput.classList.remove('text-gray-300');
                hashInput.classList.add('text-white', 'bg-white/5');
                hashInput.focus();

                // Enforce Timelock < Alice's (e.g. 30 mins)
                if(timelockInput) timelockInput.value = 30;

                actionBtn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                actionBtn.className = "w-full py-4 rounded-xl text-lg font-bold bg-jstz-accent text-black shadow-lg flex items-center justify-center gap-2 hover:brightness-110 transition-all";
                
                log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ", 'system');
                log("üë§ MODE: BOB (Participant)", 'warning');
                log("üìã Vous R√âPONDEZ √† un swap existant", 'info');
                log("‚ö†Ô∏è PR√âREQUIS: Alice doit avoir D√âJ√Ä verrouill√© ses fonds!", 'warning');
                log("1Ô∏è‚É£ Collez le HASH re√ßu d'Alice", 'system');
                log("2Ô∏è‚É£ Le syst√®me v√©rifie qu'Alice a bien lock√©", 'system');
                log("3Ô∏è‚É£ Cliquez 'Match Swap' pour verrouiller vos fonds", 'system');
                log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ", 'system');
            }
        }

        function updateProgress(step) {
            state.step = step;
            const progressBar = document.getElementById('progress-bar');
            
            // Reset all
            [1,2,3,4].forEach(i => {
                const container = document.getElementById(`step-${i}`);
                const dot = container.querySelector('.step-dot');
                
                dot.classList.remove('active', 'completed');
                dot.innerHTML = i;
                
                if (i < step) {
                    dot.classList.add('completed');
                    dot.innerHTML = '<i class="fa-solid fa-check"></i>';
                } else if (i === step) {
                    dot.classList.add('active');
        }
            });

            // Bar width
            const percentage = ((step - 1) / 3) * 100;
            progressBar.style.width = `${percentage}%`;
        }

        // ============================================
        // REAL CONTRACT INTERACTIONS
        // ============================================

        // Initiate swap on Etherlink (Alice locks ETH)
        async function initiateOnEtherlink() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const counterpartyInput = document.querySelector('input[placeholder="0x..."]');
            const timelockInput = document.getElementById('timelock-input');
            const timelockMins = parseInt(timelockInput?.value || 60);
            
            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("‚ùå Please enter a valid amount (> 0)", 'error');
                return;
            }
            
            // 2. Validate hashlock exists and is properly formatted
            if (!state.hash || !isValidHashLock(state.hash)) {
                log("‚ùå Invalid HashLock. Generate a new secret first.", 'error');
                return;
            }
            
            // 3. Validate secret exists (needed for claiming later)
            if (!state.secret) {
                log("‚ùå Secret not found. Generate a new secret first.", 'error');
                return;
            }
            
            // 4. Validate timelock (minimum 5 minutes for safety)
            if (timelockMins < 5) {
                log("‚ùå Timelock must be at least 5 minutes for safety", 'error');
                return;
            }

            // Connect if not connected
            if (!state.provider) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }

            // Check if contract is deployed on this network
            if (!state.contract) {
                const networkName = NETWORK_CONFIG[state.currentChainId]?.name || 'this network';
                log(`‚ùå HTLC contract not deployed on ${networkName}!`, 'error');
                log('Deploy with: npx hardhat run scripts/deploy.js --network etherlinkTestnet', 'system');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking for duplicates...`;
            
            // ========== DUPLICATE CHECK ==========
            // 5. Check if swap with this hashlock already exists
            log('Checking if swap already exists...', 'warning');
            const existingSwap = await verifySwapOnEtherlink(state.hash);
            if (existingSwap.valid && existingSwap.swap) {
                log(`‚ùå A swap with this HashLock already exists!`, 'error');
                log(`State: ${['EMPTY', 'ACTIVE', 'CLAIMED', 'REFUNDED'][existingSwap.swap.state]}`, 'info');
                log(`Generate a new secret to create a new swap.`, 'system');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log('‚úì HashLock is unique', 'success');
            
            // ========== BALANCE CHECK ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking balance...`;
            
            // 6. Check user has enough balance
            const balance = await state.provider.getBalance(state.etherlinkAddress);
            const amountWei = ethers.utils.parseEther(amount);
            if (balance.lt(amountWei)) {
                const balanceEth = ethers.utils.formatEther(balance);
                log(`‚ùå Insufficient balance!`, 'error');
                log(`Required: ${amount} XTZ, Available: ${parseFloat(balanceEth).toFixed(4)} XTZ`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log('‚úì Sufficient balance', 'success');
            
            // ========== EXECUTE INITIATE ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Initiating Swap...`;

            try {
                const recipient = counterpartyInput?.value || ethers.constants.AddressZero;
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                
                log(`Initiating swap on Etherlink...`, 'warning');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`HashLock: ${state.hash.substring(0, 18)}...`, 'info');
                log(`Expiration: ${new Date(expiration * 1000).toLocaleTimeString()} (${timelockMins} mins)`, 'info');
                if (recipient !== ethers.constants.AddressZero) {
                    log(`Recipient: ${recipient.substring(0, 10)}...`, 'info');
                }

                const tx = await state.contract.initiateSwap(
                    recipient,
                    state.hash,
                    expiration,
                    { value: amountWei }
                );

                logTx(tx.hash, 'üì§ Transaction sent');
                
                const receipt = await tx.wait();
                
                state.currentSwapId = state.hash;
                
                log(`‚úÖ Swap initiated on Etherlink!`, 'success');
                logTx(receipt.hash || tx.hash, '‚úÖ Confirmed');
                log(`SwapId: ${state.currentSwapId.substring(0, 18)}...`, 'info');
                log(`Funds Locked: ${amount} ETH`, 'success');
                
                updateProgress(2);
                btn.innerHTML = `<span>Waiting for Bob on Jstz...</span>`;
                
                log(``, 'system');
                log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'system');
                log(`üéâ SWAP INITI√â AVEC SUCC√àS!`, 'success');
                log(``, 'system');
                log(`üìã PROCHAINE √âTAPE:`, 'warning');
                log(`   Partagez ce HASH avec Bob:`, 'info');
                log(`   ${state.hash}`, 'system');
                log(``, 'system');
                log(`üë§ BOB DOIT:`, 'info');
                log(`   1. Se connecter avec son wallet Jstz`, 'system');
                log(`   2. Cliquer sur "Join" et coller le hash`, 'system');
                log(`   3. Cliquer "Match Swap" pour verrouiller ses fonds`, 'system');
                log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'system');
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.currentSwapId, state.secret);
                log("Go to 'Redeem / Refund' tab to claim or refund later", 'system');
                
                // Enable claim button after Bob participates
                setTimeout(() => {
                    log("Ready to claim on Jstz (when Bob has locked funds)", 'system');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Waiting for Bob...</span>`;
                    // No onClick needed here, user should go to Redeem tab
                    updateProgress(3);
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // Initiate swap on Jstz (Bob locks XTZ)
        async function initiateOnJstz() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const hashInput = document.getElementById('hash-input');
            const hashlock = hashInput.value;
            const timelockInput = document.getElementById('timelock-input');
            const timelockMins = parseInt(timelockInput?.value || 30);

            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("‚ùå Please enter a valid amount (> 0)", 'error');
                return;
            }

            // 2. Validate hashlock format
            if (!hashlock || !isValidHashLock(hashlock)) {
                log("‚ùå Please enter a valid HashLock (0x + 64 hex characters)", 'error');
                log("Get the HashLock from Alice who initiated the swap", 'info');
                return;
            }
            
            // 3. Validate timelock (Bob's timelock should be shorter than Alice's)
            if (timelockMins < 2) {
                log("‚ùå Timelock must be at least 2 minutes", 'error');
                return;
            }
            
            // 4. Warning if timelock is too long (should be shorter than Alice's)
            if (timelockMins >= 60) {
                log("‚ö†Ô∏è Warning: Your timelock should be shorter than Alice's for safety", 'warning');
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying Alice's swap...`;
            
            // ========== VERIFY ALICE'S SWAP EXISTS ==========
            // 5. Check that Alice has already locked funds on Etherlink with this hashlock
            log("Checking if Alice has locked funds on Etherlink...", 'warning');
            const aliceSwap = await verifySwapOnEtherlink(hashlock, SwapState.ACTIVE);
            
            if (!aliceSwap.valid) {
                log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'system');
                log(`‚ùå ERREUR: Aucun swap trouv√© sur Etherlink!`, 'error');
                log(``, 'system');
                log(`üìã Ce que √ßa signifie:`, 'warning');
                log(`   Alice n'a pas encore verrouill√© ses fonds`, 'info');
                log(`   avec ce HashLock sur Etherlink.`, 'info');
                log(``, 'system');
                log(`‚úÖ Ce que vous devez faire:`, 'success');
                log(`   1. Demandez √† Alice de d'abord initier le swap`, 'system');
                log(`   2. Alice doit cliquer "From Etherlink" avec ce hash`, 'system');
                log(`   3. Puis revenez ici pour "Match Swap"`, 'system');
                log(``, 'system');
                log(`üîë HashLock attendu: ${hashlock.substring(0, 20)}...`, 'info');
                log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'system');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            log(`‚úì Found Alice's swap: ${aliceSwap.swap.amount} XTZ locked`, 'success');
            log(`‚úì Expires: ${aliceSwap.swap.expirationDate}`, 'success');
            
            // 6. Check Alice's swap hasn't expired
            if (aliceSwap.swap.isExpired) {
                log("‚ùå Alice's swap has expired! Don't lock your funds.", 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            // 7. Check there's enough time for Bob's timelock to be shorter
            const aliceExpiration = aliceSwap.swap.expiration;
            const now = Math.floor(Date.now() / 1000);
            const aliceRemainingMins = Math.floor((aliceExpiration - now) / 60);
            
            if (timelockMins >= aliceRemainingMins) {
                log(`‚ùå Your timelock (${timelockMins}m) must be shorter than Alice's remaining time (${aliceRemainingMins}m)`, 'error');
                log(`Recommended: Set timelock to ${Math.floor(aliceRemainingMins / 2)} minutes`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log(`‚úì Timelock is safe (${timelockMins}m < ${aliceRemainingMins}m remaining)`, 'success');
            
            // ========== CHECK FOR DUPLICATE ON JSTZ ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking for duplicates on Jstz...`;
            
            // 8. Check if swap with this hashlock already exists on Jstz
            const existingJstzSwap = await verifySwapOnJstz(hashlock);
            if (existingJstzSwap.valid && existingJstzSwap.swap) {
                log(`‚ùå A swap with this HashLock already exists on Jstz!`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            // ========== EXECUTE INITIATE ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Locking on Jstz...`;

            try {
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                
                log(`Initiating swap on Jstz...`, 'warning');
                log(`HashLock: ${hashlock.substring(0, 18)}...`, 'info');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`Timelock: ${timelockMins} minutes`, 'info');
                
                // Call Jstz smart function
                log(`Calling Jstz HTLC: jstz://htlc/initiate`, 'system');
                
                const response = await jstzRequest('POST', '/initiate', {
                    hashLock: hashlock,
                    amount: amount,
                    receiver: aliceSwap.swap.sender, // Alice's address
                    expiration: expiration
                });
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                state.currentSwapId = hashlock;
                state.hash = hashlock;
                
                log(``, 'system');
                log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'system');
                log(`üéâ SWAP MATCH√â AVEC SUCC√àS!`, 'success');
                log(`üí∞ Fonds verrouill√©s: ${amount} XTZ`, 'success');
                log(``, 'system');
                log(`üìã PROCHAINES √âTAPES:`, 'warning');
                log(`   1. Attendez qu'Alice claim vos fonds sur Jstz`, 'info');
                log(`   2. Quand elle claim, le SECRET sera r√©v√©l√©`, 'info');
                log(`   3. Utilisez ce secret pour claim sur Etherlink!`, 'info');
                log(``, 'system');
                log(`‚è∞ IMPORTANT: Claimez avant l'expiration du swap d'Alice!`, 'warning');
                log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'system');
                
                updateProgress(3);
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.hash, null);
                log("Allez sur l'onglet 'Redeem / Refund' quand le secret est r√©v√©l√©", 'system');
                
                btn.innerHTML = `<span>Waiting for Secret...</span>`;
                
                // Poll for secret revelation or enable manual claim
                setTimeout(() => {
                    log("Pr√™t √† claim sur Etherlink (quand Alice r√©v√®le le secret)", 'system');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Waiting for Secret...</span>`;
                    // No onClick needed here, user should go to Redeem tab
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // Alice claims on Jstz (reveals secret)
        async function claimOnJstz() {
            const btn = document.getElementById('main-action-btn');
            const hashLock = state.currentSwapId || state.hash;
            const secret = state.secret;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate inputs
            if (!hashLock || !isValidHashLock(hashLock)) {
                log('‚ùå Invalid or missing HashLock', 'error');
                return;
            }
            
            if (!secret) {
                log('‚ùå Secret is required to claim', 'error');
                return;
            }
            
            // 2. Verify secret matches the hashlock
            if (!verifySecretMatchesHash(secret, hashLock)) {
                log('‚ùå Secret does not match HashLock!', 'error');
                log('The provided secret hash does not equal the hashlock', 'error');
                return;
            }
            log('‚úì Secret matches HashLock', 'success');
            
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying swap on Jstz...`;
            
            // 3. Verify swap exists on Jstz and is ACTIVE
            log('Verifying swap exists on Jstz...', 'warning');
            const verification = await verifySwapOnJstz(hashLock);
            
            if (!verification.valid) {
                log(`‚ùå ${verification.error}`, 'error');
                log('Bob must lock funds on Jstz before you can claim!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`‚úì Swap found on Jstz: ${swap.amount} XTZ locked`, 'success');
            
            // 4. Check if swap is already claimed or refunded
            if (swap.state === 'CLAIMED' || swap.state === 2) {
                log('‚ùå Swap has already been claimed!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            
            if (swap.state === 'REFUNDED' || swap.state === 3) {
                log('‚ùå Swap has been refunded!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            
            // 5. Check timelock hasn't expired
            if (swap.isExpired) {
                log('‚ùå Swap has expired! Cannot claim after timelock.', 'error');
                log(`Expired at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            log(`‚úì Timelock valid until: ${swap.expirationDate}`, 'success');
            
            // ========== EXECUTE CLAIM ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Claiming on Jstz...`;

            try {
                log(`Claiming on Jstz with secret...`, 'warning');
                log(`Secret: ${secret.substring(0, 18)}...`, 'system');
                
                // Call Jstz smart function to claim
                log(`Calling Jstz HTLC: jstz://htlc/claim`, 'system');
                
                const response = await jstzRequest('POST', '/claim', {
                    hashLock: hashLock,
                    secret: secret
                });
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                log(`‚úÖ Claimed on Jstz!`, 'success');
                log(`Secret revealed: ${secret}`, 'system');
                log(`Alice has received XTZ!`, 'success');
                
                updateProgress(4);
                
                btn.innerHTML = `<i class="fa-solid fa-check-circle"></i> Swap Complete`;
                btn.classList.add('bg-ether-green', 'text-black');
                btn.disabled = true;

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
            }
        }

        // ============================================
        // SWAP VERIFICATION FUNCTIONS
        // ============================================
        
        // Swap states enum (matching Solidity contract)
        const SwapState = {
            EMPTY: 0,      // Swap doesn't exist
            ACTIVE: 1,     // Swap is active, funds locked
            CLAIMED: 2,    // Swap was claimed
            REFUNDED: 3    // Swap was refunded
        };
        
        // Verify swap exists and is in correct state on Etherlink
        // Uses read-only provider to avoid changing wallet connection state
        async function verifySwapOnEtherlink(swapId, expectedState = null) {
            try {
                // Use read-only provider to check swap without connecting wallet
                const readOnlyProvider = new ethers.providers.JsonRpcProvider(
                    NETWORK_CONFIG[128123].rpcUrl // Etherlink Testnet
                );
                const readOnlyContract = new ethers.Contract(
                    NETWORK_CONFIG[128123].htlcAddress,
                    CONFIG.etherlink.abi,
                    readOnlyProvider
                );
                
                console.log('[VERIFY] Checking swap on Etherlink (read-only):', swapId);
                const swap = await readOnlyContract.getSwap(swapId);
                
                console.log('[VERIFY] Swap data:', {
                    sender: swap.sender,
                    receiver: swap.receiver,
                    amount: swap.amount?.toString(),
                    hashLock: swap.hashLock,
                    expiration: swap.expiration?.toString(),
                    state: swap.state
                });
                
                // Check if swap exists (sender is not zero address)
                if (swap.sender === ethers.constants.AddressZero) {
                    return { 
                        valid: false, 
                        error: 'Swap does not exist on Etherlink',
                        swap: null
                    };
                }
                
                // Check state if expected state provided
                if (expectedState !== null && swap.state !== expectedState) {
                    const stateNames = ['EMPTY', 'ACTIVE', 'CLAIMED', 'REFUNDED'];
                    return {
                        valid: false,
                        error: `Swap is ${stateNames[swap.state]}, expected ${stateNames[expectedState]}`,
                        swap
                    };
                }
                
                // Check expiration for claim (must not be expired)
                const now = Math.floor(Date.now() / 1000);
                const isExpired = now >= swap.expiration.toNumber();
                
                return {
                    valid: true,
                    swap: {
                        sender: swap.sender,
                        receiver: swap.receiver,
                        amount: ethers.utils.formatEther(swap.amount),
                        hashLock: swap.hashLock,
                        expiration: swap.expiration.toNumber(),
                        expirationDate: new Date(swap.expiration.toNumber() * 1000).toLocaleString(),
                        state: swap.state,
                        isExpired
                    }
                };
                
            } catch (error) {
                console.error('[VERIFY] Error:', error);
                return { 
                    valid: false, 
                    error: `Failed to verify swap: ${error.message}` 
                };
            }
        }
        
        // Verify swap exists and is in correct state on Jstz
        async function verifySwapOnJstz(hashLock) {
            try {
                console.log('[VERIFY] Checking swap on Jstz:', hashLock);
                
                const response = await jstzRequest('GET', `/swap/${hashLock}`);
                
                if (!response || response.error) {
                    return {
                        valid: false,
                        error: response?.error || 'Swap does not exist on Jstz',
                        swap: null
                    };
                }
                
                console.log('[VERIFY] Jstz swap data:', response);
                
                const now = Math.floor(Date.now() / 1000);
                const isExpired = now >= response.expiration;
                
                return {
                    valid: true,
                    swap: {
                        sender: response.sender,
                        receiver: response.receiver,
                        amount: response.amount,
                        hashLock: response.hashLock,
                        expiration: response.expiration,
                        expirationDate: new Date(response.expiration * 1000).toLocaleString(),
                        state: response.state,
                        isExpired
                    }
                };
                
            } catch (error) {
                console.error('[VERIFY] Jstz error:', error);
                return {
                    valid: false,
                    error: `Failed to verify swap on Jstz: ${error.message}`,
                    swap: null
                };
            }
        }
        
        // Validate hashlock format
        function isValidHashLock(hashLock) {
            if (!hashLock) return false;
            // Must be 0x followed by 64 hex characters (32 bytes)
            return /^0x[a-fA-F0-9]{64}$/.test(hashLock);
        }
        
        // Validate secret matches hashlock using SHA-256 (cross-chain compatible)
        function verifySecretMatchesHash(secret, hashLock) {
            if (!secret || !hashLock) return false;
            try {
                const computedHash = ethers.utils.sha256(secret);
                const matches = computedHash.toLowerCase() === hashLock.toLowerCase();
                console.log('[VERIFY] Secret verification (SHA-256):', {
                    secret: secret.substring(0, 18) + '...',
                    computedHash,
                    expectedHash: hashLock,
                    matches
                });
                return matches;
            } catch (error) {
                console.error('[VERIFY] Secret verification error:', error);
                return false;
            }
        }

        // Pre-fill Redeem/Refund form
        function prefillRedeemForm(swapId, secret) {
            const swapIdInput = document.getElementById('swap-id-input');
            const secretInput = document.getElementById('secret-input-claim');
            
            if (swapIdInput && swapId) {
                swapIdInput.value = swapId;
            }
            if (secretInput && secret) {
                secretInput.value = secret;
            }
            
            // Optional: auto-switch to redeem tab? Maybe too intrusive.
            // setTab('redeem');
            log('Swap details saved for Redeem/Refund tab', 'info');
        }

        // ============================================
        // MY SWAPS FUNCTIONALITY
        // ============================================
        
        // Store loaded swaps
        state.mySwaps = [];
        let swapTimerInterval = null;
        
        // Status labels and colors
        // Note: Status 2 in contract means REFUNDED (after refundSwap was called)
        const SWAP_STATUS = {
            0: { label: 'OPEN', color: 'text-green-400', bg: 'bg-green-400/20', icon: 'fa-lock' },
            1: { label: 'CLAIMED', color: 'text-blue-400', bg: 'bg-blue-400/20', icon: 'fa-check-circle' },
            2: { label: 'REFUNDED', color: 'text-orange-400', bg: 'bg-orange-400/20', icon: 'fa-rotate-left' }
        };
        
        // Load all swaps for the connected address
        async function loadMySwaps() {
            if (!state.contract || !state.etherlinkAddress) {
                log('Connect wallet first to see your swaps', 'warning');
                document.getElementById('swaps-empty').classList.remove('hidden');
                document.getElementById('swaps-list').innerHTML = '';
                document.getElementById('swaps-loading').classList.add('hidden');
                return;
            }
            
            const loadingEl = document.getElementById('swaps-loading');
            const emptyEl = document.getElementById('swaps-empty');
            const listEl = document.getElementById('swaps-list');
            
            loadingEl.classList.remove('hidden');
            emptyEl.classList.add('hidden');
            listEl.innerHTML = '';
            
            try {
                console.log('[MY SWAPS] Loading swaps for:', state.etherlinkAddress);
                
                // Get current block number
                const currentBlock = await state.provider.getBlockNumber();
                // Search in chunks of 499 blocks (Etherlink limit is 500!)
                const CHUNK_SIZE = 499;
                const MAX_BLOCKS_BACK = 3000; // ~30 min on Etherlink
                const fromBlock = Math.max(0, currentBlock - MAX_BLOCKS_BACK);
                
                console.log('[MY SWAPS] Searching blocks', fromBlock, 'to', currentBlock);
                
                // Query in chunks to avoid RPC limits
                const filter = state.contract.filters.SwapInitiated();
                let allEvents = [];
                
                for (let start = fromBlock; start < currentBlock; start += CHUNK_SIZE) {
                    const end = Math.min(start + CHUNK_SIZE - 1, currentBlock);
                    try {
                        const events = await state.contract.queryFilter(filter, start, end);
                        allEvents = allEvents.concat(events);
                        console.log(`[MY SWAPS] Scanned blocks ${start}-${end}: ${events.length} events`);
                    } catch (e) {
                        console.warn(`[MY SWAPS] Chunk ${start}-${end} failed:`, e.message);
                    }
                }
                
                console.log('[MY SWAPS] Total events found:', allEvents.length);
                
                // Debug: show all events
                if (allEvents.length > 0) {
                    console.log('[MY SWAPS] All events:');
                    allEvents.forEach((e, i) => {
                        console.log(`  Event ${i}: sender=${e.args.sender}, recipient=${e.args.recipient}, swapId=${e.args.swapId}`);
                    });
                }
                
                // Filter events where user is sender OR recipient
                const userAddress = state.etherlinkAddress.toLowerCase();
                console.log('[MY SWAPS] Looking for user address:', userAddress);
                
                const userEvents = allEvents.filter(e => {
                    const senderMatch = e.args.sender.toLowerCase() === userAddress;
                    const recipientMatch = e.args.recipient.toLowerCase() === userAddress;
                    return senderMatch || recipientMatch;
                });
                
                console.log('[MY SWAPS] User events:', userEvents.length);
                
                // Get unique swap IDs
                const uniqueSwapIds = [...new Set(userEvents.map(e => e.args.swapId))];
                
                // Also fetch SwapRefunded and SwapClaimed events to get tx hashes
                const refundFilter = state.contract.filters.SwapRefunded();
                const claimFilter = state.contract.filters.SwapClaimed();
                let refundEvents = [];
                let claimEvents = [];
                
                for (let start = fromBlock; start < currentBlock; start += CHUNK_SIZE) {
                    const end = Math.min(start + CHUNK_SIZE - 1, currentBlock);
                    try {
                        const refunds = await state.contract.queryFilter(refundFilter, start, end);
                        const claims = await state.contract.queryFilter(claimFilter, start, end);
                        refundEvents = refundEvents.concat(refunds);
                        claimEvents = claimEvents.concat(claims);
                    } catch (e) {
                        // Silently continue
                    }
                }
                
                // Create lookup maps for tx hashes
                const refundTxMap = {};
                refundEvents.forEach(e => {
                    refundTxMap[e.args.swapId] = e.transactionHash;
                });
                
                const claimTxMap = {};
                claimEvents.forEach(e => {
                    claimTxMap[e.args.swapId] = e.transactionHash;
                });
                
                console.log('[MY SWAPS] Found swap IDs:', uniqueSwapIds);
                
                // Get current details for each swap
                state.mySwaps = [];
                for (const swapId of uniqueSwapIds) {
                    try {
                        const [recipient, sender, amount, expiration, hashLock, status] = await state.contract.getSwap(swapId);
                        
                        // Only include if not zero address (swap exists)
                        if (sender !== ethers.constants.AddressZero) {
                            state.mySwaps.push({
                                swapId,
                                recipient,
                                sender,
                                amount: ethers.utils.formatEther(amount),
                                expiration: expiration.toNumber(),
                                hashLock,
                                status,
                                isInitiator: sender.toLowerCase() === state.etherlinkAddress.toLowerCase(),
                                refundTxHash: refundTxMap[swapId] || null,
                                claimTxHash: claimTxMap[swapId] || null
                            });
                        }
                    } catch (e) {
                        console.warn('[MY SWAPS] Error fetching swap:', swapId, e);
                    }
                }
                
                // Sort by expiration (closest first)
                state.mySwaps.sort((a, b) => a.expiration - b.expiration);
                
                loadingEl.classList.add('hidden');
                
                if (state.mySwaps.length === 0) {
                    emptyEl.classList.remove('hidden');
                    log(`No swaps found for ${state.etherlinkAddress.substring(0, 10)}...`, 'info');
                } else {
                    emptyEl.classList.add('hidden');
                    renderSwapsList();
                    startSwapTimers();
                    log(`Found ${state.mySwaps.length} swap(s)`, 'success');
                }
                
            } catch (error) {
                console.error('[MY SWAPS] Error:', error);
                loadingEl.classList.add('hidden');
                emptyEl.classList.remove('hidden');
                log(`Error loading swaps: ${error.message}`, 'error');
            }
        }
        
        // Render all swaps in the list
        function renderSwapsList() {
            const listEl = document.getElementById('swaps-list');
            listEl.innerHTML = state.mySwaps.map(swap => renderSwapCard(swap)).join('');
        }
        
        // Render a single swap card
        function renderSwapCard(swap) {
            const statusInfo = SWAP_STATUS[swap.status] || SWAP_STATUS[0];
            const now = Math.floor(Date.now() / 1000);
            const isExpired = now >= swap.expiration;
            const timeRemaining = swap.expiration - now;
            const role = swap.isInitiator ? 'Initiator (Alice)' : 'Participant (Bob)';
            const roleColor = swap.isInitiator ? 'text-ether-green' : 'text-jstz-accent';
            
            // Get explorer URL
            const networkConfig = NETWORK_CONFIG[state.currentChainId];
            const explorerUrl = networkConfig?.explorer || '';
            
            // Determine tx hash to show (refund or claim)
            const txHash = swap.refundTxHash || swap.claimTxHash;
            const txType = swap.refundTxHash ? 'Refund' : (swap.claimTxHash ? 'Claim' : null);
            
            return `
                <div class="bg-gradient-to-r from-white/5 to-transparent rounded-xl p-4 border border-white/10 hover:border-white/20 transition-all">
                    <div class="flex items-start justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <span class="px-2 py-1 rounded-md text-xs font-bold ${statusInfo.color} ${statusInfo.bg}">
                                <i class="fa-solid ${statusInfo.icon} mr-1"></i>
                                ${statusInfo.label}
                            </span>
                            <span class="text-xs ${roleColor} font-medium">${role}</span>
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-bold text-white">${parseFloat(swap.amount).toFixed(4)} XTZ</div>
                        </div>
                    </div>
                    
                    <div class="space-y-2 text-xs">
                        <div class="flex items-center justify-between">
                            <span class="text-gray-500">Swap ID:</span>
                            <div class="flex items-center gap-2">
                                <code class="text-gray-300 font-mono">${swap.swapId.substring(0, 12)}...${swap.swapId.slice(-8)}</code>
                                <button onclick="copySwapId('${swap.swapId}')" class="text-gray-500 hover:text-white transition">
                                    <i class="fa-regular fa-copy"></i>
                                </button>
                            </div>
                        </div>
                        
                        <div class="flex items-center justify-between">
                            <span class="text-gray-500">Counterparty:</span>
                            <code class="text-gray-300 font-mono">${swap.isInitiator ? swap.recipient.substring(0, 8) : swap.sender.substring(0, 8)}...</code>
                        </div>
                        
                        <div class="flex items-center justify-between">
                            <span class="text-gray-500">Timelock:</span>
                            <span id="timer-${swap.swapId.substring(0, 10)}" class="${isExpired ? 'text-red-400' : 'text-yellow-400'} font-mono">
                                ${formatTimeRemaining(timeRemaining)}
                            </span>
                        </div>
                        
                        ${txHash && explorerUrl ? `
                        <div class="flex items-center justify-between mt-2 pt-2 border-t border-white/5">
                            <span class="text-gray-500">${txType} TX:</span>
                            <a href="${explorerUrl}/tx/${txHash}" target="_blank" class="flex items-center gap-1 text-ether-green hover:underline">
                                <code class="font-mono">${txHash.substring(0, 8)}...${txHash.slice(-6)}</code>
                                <i class="fa-solid fa-external-link text-[10px]"></i>
                            </a>
                        </div>
                        ` : ''}
                    </div>
                    
                    ${swap.status === 0 ? `
                    <div class="mt-3 pt-3 border-t border-white/10 flex gap-2">
                        ${isExpired && swap.isInitiator ? `
                        <button onclick="quickRefund('${swap.swapId}')" class="flex-1 py-2 rounded-lg text-xs font-semibold bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white transition">
                            <i class="fa-solid fa-rotate-left mr-1"></i>
                            Refund Now
                        </button>
                        ` : `
                        <button onclick="useSwapInRedeem('${swap.swapId}')" class="flex-1 py-2 rounded-lg text-xs font-semibold bg-white/5 hover:bg-white/10 text-gray-300 hover:text-white transition">
                            <i class="fa-solid fa-arrow-right-to-bracket mr-1"></i>
                            ${swap.isInitiator ? 'View Details' : 'Claim'}
                        </button>
                        `}
                    </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Format time remaining
        function formatTimeRemaining(seconds) {
            if (seconds <= 0) return 'EXPIRED';
            
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }
        
        // Start timers to update countdown
        function startSwapTimers() {
            // Clear existing interval
            if (swapTimerInterval) {
                clearInterval(swapTimerInterval);
            }
            
            // Update every second
            swapTimerInterval = setInterval(() => {
                const now = Math.floor(Date.now() / 1000);
                state.mySwaps.forEach(swap => {
                    const timerEl = document.getElementById(`timer-${swap.swapId.substring(0, 10)}`);
                    if (timerEl) {
                        const remaining = swap.expiration - now;
                        timerEl.textContent = formatTimeRemaining(remaining);
                        timerEl.className = remaining <= 0 ? 'text-red-400 font-mono' : 
                                           remaining < 300 ? 'text-orange-400 font-mono animate-pulse' : 
                                           'text-yellow-400 font-mono';
                    }
                });
            }, 1000);
        }
        
        // Copy swap ID to clipboard
        function copySwapId(swapId) {
            navigator.clipboard.writeText(swapId);
            log(`Copied Swap ID: ${swapId.substring(0, 18)}...`, 'success');
        }
        
        // Use swap in Redeem tab
        function useSwapInRedeem(swapId) {
            const swap = state.mySwaps.find(s => s.swapId === swapId);
            if (swap) {
                document.getElementById('swap-id-input').value = swapId;
                
                // If user is initiator and has the secret stored, pre-fill it
                if (swap.isInitiator && state.secret && state.hash === swapId) {
                    document.getElementById('secret-input-claim').value = state.secret;
                }
                
                setTab('redeem');
                log(`Loaded swap ${swapId.substring(0, 12)}... into Redeem tab`, 'info');
            }
        }
        
        // Quick refund directly from My Swaps
        async function quickRefund(swapId) {
            if (!state.contract || !state.signer) {
                log('Connect wallet first!', 'error');
                return;
            }
            
            const swap = state.mySwaps.find(s => s.swapId === swapId);
            if (!swap) {
                log('Swap not found', 'error');
                return;
            }
            
            // Use custom modal instead of confirm()
            const modalText = document.getElementById('confirm-modal-text');
            const modalBtn = document.getElementById('confirm-modal-btn');
            
            modalText.innerText = `Refund ${swap.amount} XTZ from swap ${swapId.substring(0, 8)}...?`;
            
            // Set up confirm action
            modalBtn.onclick = async () => {
                closeConfirmModal();
                await performRefund(swapId, swap.amount);
            };
            
            openConfirmModal();
        }
        
        async function performRefund(swapId, amount) {
            try {
                log(`Refunding swap ${swapId.substring(0, 12)}...`, 'info');
                
                const tx = await state.contract.refundSwap(swapId);
                logTx(tx.hash, 'üì§ Transaction sent');
                
                const receipt = await tx.wait();
                log(`‚úÖ Refund successful!`, 'success');
                logTx(tx.hash, '‚úÖ Refund confirmed');
                log(`${amount} XTZ returned to your wallet`, 'success');
                
                // Show success modal with link
                const networkConfig = NETWORK_CONFIG[state.currentChainId];
                if (networkConfig?.explorer) {
                    const txUrl = `${networkConfig.explorer}/tx/${tx.hash}`;
                    showSuccessNotification(amount, tx.hash, txUrl);
                }
                
                // Reload swaps to update the list
                setTimeout(() => loadMySwaps(), 2000);
                
            } catch (error) {
                console.error('Refund error:', error);
                if (error.message.includes('NotYetExpired')) {
                    log('‚ùå Swap has not expired yet', 'error');
                } else if (error.message.includes('OnlySender')) {
                    log('‚ùå Only the original sender can refund', 'error');
                } else if (error.message.includes('SwapNotActive')) {
                    log('‚ùå Swap is no longer active (already claimed or refunded)', 'error');
                } else {
                    log(`‚ùå Refund failed: ${error.message}`, 'error');
                }
            }
        }
        
        // Success notification with tx link
        function showSuccessNotification(amount, txHash, txUrl) {
            const modal = document.getElementById('confirm-modal');
            const content = document.getElementById('confirm-modal-content');
            const text = document.getElementById('confirm-modal-text');
            const btn = document.getElementById('confirm-modal-btn');
            
            // Update modal for success state
            content.innerHTML = `
                <div class="text-center mb-6">
                    <div class="w-16 h-16 bg-green-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                        <i class="fa-solid fa-check text-3xl text-green-400"></i>
                    </div>
                    <h3 class="text-xl font-bold text-white mb-2">Refund Successful!</h3>
                    <p class="text-gray-400 text-sm mb-4">${amount} XTZ has been returned to your wallet</p>
                    <div class="bg-black/30 rounded-lg p-3 text-xs">
                        <p class="text-gray-500 mb-1">Transaction Hash:</p>
                        <code class="text-ether-green font-mono">${txHash.substring(0, 20)}...${txHash.slice(-8)}</code>
                    </div>
                </div>
                
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="closeConfirmModal(); resetConfirmModal();" class="py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 text-gray-300 font-semibold transition-all">
                        Close
                    </button>
                    <a href="${txUrl}" target="_blank" class="py-3 px-4 rounded-xl bg-gradient-to-r from-ether-green to-emerald-500 text-black font-bold text-center transition-all hover:opacity-90">
                        <i class="fa-solid fa-external-link mr-1"></i>
                        View TX
                    </a>
                </div>
            `;
            
            openConfirmModal();
        }
        
        // Reset modal to default state
        function resetConfirmModal() {
            const content = document.getElementById('confirm-modal-content');
            content.innerHTML = `
                <div class="text-center mb-6">
                    <div class="w-16 h-16 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-4">
                        <i class="fa-solid fa-rotate-left text-2xl text-red-500"></i>
                    </div>
                    <h3 class="text-xl font-bold text-white mb-2">Confirm Refund</h3>
                    <p class="text-gray-400 text-sm" id="confirm-modal-text">Are you sure you want to refund this swap?</p>
                </div>
                
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="closeConfirmModal()" class="py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 text-gray-300 font-semibold transition-all">
                        Cancel
                    </button>
                    <button id="confirm-modal-btn" class="py-3 px-4 rounded-xl bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-bold shadow-lg shadow-red-500/20 transition-all">
                        Confirm Refund
                    </button>
                </div>
            `;
        }
        
        // Modal Helpers
        function openConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            const content = document.getElementById('confirm-modal-content');
            modal.classList.remove('hidden');
            // Small delay for transition
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                content.classList.remove('scale-95');
                content.classList.add('scale-100');
            }, 10);
        }
        
        function closeConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            const content = document.getElementById('confirm-modal-content');
            modal.classList.add('opacity-0');
            content.classList.remove('scale-100');
            content.classList.add('scale-95');
            
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        // Unified claim function
        async function claimSwap() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            const secret = document.getElementById('secret-input-claim')?.value || state.secret;
            
            if (!swapId) {
                log('Please enter a Swap ID / HashLock', 'error');
                return;
            }
            
            if (!secret) {
                log('Please enter the secret to claim', 'error');
                return;
            }
            
            // Store for use in claim functions
            state.currentSwapId = swapId;
            state.secret = secret;
            
            // Determine which chain to claim on based on current mode and chain selection
            if (state.selectedChain === 'etherlink') {
                // If we're set to Etherlink, we're Bob claiming on Etherlink
                log('Claiming on Etherlink...', 'warning');
                await claimOnEtherlink();
            } else {
                // If we're set to Jstz, we're Alice claiming on Jstz
                log('Claiming on Jstz...', 'warning');
                await claimOnJstz();
            }
        }
        
        // Unified refund function
        async function refundSwap() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            if (!swapId) {
                log('Please enter a Swap ID / HashLock', 'error');
                return;
            }
            
            state.currentSwapId = swapId;
            
            if (state.selectedChain === 'etherlink') {
                await refundOnEtherlink();
            } else {
                await refundOnJstz();
            }
        }
        
        // Refund on Etherlink (after timelock expires)
        async function refundOnEtherlink() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate swap ID
            if (!swapId || !isValidHashLock(swapId)) {
                log('‚ùå Invalid or missing Swap ID', 'error');
                return;
            }
            state.currentSwapId = swapId;
            
            if (!state.contract) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }
            
            if (!state.contract) {
                log('‚ùå HTLC contract not available', 'error');
                return;
            }
            
            const btn = document.getElementById('refund-btn');
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
            
            // 2. Verify swap exists on Etherlink and is ACTIVE
            log('Verifying swap on Etherlink...', 'warning');
            const verification = await verifySwapOnEtherlink(swapId, SwapState.ACTIVE);
            
            if (!verification.valid) {
                log(`‚ùå ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`‚úì Swap found: ${swap.amount} XTZ`, 'success');
            
            // 3. Verify caller is the original sender (can only refund your own swap)
            if (swap.sender.toLowerCase() !== state.etherlinkAddress.toLowerCase()) {
                log('‚ùå Only the original sender can refund this swap', 'error');
                log(`Sender: ${swap.sender}`, 'info');
                log(`Your address: ${state.etherlinkAddress}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('‚úì You are the original sender', 'success');
            
            // 4. Check timelock HAS expired (required for refund)
            if (!swap.isExpired) {
                const now = Math.floor(Date.now() / 1000);
                const remaining = swap.expiration - now;
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                log(`‚ùå Cannot refund yet - timelock has not expired`, 'error');
                log(`Time remaining: ${mins}m ${secs}s`, 'warning');
                log(`Expires at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('‚úì Timelock has expired, refund allowed', 'success');
            
            // ========== EXECUTE REFUND ==========
            try {
                log('Executing refund on Etherlink...', 'warning');
                log(`Swap ID: ${swapId.substring(0, 18)}...`, 'info');
                
                const tx = await state.contract.refundSwap(swapId);
                logTx(tx.hash, 'üì§ Transaction sent');
                
                const receipt = await tx.wait();
                
                if (receipt.status !== 1) {
                    throw new Error('Transaction failed on-chain');
                }
                
                log('‚úÖ Refund successful on Etherlink!', 'success');
                logTx(tx.hash, '‚úÖ Refund confirmed');
                log(`${swap.amount} XTZ returned to your wallet`, 'success');
                
                // hideClaimRefundSection(); // No longer needed in redeem tab
                updateProgress(1);
                
            } catch (error) {
                let errorMsg = error.message;
                if (error.message.includes('NotYetExpired') || error.message.includes('not yet expired')) {
                    errorMsg = 'Timelock has not expired yet';
                } else if (error.message.includes('OnlySender') || error.message.includes('not sender')) {
                    errorMsg = 'Only the original sender can refund';
                } else if (error.message.includes('SwapNotActive')) {
                    errorMsg = 'Swap is not active (already claimed or refunded)';
                }
                log(`‚ùå Refund error: ${errorMsg}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
            }
        }
        
        // Refund on Jstz
        async function refundOnJstz() {
            const hashLock = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate hashlock
            if (!hashLock || !isValidHashLock(hashLock)) {
                log('‚ùå Invalid or missing HashLock', 'error');
                return;
            }
            state.currentSwapId = hashLock;
            
            const btn = document.getElementById('refund-btn');
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
            
            // 2. Verify swap exists on Jstz
            log('Verifying swap on Jstz...', 'warning');
            const verification = await verifySwapOnJstz(hashLock);
            
            if (!verification.valid) {
                log(`‚ùå ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`‚úì Swap found: ${swap.amount} XTZ`, 'success');
            
            // 3. Check if already claimed or refunded
            if (swap.state === 'CLAIMED' || swap.state === 2) {
                log('‚ùå Swap has already been claimed!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            if (swap.state === 'REFUNDED' || swap.state === 3) {
                log('‚ùå Swap has already been refunded!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            // 4. Check timelock HAS expired (required for refund)
            if (!swap.isExpired) {
                const now = Math.floor(Date.now() / 1000);
                const remaining = swap.expiration - now;
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                log(`‚ùå Cannot refund yet - timelock has not expired`, 'error');
                log(`Time remaining: ${mins}m ${secs}s`, 'warning');
                log(`Expires at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('‚úì Timelock has expired, refund allowed', 'success');
            
            // ========== EXECUTE REFUND ==========
            log('Executing refund on Jstz...', 'warning');
            
            try {
                const response = await jstzRequest('POST', '/refund', {
                    hashLock: hashLock
                });
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                log('‚úÖ Refund successful on Jstz!', 'success');
                log(`${swap.amount} XTZ returned to your wallet`, 'success');
                // hideClaimRefundSection(); // No longer needed
                updateProgress(1);
                
            } catch (error) {
                log(`‚ùå Refund error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
            }
        }

        // Bob claims on Etherlink (uses revealed secret)
        async function claimOnEtherlink() {
            const btn = document.getElementById('main-action-btn');
            const swapId = state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate swap ID
            if (!swapId || !isValidHashLock(swapId)) {
                log('‚ùå Invalid or missing Swap ID', 'error');
                return;
            }
            
            // 2. Get secret (prompt if not available)
            let secret = state.secret;
            if (!secret) {
                secret = document.getElementById('secret-input-claim')?.value;
            }
            if (!secret) {
                secret = prompt("Enter the revealed secret (0x...):");
                if (!secret) {
                    log("‚ùå Secret is required to claim", 'error');
                    return;
                }
            }
            state.secret = secret;
            
            // 3. Verify secret format
            if (!isValidHashLock(secret)) {
                log('‚ùå Invalid secret format (must be 0x + 64 hex chars)', 'error');
                return;
            }
            
            // 4. Verify secret matches the hashlock
            if (!verifySecretMatchesHash(secret, swapId)) {
                log('‚ùå Secret does not match Swap ID (HashLock)!', 'error');
                log('Make sure you have the correct secret from Alice', 'error');
                return;
            }
            log('‚úì Secret matches HashLock', 'success');

            if (!state.contract) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }
            
            if (!state.contract) {
                log('‚ùå HTLC contract not available', 'error');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying swap on Etherlink...`;
            
            // 5. Verify swap exists on Etherlink and is ACTIVE
            log('Verifying swap exists on Etherlink...', 'warning');
            const verification = await verifySwapOnEtherlink(swapId, SwapState.ACTIVE);
            
            if (!verification.valid) {
                log(`‚ùå ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`‚úì Swap found: ${swap.amount} XTZ locked by ${swap.sender.substring(0,10)}...`, 'success');
            
            // 6. Check timelock hasn't expired
            if (swap.isExpired) {
                log('‚ùå Swap has expired! Cannot claim after timelock.', 'error');
                log(`Expired at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
                return;
            }
            log(`‚úì Timelock valid until: ${swap.expirationDate}`, 'success');
            
            // ========== EXECUTE CLAIM ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Claiming on Etherlink...`;

            try {
                log(`Claiming on Etherlink with secret...`, 'warning');
                
                // Convert secret to bytes
                const secretBytes = ethers.utils.arrayify(secret);
                
                const tx = await state.contract.claimSwap(swapId, secretBytes);

                logTx(tx.hash, 'üì§ Transaction sent');
                
                const receipt = await tx.wait();
                
                // Verify transaction was successful
                if (receipt.status !== 1) {
                    throw new Error('Transaction failed on-chain');
                }
                
                log(`‚úÖ Claimed on Etherlink!`, 'success');
                logTx(tx.hash, '‚úÖ Claim confirmed');
                log(`Bob has received ${swap.amount} XTZ!`, 'success');
                
                updateProgress(4);
                
                btn.innerHTML = `<i class="fa-solid fa-check-circle"></i> Swap Complete`;
                btn.classList.add('bg-green-500');
                btn.disabled = true;

            } catch (error) {
                // Parse contract revert reasons
                let errorMsg = error.message;
                if (error.message.includes('SwapNotActive')) {
                    errorMsg = 'Swap is not active (already claimed or refunded)';
                } else if (error.message.includes('InvalidHashLock')) {
                    errorMsg = 'Invalid secret - does not match hashlock';
                } else if (error.message.includes('SwapExpired')) {
                    errorMsg = 'Swap has expired';
                }
                log(`‚ùå Error: ${errorMsg}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
            }
        }

        // Main action dispatcher
        async function executeAction() {
            if (state.mode === 'create') {
                // Alice initiates
                if (state.chain === 'etherlink') {
                    await initiateOnEtherlink();
                } else {
                    await initiateOnJstz();
                }
            } else {
                // Bob joins
                if (state.chain === 'etherlink') {
                    await initiateOnJstz(); // Bob locks on opposite chain
                } else {
                    await initiateOnEtherlink();
                }
            }
        }

        // Legacy functions for compatibility
        async function revealSecret() {
            await claimOnJstz();
        }

        async function claimWithSecret() {
            await claimOnEtherlink();
        }

        function copyToClipboard(id) {
            const el = document.getElementById(id);
            el.select();
            navigator.clipboard.writeText(el.value);
            log(`Copied ${id} to clipboard.`, 'info');
        }

        // Init
        generateNewSecret();
        updateProgress(1);
        renderTokenDropdown(); // Initialize token dropdown
        log("Atomic Swap ready. Connect wallets to begin.", 'system');
        log(`Etherlink Contract: ${CONFIG.etherlink.contractAddress}`, 'info');
        log(`Jstz Function: ${CONFIG.jstz.functionAddress}`, 'info');
        log(`Tokens available: ${Object.keys(TOKENS).join(', ')}`, 'info');
        
        // Close token dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('token-dropdown');
            const assetSelector = e.target.closest('[onclick="toggleTokenSelector()"]');
            if (!assetSelector && !e.target.closest('#token-dropdown')) {
                toggleTokenSelector(false);
            }
        });

        // Wallet Events - Real connections
        document.getElementById('wallet-etherlink').addEventListener('click', async (e) => {
            const btn = e.currentTarget;
            const textEl = document.getElementById('wallet-etherlink-text');
            const balanceEl = document.getElementById('wallet-balance');
            
            // Check if already connected - toggle disconnect
            if (state.etherlinkAddress) {
                state.etherlinkAddress = null;
                state.provider = null;
                state.signer = null;
                state.contract = null;
                textEl.innerText = 'Connect Etherlink';
                balanceEl.classList.add('hidden');
                btn.classList.remove('border-ether-green', 'text-ether-green', 'bg-ether-green/10');
                updateWalletConnectionUI(null);
                updateNetworkBadge(null, 'Not Connected');
                log('Etherlink wallet disconnected', 'info');
                return;
            }
            
            // Check if other wallet is connected
            if (state.jstzAddress) {
                log('‚ö†Ô∏è Disconnect Jstz wallet first', 'warning');
                return;
            }
            
            textEl.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin mr-1"></i> Connecting...`;
            
            const connected = await connectEtherlink();
            
            if (connected) {
                const shortAddr = `${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`;
                textEl.innerText = shortAddr;
                btn.classList.add('border-ether-green', 'text-ether-green', 'bg-ether-green/10');
                
                // Fetch and display balances
                await fetchAllBalances();
                
                // Show balance next to address
                if (state.tokenBalances['XTZ']) {
                    const xtzBalance = parseFloat(state.tokenBalances['XTZ']).toFixed(2);
                    balanceEl.innerText = `${xtzBalance} XTZ`;
                    balanceEl.classList.remove('hidden');
                }
                
                // Update token dropdown with balances
                renderTokenDropdown();
            } else {
                textEl.innerText = 'Connect Etherlink';
            }
        });

        document.getElementById('wallet-jstz').addEventListener('click', async (e) => {
            const btn = e.currentTarget;
            const textEl = document.getElementById('wallet-jstz-text');
            
            // Check if already connected
            if (state.jstzAddress) {
                // Disconnect
                state.jstzAddress = null;
                textEl.innerText = 'Connect Jstz';
                btn.classList.remove('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                updateWalletConnectionUI(null);
                log('Jstz wallet disconnected', 'info');
                return;
            }
            
            // Check if other wallet is connected
            if (state.etherlinkAddress) {
                log('‚ö†Ô∏è Disconnect Etherlink wallet first', 'warning');
                return;
            }
            
            // Jstz connection - try extension first, fallback to simulated
            try {
                if (isJstzExtensionInstalled()) {
                    log('üîê Connecting to Jstz wallet extension...', 'warning');
                    
                    const addressData = await getJstzAddress();
                    console.log('[JSTZ] Address response:', addressData);
                    
                    // Handle different response formats
                    if (typeof addressData === 'string') {
                        state.jstzAddress = addressData;
                    } else if (addressData && typeof addressData === 'object') {
                        state.jstzAddress = addressData.address || addressData.accountAddress || addressData.data?.address || JSON.stringify(addressData);
                    } else {
                        throw new Error('Invalid address response from wallet');
                    }
                    
                    // Safely create short address
                    const addr = String(state.jstzAddress);
                    const shortAddr = addr.length > 10 ? `${addr.substring(0, 6)}...${addr.slice(-3)}` : addr;
                    textEl.innerText = shortAddr;
                    btn.classList.add('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                    
                    updateWalletConnectionUI('jstz');
                    
                    log(`‚úÖ Jstz wallet connected: ${state.jstzAddress}`, 'success');
                    log('Transactions will be signed by your wallet extension', 'system');
                } else {
                    // No extension - use simulated mode
                    state.jstzAddress = 'tz1gyq6Er4ntjHFaXsVbUKnSEqvEiez4HFTP';
                    textEl.innerText = 'tz1...FTP (demo)';
                    btn.classList.add('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                    
                    updateWalletConnectionUI('jstz');
                    
                    log(`‚ö†Ô∏è Jstz wallet extension not found`, 'warning');
                    log(`Using demo mode - CLI commands will be shown`, 'system');
                    log(`Install wallet: <a href="https://github.com/jstz-dev/dev-wallet/releases" target="_blank" class="text-ether-green hover:underline">github.com/jstz-dev/dev-wallet</a>`, 'info');
                }
            } catch (error) {
                console.error('[JSTZ] Connection error:', error);
                log(`‚ùå Jstz connection error: ${error.message}`, 'error');
                
                // Fallback to demo mode
                state.jstzAddress = 'tz1gyq6Er4ntjHFaXsVbUKnSEqvEiez4HFTP';
                textEl.innerText = 'tz1...FTP (demo)';
                btn.classList.add('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                updateWalletConnectionUI('jstz');
                log('Falling back to demo mode', 'system');
            }
        });

        // Listen for MetaMask network/account changes
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('chainChanged', async (chainId) => {
                const newChainId = parseInt(chainId, 16);
                console.log('[DEBUG] Network changed to chainId:', newChainId);
                log(`Network changed! Reconnecting...`, 'warning');
                
                // Reconnect with new network
                await connectEtherlink();
                await fetchAllBalances();
                renderTokenDropdown();
            });
            
            window.ethereum.on('accountsChanged', async (accounts) => {
                console.log('[DEBUG] Account changed to:', accounts[0]);
                if (accounts.length > 0) {
                    log(`Account changed! Reconnecting...`, 'warning');
                    await connectEtherlink();
                    await fetchAllBalances();
                    
                    // Update wallet button
                    const textEl = document.getElementById('wallet-etherlink-text');
                    if (textEl) {
                        const shortAddr = `${accounts[0].substring(0, 6)}...${accounts[0].slice(-4)}`;
                        textEl.innerText = shortAddr;
                    }
                } else {
                    log(`Wallet disconnected`, 'warning');
                    updateNetworkBadge(0, 'Not Connected');
                }
            });
            
            console.log('[DEBUG] MetaMask event listeners attached');
        }

    </script>
    <!-- Notification Modal -->
    <div id="confirm-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center opacity-0 transition-opacity duration-300">
        <div class="bg-[#111111] border border-white/10 rounded-2xl p-6 max-w-sm w-full mx-4 shadow-2xl transform scale-95 transition-transform duration-300" id="confirm-modal-content">
            <div class="text-center mb-6">
                <div class="w-16 h-16 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-4">
                    <i class="fa-solid fa-rotate-left text-2xl text-red-500"></i>
                </div>
                <h3 class="text-xl font-bold text-white mb-2">Confirm Refund</h3>
                <p class="text-gray-400 text-sm" id="confirm-modal-text">Are you sure you want to refund this swap?</p>
            </div>
            
            <div class="grid grid-cols-2 gap-3">
                <button onclick="closeConfirmModal()" class="py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 text-gray-300 font-semibold transition-all">
                    Cancel
                </button>
                <button id="confirm-modal-btn" class="py-3 px-4 rounded-xl bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-bold shadow-lg shadow-red-500/20 transition-all">
                    Confirm Refund
                </button>
            </div>
        </div>
    </div>
</body>
</html>
