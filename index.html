<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etherlink x Jstz | Atomic Swap</title>
    
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        ether: {
                            green: '#80F89B', // Etherlink Brand Green (approx)
                            dark: '#020202',
                            card: '#111111',
                            border: '#222222',
                            text: '#e2e8f0'
                        },
                        jstz: {
                            accent: '#FFD700' // Gold/Yellow for Jstz
                        }
                    },
                    fontFamily: {
                        sans: ['"Plus Jakarta Sans"', 'Inter', 'sans-serif'],
                        mono: ['"JetBrains Mono"', 'monospace'],
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 6s ease-in-out infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        }
                    }
                }
            }
        }
    </script>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    
    <!-- Load Jstz Client SDK -->
    <script type="module">
        // Try to load Jstz SDK and expose it globally
        try {
            const JstzModule = await import('https://esm.sh/@jstz-dev/jstz-client@0.1.1-alpha.5');
            window.JstzClient = JstzModule.default || JstzModule.Jstz || JstzModule;
            console.log('[JSTZ SDK] Loaded successfully:', window.JstzClient);
        } catch (e) {
            console.warn('[JSTZ SDK] Failed to load from esm.sh:', e);
            window.JstzClient = null;
        }
    </script>
    
    <!-- Jstz Wallet Extension Integration -->
    <script>
        // Jstz Signer Extension Types and Functions
        const JstzSignerEventTypes = {
            SIGN: 'JSTZ_SIGN_REQUEST_TO_EXTENSION',
            GET_ADDRESS: 'JSTZ_GET_ADDRESS_REQUEST_TO_EXTENSION',
            SIGN_RESPONSE: 'JSTZ_SIGN_RESPONSE_FROM_EXTENSION',
            GET_ADDRESS_RESPONSE: 'JSTZ_GET_ADDRESS_RESPONSE_FROM_EXTENSION'
        };

        // Check if Jstz extension is installed
        function isJstzExtensionInstalled() {
            try {
                return typeof window.jstzCallSignerExtension === 'function';
            } catch (e) {
                return false;
            }
        }
        
        // Check if Jstz SDK is loaded
        function isJstzSdkLoaded() {
            return !!window.JstzClient;
        }

        // Request address from Jstz wallet extension
        async function getJstzAddress() {
            if (!isJstzExtensionInstalled()) {
                throw new Error('Jstz wallet extension not installed. Please install from: https://github.com/jstz-dev/dev-wallet/releases');
            }
            
            try {
                const response = await window.jstzCallSignerExtension({
                    type: JstzSignerEventTypes.GET_ADDRESS
                });
                return response.data;
            } catch (error) {
                throw new Error(`Failed to get Jstz address: ${error.message}`);
            }
        }

        // Request signature from Jstz wallet extension
        async function requestJstzSignature(operation) {
            if (!isJstzExtensionInstalled()) {
                throw new Error('Jstz wallet extension not installed');
            }
            
            try {
                const response = await window.jstzCallSignerExtension({
                    type: JstzSignerEventTypes.SIGN,
                    content: operation
                });
                return response.data;
            } catch (error) {
                throw new Error(`Failed to sign Jstz operation: ${error.message}`);
            }
        }

        // Inject and poll Jstz operation
        async function injectJstzOperation(operation, signature, rpcUrl = 'https://privatenet.jstz.info') {
            const response = await fetch(`${rpcUrl}/operations`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    inner: operation,
                    signature: signature
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Jstz injection failed: ${errorText}`);
            }
            
            return await response.json();
        }

        // Poll for operation result
        async function pollJstzOperation(operationHash, rpcUrl = 'https://privatenet.jstz.info', maxAttempts = 30) {
            for (let i = 0; i < maxAttempts; i++) {
                try {
                    const response = await fetch(`${rpcUrl}/operations/${operationHash}`);
                    if (response.ok) {
                        const result = await response.json();
                        if (result.status === 'applied' || result.status === 'failed') {
                            return result;
                        }
                    }
                } catch (e) {
                    // Continue polling
                }
                await new Promise(r => setTimeout(r, 1000));
            }
            throw new Error('Operation polling timeout');
        }
    </script>
    <!-- Automated Test Suite (run runAllTests() in console) -->
    <script src="test-scenarios.js"></script>

    <style>
        body {
            background-color: #020202;
            /* Etherlink-style diagonal glow */
            background-image: 
                radial-gradient(circle at 20% 0%, rgba(128, 248, 155, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 100%, rgba(128, 248, 155, 0.05) 0%, transparent 50%);
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #80F89B; }

        .glass-card {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
        }

        .neon-text {
            text-shadow: 0 0 20px rgba(128, 248, 155, 0.4);
        }
        
        .input-field {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        .input-field:focus {
            border-color: #80F89B;
            box-shadow: 0 0 15px rgba(128, 248, 155, 0.1);
        }

        .btn-primary {
            background: #80F89B;
            color: #000;
            font-weight: 600;
            letter-spacing: -0.02em;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .btn-primary::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: 0.5s;
        }
        .btn-primary:hover::after {
            left: 100%;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(128, 248, 155, 0.3);
            background: #6ee786;
        }

        .step-line-bg {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 0;
            transform: translateY(-50%);
        }
        .step-progress {
            position: absolute;
            top: 50%;
            left: 0;
            height: 1px;
            background: #80F89B;
            box-shadow: 0 0 10px rgba(128, 248, 155, 0.5);
            z-index: 0;
            transform: translateY(-50%);
            width: 0%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .step-dot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            z-index: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: #111;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #666;
        }
        
        .step-dot.active {
            background: #80F89B;
            color: #000;
            border-color: #80F89B;
            box-shadow: 0 0 20px rgba(128, 248, 155, 0.3);
            transform: scale(1.1);
        }

        .step-dot.completed {
            background: #000;
            color: #80F89B;
            border-color: #80F89B;
        }

        .step-label {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #666;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .step-dot.active + .step-label {
            color: #80F89B;
            text-shadow: 0 0 10px rgba(128, 248, 155, 0.3);
        }
        .step-dot.completed + .step-label {
            color: #e2e8f0;
        }

        /* Secret Blur */
        .secret-blur {
            filter: blur(8px);
            cursor: pointer;
            transition: filter 0.3s;
            user-select: none;
        }
        .secret-blur:hover, .secret-blur.revealed {
            filter: blur(0);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Navigation -->
    <nav class="w-full border-b border-white/5 bg-ether-card/50 backdrop-blur-md fixed top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
        <div class="flex items-center gap-3">
                    <!-- Logo Placeholder -->
                    <div class="w-8 h-8 rounded bg-ether-green flex items-center justify-center text-black font-bold text-lg shadow-[0_0_15px_rgba(128,248,155,0.4)]">
                        <i class="fa-solid fa-arrow-right-arrow-left"></i>
                    </div>
                    <span class="text-xl font-bold tracking-tight text-white">Etherlink <span class="text-gray-500 mx-1">x</span> <span class="text-jstz-accent">Jstz</span></span>
                </div>
                
                <div class="hidden md:flex items-center space-x-4">
                    <div id="network-badge" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-white/10 cursor-pointer hover:border-ether-green/50 transition" onclick="switchToEtherlink(128123)" title="Click to switch to Etherlink Testnet">
                        <div id="network-dot" class="w-2 h-2 rounded-full bg-gray-500"></div>
                        <span id="network-name" class="text-xs text-gray-400">Not Connected</span>
                    </div>
                    <button id="wallet-etherlink" class="flex items-center gap-2 px-4 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 transition text-sm font-medium">
                        <i class="fa-brands fa-ethereum text-ether-green"></i>
                        <span id="wallet-etherlink-text">Connect Etherlink</span>
                        <span id="wallet-balance" class="hidden text-ether-green font-mono text-xs"></span>
                    </button>
                    <button id="wallet-jstz" class="flex items-center gap-2 px-4 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 transition text-sm font-medium">
                        <i class="fa-solid fa-bolt text-jstz-accent"></i>
                        <span id="wallet-jstz-text">Connect Jstz</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow pt-24 pb-12 px-4 flex flex-col items-center justify-center relative overflow-hidden">
        
        <!-- Decorative Elements -->
        <div class="absolute top-1/4 left-10 w-64 h-64 bg-green-500/10 rounded-full blur-3xl animate-pulse-slow"></div>
        <div class="absolute bottom-1/4 right-10 w-96 h-96 bg-yellow-500/5 rounded-full blur-3xl animate-pulse-slow" style="animation-delay: 1.5s;"></div>

        <div class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-12 gap-8 z-10">
            
            <!-- Left Column: Swap Interface -->
            <div class="lg:col-span-7 flex flex-col gap-6">
                
                <!-- Progress Stepper -->
                <div class="glass-card rounded-2xl p-8 relative overflow-hidden">
                    <div class="flex justify-between items-center mb-8">
                        <h3 class="text-xs font-bold text-gray-400 uppercase tracking-[0.2em]">Swap Status</h3>
                        <div class="flex items-center gap-2 text-[10px] text-gray-500">
                            <div class="w-1.5 h-1.5 rounded-full bg-ether-green animate-pulse"></div>
                            LIVE
                        </div>
                    </div>

                    <div class="relative px-4 pb-4">
                        <div class="step-line-bg"></div>
                        <div class="step-progress" id="progress-bar"></div>
                        
                        <div class="flex justify-between items-center relative z-10">
                            <div class="relative group cursor-default" id="step-1">
                                <div class="step-dot">1</div>
                                <span class="step-label">Initiate</span>
                            </div>
                            <div class="relative group cursor-default" id="step-2">
                                <div class="step-dot">2</div>
                                <span class="step-label">Participate</span>
                            </div>
                            <div class="relative group cursor-default" id="step-3">
                                <div class="step-dot">3</div>
                                <span class="step-label">Redeem</span>
                            </div>
                            <div class="relative group cursor-default" id="step-4">
                                <div class="step-dot">4</div>
                                <span class="step-label">Complete</span>
                        </div>
                        </div>
                    </div>
                </div>

                <!-- Main Swap Card -->
                <div class="glass-card rounded-2xl p-1">
                    <!-- Tabs -->
                    <div class="grid grid-cols-4 gap-1 p-1 bg-black/20 rounded-t-xl">
                        <button onclick="setTab('create')" id="tab-create" class="flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-ether-border shadow-lg transition-all">
                            Initiate
                        </button>
                        <button onclick="setTab('join')" id="tab-join" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            Join
                        </button>
                        <button onclick="setTab('redeem')" id="tab-redeem" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            Redeem
                        </button>
                        <button onclick="setTab('myswaps')" id="tab-myswaps" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            My Swaps
                        </button>
                    </div>

                    <div class="p-6 sm:p-8">
                        
                        <!-- INITIATE & JOIN CONTENT -->
                        <div id="initiate-join-content" class="space-y-6">
                            <!-- Chain Selection -->
                            <div class="grid grid-cols-2 gap-4 p-1 bg-black/20 rounded-xl">
                            <button onclick="setChain('etherlink')" id="chain-etherlink" class="relative py-3 rounded-lg border border-ether-green bg-ether-green/10 text-white transition-all group overflow-hidden">
                                <div class="flex items-center justify-center gap-2 relative z-10">
                                    <i class="fa-brands fa-ethereum text-ether-green"></i>
                                    <span class="text-sm font-bold">From Etherlink</span>
                                    <i class="fa-solid fa-arrow-right text-gray-500 text-xs"></i>
                                    <i class="fa-solid fa-layer-group text-gray-500 text-xs"></i>
                                </div>
                                <div class="absolute inset-0 bg-ether-green/5 opacity-0 group-hover:opacity-100 transition"></div>
                            </button>
                            <button onclick="setChain('jstz')" id="chain-jstz" class="relative py-3 rounded-lg border border-transparent text-gray-400 hover:text-white hover:bg-white/5 transition-all group">
                                <div class="flex items-center justify-center gap-2 relative z-10">
                                    <i class="fa-solid fa-layer-group text-jstz-accent"></i>
                                    <span class="text-sm font-bold">From Jstz</span>
                                    <i class="fa-solid fa-arrow-right text-gray-500 text-xs"></i>
                                    <i class="fa-brands fa-ethereum text-gray-500 text-xs"></i>
                                </div>
                            </button>
                        </div>

                        <!-- Secret Generator Section -->
                        <div id="secret-section" class="p-5 rounded-xl bg-gradient-to-br from-white/5 to-transparent border border-white/5 relative overflow-hidden group transition-all duration-300">
                            <div class="absolute top-0 right-0 p-3 opacity-50 group-hover:opacity-100 transition">
                                <i class="fa-solid fa-lock text-ether-green"></i>
                            </div>
                            <label class="text-xs font-bold text-ether-green uppercase tracking-widest mb-3 block">
                                <i class="fa-solid fa-key mr-1"></i> Cryptographic Proof
                            </label>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="proof-inputs">
                                <div id="secret-container">
                                    <span class="text-[10px] text-gray-400 uppercase block mb-1">Secret (Preimage) - <span class="text-red-400">Keep Safe</span></span>
                                    <div class="relative">
                                        <input type="text" id="secret-input" class="w-full input-field rounded-lg p-3 text-sm font-mono text-white secret-blur" readonly value="Generating...">
                                        <button onclick="copyToClipboard('secret-input')" class="absolute right-2 top-2 text-gray-500 hover:text-white"><i class="fa-regular fa-copy"></i></button>
                                    </div>
                                </div>
                                <div id="hash-container">
                                    <span class="text-[10px] text-gray-400 uppercase block mb-1">HashLock (Public)</span>
                                    <div class="relative">
                                        <input type="text" id="hash-input" class="w-full input-field rounded-lg p-3 text-sm font-mono text-gray-300" readonly value="Waiting...">
                                        <button id="copy-hash-btn" onclick="copyToClipboard('hash-input')" class="absolute right-2 top-2 text-gray-500 hover:text-white"><i class="fa-regular fa-copy"></i></button>
                                    </div>
                                </div>
                            </div>
                            <button id="regen-secret-btn" onclick="generateNewSecret()" class="mt-3 text-xs text-gray-400 hover:text-white underline decoration-dotted underline-offset-4">
                                Generate New Secret
                            </button>
                        </div>

                        <!-- Input Fields -->
                        <div class="space-y-4">
                            <div class="grid grid-cols-2 gap-4">
                                <div class="relative">
                                    <label class="block text-sm text-gray-400 mb-1">Asset</label>
                                    <div onclick="toggleTokenSelector()" class="flex items-center gap-2 input-field rounded-lg p-3 cursor-pointer hover:bg-white/10 transition">
                                        <img src="https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026" class="w-6 h-6 rounded-full bg-white p-0.5" id="asset-icon">
                                        <span class="font-bold text-white" id="asset-symbol">XTZ</span>
                                        <i class="fa-solid fa-chevron-down ml-auto text-xs text-gray-500"></i>
                                    </div>
                                    <!-- Token Dropdown -->
                                    <div id="token-dropdown" class="hidden absolute top-full left-0 right-0 mt-1 bg-ether-card border border-white/10 rounded-lg shadow-xl z-50 flex-col max-h-60 overflow-y-auto">
                                        <!-- Tokens will be rendered here by JS -->
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">Amount</label>
                                    <input type="number" id="amount-input" placeholder="0.00" class="w-full input-field rounded-lg p-3 text-white font-mono focus:outline-none">
                                    <div id="selected-token-balance" class="text-xs text-gray-500 mt-1">Balance: -- </div>
                                </div>
                            </div>

                <div>
                    <label class="block text-sm text-gray-400 mb-1 flex items-center gap-1">
                        Counterparty Address
                        <div class="relative group">
                            <span class="w-4 h-4 inline-flex items-center justify-center rounded-full bg-white/10 text-[10px] text-gray-400 cursor-help hover:bg-white/20 transition">?</span>
                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 border border-white/20 rounded-lg text-xs text-gray-300 w-64 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50 shadow-xl">
                                <div class="font-semibold text-white mb-1">Who receives the funds?</div>
                                <p><strong>As Alice (Initiator):</strong> Enter Bob's address on the destination chain (Jstz). This is who can claim your locked funds.</p>
                                <p class="mt-1"><strong>As Bob (Participant):</strong> Enter Alice's address on Etherlink. This is who can claim your locked funds.</p>
                                <p class="mt-1 text-gray-500">Leave empty if unknown (uses zero address).</p>
                                <div class="absolute top-full left-1/2 -translate-x-1/2 border-8 border-transparent border-t-gray-900"></div>
                            </div>
                        </div>
                    </label>
                    <input type="text" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                </div>

                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">Timelock (Mins)</label>
                                    <input type="number" id="timelock-input" value="60" class="w-full input-field rounded-lg p-3 text-white font-mono focus:outline-none">
                                </div>
                                <div class="flex items-end">
                                    <div class="text-xs text-gray-500 mb-3">
                                        <i class="fa-regular fa-clock mr-1"></i> Funds revert if not claimed.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Action Button -->
                        <button onclick="executeAction()" id="main-action-btn" class="btn-primary w-full py-4 rounded-xl text-lg shadow-[0_0_20px_rgba(57,255,20,0.2)] flex items-center justify-center gap-2 group">
                            <span>Initiate Swap</span>
                            <i class="fa-solid fa-arrow-right group-hover:translate-x-1 transition-transform"></i>
                        </button>
                        </div> <!-- End initiate-join-content -->

                        <!-- REDEEM / REFUND CONTENT -->
                        <div id="redeem-content" class="hidden space-y-6">
                            <div class="bg-black/20 rounded-xl p-4 border border-white/5">
                                <p class="text-sm text-gray-400 mb-4 text-center">
                                    <i class="fa-solid fa-circle-info mr-2"></i>
                                    Enter the Swap ID (HashLock) to claim or refund funds.
                                </p>
                                
                                <!-- Swap ID Input -->
                                <div class="mb-4">
                                    <label class="block text-xs text-gray-400 mb-1 flex items-center gap-1">
                                        Swap ID / HashLock
                                        <div class="relative group">
                                            <span class="w-3 h-3 inline-flex items-center justify-center rounded-full bg-white/10 text-[8px] text-gray-400 cursor-help">?</span>
                                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 border border-white/20 rounded text-[10px] text-gray-300 w-48 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50">
                                                The HashLock used when initiating the swap
                                            </div>
                                        </div>
                                    </label>
                                    <input type="text" id="swap-id-input" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                                </div>
                                
                                <!-- Secret Input -->
                                <div class="mb-6">
                                    <label class="block text-xs text-gray-400 mb-1 flex items-center gap-1">
                                        Secret (Required for Claim)
                                        <div class="relative group">
                                            <span class="w-3 h-3 inline-flex items-center justify-center rounded-full bg-white/10 text-[8px] text-gray-400 cursor-help">?</span>
                                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 border border-white/20 rounded text-[10px] text-gray-300 w-48 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50">
                                                The preimage/secret revealed by Alice to claim funds
                                            </div>
                                        </div>
                                    </label>
                                    <input type="text" id="secret-input-claim" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                                </div>

                                <!-- Connected Chain Indicator -->
                                <div id="redeem-chain-indicator" class="mb-4 p-3 rounded-xl border border-white/10 bg-white/5">
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-gray-400">Action will be executed on:</span>
                                        <span id="redeem-chain-badge" class="px-3 py-1 rounded-lg text-xs font-bold">
                                            Not Connected
                                        </span>
                                    </div>
                                </div>

                                <!-- Action Buttons -->
                                <div class="grid grid-cols-2 gap-4">
                                    <button onclick="claimSwap()" id="claim-btn" class="py-4 px-4 rounded-xl bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-semibold flex flex-col items-center justify-center gap-1 transition-all shadow-lg shadow-green-500/20 group">
                                        <div class="flex items-center gap-2">
                                            <i class="fa-solid fa-hand-holding-dollar text-lg"></i>
                                            <span id="claim-btn-text">Claim Funds</span>
                                        </div>
                                        <span id="claim-btn-chain" class="text-[10px] opacity-70 font-normal">Connect wallet first</span>
                                    </button>
                                    
                                    <button onclick="refundSwap()" id="refund-btn" class="py-4 px-4 rounded-xl bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-semibold flex flex-col items-center justify-center gap-1 transition-all shadow-lg shadow-red-500/20 group">
                                        <div class="flex items-center gap-2">
                                            <i class="fa-solid fa-rotate-left text-lg"></i>
                                            <span id="refund-btn-text">Refund</span>
                                        </div>
                                        <span id="refund-btn-chain" class="text-[10px] opacity-70 font-normal">Connect wallet first</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- MY SWAPS CONTENT -->
                        <div id="myswaps-content" class="hidden space-y-4">
                            <div class="flex items-center justify-between mb-2">
                                <h3 class="text-sm font-bold text-gray-300 uppercase tracking-wider">
                                    <i class="fa-solid fa-clock-rotate-left mr-2 text-purple-400"></i>
                                    Your Active Swaps
                                </h3>
                                <button onclick="loadMySwaps()" class="text-xs px-3 py-1 rounded-lg bg-white/5 hover:bg-white/10 text-gray-400 hover:text-white transition">
                                    <i class="fa-solid fa-refresh mr-1"></i> Refresh
                                </button>
                            </div>
                            
                            <!-- Loading State -->
                            <div id="swaps-loading" class="hidden text-center py-8">
                                <i class="fa-solid fa-circle-notch fa-spin text-2xl text-purple-400 mb-2"></i>
                                <p class="text-gray-500 text-sm">Loading your swaps...</p>
                            </div>
                            
                            <!-- Empty State -->
                            <div id="swaps-empty" class="text-center py-8 bg-black/20 rounded-xl border border-dashed border-white/10">
                                <i class="fa-solid fa-inbox text-3xl text-gray-600 mb-2"></i>
                                <p class="text-gray-500 text-sm">No active swaps found</p>
                                <p class="text-gray-600 text-xs mt-1">Initiate or join a swap to see it here</p>
                            </div>
                            
                            <!-- Swaps List -->
                            <div id="swaps-list" class="space-y-3">
                                <!-- Swap cards will be inserted here -->
                            </div>
                        </div>

                    </div>
                </div>
        </div>

            <!-- Right Column: Info & Console -->
            <div class="lg:col-span-5 flex flex-col gap-6">
                
                <!-- Network Status -->
                <div class="glass-card rounded-2xl p-6">
                    <h3 class="text-sm font-mono text-gray-400 mb-4 uppercase tracking-wider">Network Bridge</h3>
            
                    <div class="flex items-center justify-between relative">
                        <!-- Left: Etherlink -->
                        <div class="text-center z-10">
                            <div class="w-14 h-14 rounded-2xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 flex items-center justify-center mx-auto mb-2 shadow-lg relative overflow-hidden group">
                                <div class="absolute inset-0 bg-green-500/10 group-hover:bg-green-500/20 transition"></div>
                                <i class="fa-brands fa-ethereum text-2xl text-green-400"></i>
                            </div>
                            <div class="text-sm font-bold text-gray-200">Etherlink</div>
                            <div class="text-[10px] text-green-500">Connected</div>
                        </div>

                        <!-- Center: Animation -->
                        <div class="flex-1 h-px bg-slate-700 mx-4 relative">
                            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 rounded-full bg-slate-900 border border-slate-700 flex items-center justify-center z-20">
                                <i class="fa-solid fa-arrow-right-arrow-left text-gray-500 text-xs"></i>
                    </div>
                            <div class="absolute top-0 left-0 h-full w-1/2 bg-gradient-to-r from-transparent to-green-500 opacity-50 animate-pulse"></div>
                        </div>

                        <!-- Right: Jstz -->
                        <div class="text-center z-10">
                            <div class="w-14 h-14 rounded-2xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 flex items-center justify-center mx-auto mb-2 shadow-lg relative overflow-hidden group">
                                <div class="absolute inset-0 bg-yellow-500/10 group-hover:bg-yellow-500/20 transition"></div>
                                <i class="fa-solid fa-layer-group text-2xl text-jstz-accent"></i>
                    </div>
                            <div class="text-sm font-bold text-gray-200">Jstz</div>
                            <div class="text-[10px] text-gray-500">Waiting...</div>
                        </div>
                    </div>
                </div>

                <!-- Terminal / Logs -->
                <div class="glass-card rounded-2xl flex flex-col flex-grow overflow-hidden h-96 lg:h-auto border-t-4 border-t-ether-green">
                    <div class="bg-black/40 p-3 flex items-center justify-between border-b border-white/5">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-red-500/50"></div>
                            <div class="w-3 h-3 rounded-full bg-yellow-500/50"></div>
                            <div class="w-3 h-3 rounded-full bg-green-500/50"></div>
                        </div>
                        <div class="text-[10px] font-mono text-gray-500">swap_daemon.js</div>
                    </div>
                    <div id="terminal-body" class="p-4 font-mono text-xs space-y-2 overflow-y-auto flex-grow bg-black/20 max-h-[400px]">
                        <div class="text-gray-500">Last login: <span id="login-time"></span> on tty1</div>
                        <div class="text-green-500/50">Initializing atomic swap protocol...</div>
                        <div class="text-green-500/50">Loaded JS environment.</div>
                        <div class="text-white">> Ready.</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="border-t border-white/5 bg-black/20 py-6 mt-auto">
        <div class="max-w-7xl mx-auto px-4 text-center">
            <p class="text-xs text-gray-500">Built for Etherlink Internal Hackathon</p>
        </div>
    </footer>

    <script>
        // --- REAL CONTRACT INTEGRATION ---

        // Contract Configuration - Per Network
        const NETWORK_CONFIG = {
            // Hardhat Local
            31337: {
                name: 'Hardhat Local',
                rpcUrl: 'http://127.0.0.1:8545',
                htlcAddress: '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0',
                explorer: null
            },
            // Etherlink Testnet (Ghostnet) - SHA-256 compatible
            128123: {
                name: 'Etherlink Testnet',
                rpcUrl: 'https://node.ghostnet.etherlink.com',
                htlcAddress: '0x79826f6Ab82C24395123f8419E3aFb995d906bAd',
                explorer: 'https://testnet.explorer.etherlink.com'
            },
            // Etherlink Mainnet
            42793: {
                name: 'Etherlink Mainnet',
                rpcUrl: 'https://node.mainnet.etherlink.com',
                htlcAddress: null, // TODO: Deploy and fill this
                explorer: 'https://explorer.etherlink.com'
            }
        };

        // Default to testnet for real testing
        const DEFAULT_CHAIN_ID = 128123; // Etherlink Testnet

        const CONFIG = {
            // Current Etherlink config (will be updated based on connected network)
            etherlink: {
                contractAddress: NETWORK_CONFIG[DEFAULT_CHAIN_ID]?.htlcAddress || '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                rpcUrl: NETWORK_CONFIG[DEFAULT_CHAIN_ID]?.rpcUrl || 'http://127.0.0.1:8545',
                chainId: DEFAULT_CHAIN_ID,
                abi: [
                    "function initiateSwap(address recipient, bytes32 hashLock, uint256 expiration) external payable returns (bytes32)",
                    "function claimSwap(bytes32 swapId, bytes calldata secret) external returns (bool)",
                    "function refundSwap(bytes32 swapId) external returns (bool)",
                    "function getSwap(bytes32 swapId) external view returns (address recipient, address sender, uint256 amount, uint256 expiration, bytes32 hashLock, uint8 status)",
                    "function swapPresent(bytes32 swapId) external view returns (bool)",
                    "event SwapInitiated(bytes32 indexed swapId, address payable sender, address recipient, uint256 amount, bytes32 hashLock, uint256 expiration)",
                    "event SwapClaimed(bytes32 indexed swapId, address claimer, bytes secret)",
                    "event SwapRefunded(bytes32 indexed swapId, address sender, uint256 amount)"
                ]
            },
            // Jstz HTLC Smart Function
            jstz: {
                // Jstz Privatenet - accessible to everyone
                rpcUrl: 'https://privatenet.jstz.info',
                network: 'privatenet',
                functionAddress: 'jstz://htlc/',
                contractAddress: 'KT1VDySdkM5Q4Fi432U2FMYzzUTT6sw49ZcE'
            }
        };

        // ERC20 ABI for token interactions
        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function symbol() view returns (string)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)"
        ];

        // Network Chain IDs
        const CHAIN_IDS = {
            HARDHAT_LOCAL: 31337,
            ETHERLINK_MAINNET: 42793,
            ETHERLINK_TESTNET: 128123
        };

        // Etherlink Tokens - Simplified for POC
        // Only XTZ (native) and WXTZ (wrapped) for atomic swap demonstration
        const TOKENS = {
            XTZ: {
                symbol: 'XTZ',
                name: 'Tezos (Native)',
                address: null, // Native token
                decimals: 18,
                icon: 'https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026',
                isNative: true,
                chains: [CHAIN_IDS.HARDHAT_LOCAL, CHAIN_IDS.ETHERLINK_MAINNET, CHAIN_IDS.ETHERLINK_TESTNET]
            },
            WXTZ: {
                symbol: 'WXTZ',
                name: 'Wrapped XTZ',
                // Addresses per network
                addresses: {
                    [CHAIN_IDS.ETHERLINK_MAINNET]: '0xc9B53AB2679f573e480d01e0f49e2B5CFB7a3EAb',
                    [CHAIN_IDS.ETHERLINK_TESTNET]: '0xB1Ea698633d57705e93b0E40c1077d46CD6A51d8'
                },
                decimals: 18,
                icon: 'https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026',
                isNative: false,
                chains: [CHAIN_IDS.ETHERLINK_MAINNET, CHAIN_IDS.ETHERLINK_TESTNET]
            }
        };

        // Helper to get token address for current network
        function getTokenAddress(tokenSymbol) {
            const token = TOKENS[tokenSymbol];
            if (!token || token.isNative) return null;
            
            // If token has per-network addresses
            if (token.addresses && state.currentChainId) {
                return token.addresses[state.currentChainId] || null;
            }
            // Fallback to single address
            return token.address || null;
        }

        // State
        const state = {
            mode: 'create', // 'create' | 'join'
            step: 1,
            secret: null,
            secretBytes: null,
            hash: null,
            chain: 'etherlink', // 'etherlink' (From Etherlink) | 'jstz' (From Jstz)
            connectedWallet: null, // 'etherlink' | 'jstz' | null
            etherlinkWallet: null,
            etherlinkAddress: null,
            jstzAddress: null,
            provider: null,
            signer: null,
            contract: null,
            currentSwapId: null,
            selectedToken: 'XTZ', // Default token
            tokenBalances: {},
            tokenSelectorOpen: false,
            currentChainId: null // Current network chain ID
        };

        // Utils
        const log = (msg, type = 'info') => {
            const term = document.getElementById('terminal-body');
            const line = document.createElement('div');
            const time = new Date().toLocaleTimeString([], {hour12: false});
            
            let color = 'text-gray-300';
            if (type === 'success') color = 'text-ether-green';
            if (type === 'error') color = 'text-red-400';
            if (type === 'warning') color = 'text-yellow-400';
            if (type === 'system') color = 'text-blue-400';

            line.className = `${color} hover:bg-white/5 p-0.5 rounded`;
            line.innerHTML = `<span class="opacity-50 mr-2">[${time}]</span>${msg}`;
            
            term.appendChild(line);
            term.scrollTop = term.scrollHeight;
        };

        // Helper: Log transaction with explorer link
        const logTx = (txHash, message = 'Transaction') => {
            const networkConfig = NETWORK_CONFIG[state.currentChainId];
            const explorer = networkConfig?.explorer;
            if (explorer) {
                const txUrl = `${explorer}/tx/${txHash}`;
                log(`${message}: <a href="${txUrl}" target="_blank" class="text-ether-green hover:underline">${txHash.substring(0, 18)}... ðŸ”—</a>`, 'success');
            } else {
                log(`${message}: ${txHash}`, 'success');
            }
        };

        document.getElementById('login-time').innerText = new Date().toDateString();

        // Generate secret using SHA-256 for cross-chain compatibility (Etherlink + Jstz)
        function generateNewSecret() {
            // Generate 32 random bytes as secret
            const randomBytes = ethers.utils.randomBytes(32);
            const secret = ethers.utils.hexlify(randomBytes);
            
            // Hash using SHA-256 (cross-chain compatible with Solidity and Jstz)
            const hash = ethers.utils.sha256(randomBytes);
            
            state.secret = secret;
            state.secretBytes = randomBytes;
            state.hash = hash;
            
            document.getElementById('secret-input').value = secret;
            document.getElementById('hash-input').value = hash;
            
            log(`Generated new Preimage/Hash pair.`, 'system');
            log(`Hash: ${hash.substring(0, 18)}...`, 'system');
        }

        // Connect to Etherlink (MetaMask or local)
        async function connectEtherlink() {
            try {
                console.log('[DEBUG] Starting Etherlink connection...');
                
                if (typeof window.ethereum !== 'undefined') {
                    // Use MetaMask
                    console.log('[DEBUG] MetaMask detected, requesting accounts...');
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    state.provider = new ethers.providers.Web3Provider(window.ethereum);
                    state.signer = state.provider.getSigner();
                    state.etherlinkAddress = await state.signer.getAddress();
                    console.log('[DEBUG] Connected address:', state.etherlinkAddress);
                    log(`MetaMask connected: ${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`, 'success');
                } else {
                    // Fallback to local Hardhat node
                    console.log('[DEBUG] No MetaMask, falling back to local node');
                    state.provider = new ethers.providers.JsonRpcProvider(CONFIG.etherlink.rpcUrl);
                    state.signer = state.provider.getSigner(0);
                    state.etherlinkAddress = await state.signer.getAddress();
                    log(`Connected to local node: ${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`, 'success');
                }
                
                // Get current chain ID
                const network = await state.provider.getNetwork();
                state.currentChainId = network.chainId;
                console.log('[DEBUG] Connected to chainId:', state.currentChainId);
                
                // Log network info
                const networkConfig = NETWORK_CONFIG[state.currentChainId];
                const networkName = networkConfig?.name || getNetworkName(state.currentChainId);
                log(`Network: ${networkName} (chainId: ${state.currentChainId})`, 'info');
                
                // Update network badge in header
                updateNetworkBadge(state.currentChainId, networkName);
                
                // Check if we're on the wrong network
                const isEtherlinkNetwork = [128123, 42793, 31337].includes(state.currentChainId);
                if (!isEtherlinkNetwork) {
                    log(`âš ï¸ Wrong network! You are on ${networkName} (chainId: ${state.currentChainId})`, 'warning');
                    log(`Click the network badge to switch to Etherlink Testnet`, 'system');
                    console.log('[DEBUG] Wrong network detected. Expected Etherlink (128123, 42793, or 31337), got:', state.currentChainId);
                }
                
                // Get HTLC contract address for this network
                const htlcAddress = networkConfig?.htlcAddress;
                if (!htlcAddress) {
                    log(`âš ï¸ HTLC contract not deployed on ${networkName}!`, 'warning');
                    log(`Deploy with: npx hardhat run scripts/deploy.js --network etherlinkTestnet`, 'system');
                    console.log('[DEBUG] No HTLC address for chainId:', state.currentChainId);
                }
                
                // Initialize contract (if address exists)
                if (htlcAddress) {
                    state.contract = new ethers.Contract(
                        htlcAddress,
                        CONFIG.etherlink.abi,
                        state.signer
                    );
                    log(`HTLC Contract: ${htlcAddress.substring(0, 10)}...`, 'success');
                    console.log('[DEBUG] Contract initialized at:', htlcAddress);
                } else {
                    state.contract = null;
                }
                
                // Fetch and log balance
                await fetchAndLogBalance();
                
                // Update UI to reflect connected wallet
                updateWalletConnectionUI('etherlink');
                
                return true;
            } catch (error) {
                console.error('[DEBUG] Connection error:', error);
                log(`Etherlink connection failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        /**
         * Update UI based on which wallet is connected
         * Disables the other wallet button and grays out incompatible options
         */
        function updateWalletConnectionUI(connectedWallet) {
            const etherlinkBtn = document.getElementById('wallet-etherlink');
            const jstzBtn = document.getElementById('wallet-jstz');
            const chainEtherlinkBtn = document.getElementById('chain-etherlink');
            const chainJstzBtn = document.getElementById('chain-jstz');
            
            if (connectedWallet === 'etherlink') {
                // Etherlink wallet connected
                state.connectedWallet = 'etherlink';
                updateRedeemChainIndicator();
                
                // Disable Jstz wallet button
                if (jstzBtn) {
                    jstzBtn.disabled = true;
                    jstzBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    jstzBtn.title = 'Disconnect Etherlink first';
                }
                
                // Gray out Jstz chain option
                if (chainJstzBtn) {
                    chainJstzBtn.classList.add('opacity-40', 'pointer-events-none');
                    chainJstzBtn.title = 'Connect Jstz wallet to use this';
                }
                if (chainEtherlinkBtn) {
                    chainEtherlinkBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainEtherlinkBtn.title = '';
                }
                
                // Auto-select Etherlink chain
                if (state.chain !== 'etherlink') {
                    setChain('etherlink');
                }
                
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
                log('ðŸ”— ETHERLINK MODE ACTIVATED (You are ALICE)', 'success');
                log('ðŸ“ Direction: Etherlink â†’ Jstz', 'info');
                log('', 'system');
                log('âœ… You can INITIATE a new swap:', 'success');
                log('   1. Click "Initiate" to generate a hash', 'system');
                log('   2. Click "Initiate Swap" to lock your XTZ', 'system');
                log('   3. Share the HASH with Bob', 'system');
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
                
            } else if (connectedWallet === 'jstz') {
                // Jstz wallet connected
                state.connectedWallet = 'jstz';
                updateRedeemChainIndicator();
                
                // Disable Etherlink wallet button
                if (etherlinkBtn) {
                    etherlinkBtn.disabled = true;
                    etherlinkBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    etherlinkBtn.title = 'Disconnect Jstz first';
                }
                
                // Gray out Etherlink chain option
                if (chainEtherlinkBtn) {
                    chainEtherlinkBtn.classList.add('opacity-40', 'pointer-events-none');
                    chainEtherlinkBtn.title = 'Connect Etherlink wallet to use this';
                }
                if (chainJstzBtn) {
                    chainJstzBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainJstzBtn.title = '';
                }
                
                // Auto-select Jstz chain
                if (state.chain !== 'jstz') {
                    setChain('jstz');
                }
                
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
                log('ðŸ”— JSTZ MODE ACTIVATED (You are BOB)', 'warning');
                log('ðŸ“ Direction: Jstz â†’ Etherlink', 'info');
                log('', 'system');
                log('âš ï¸ IMPORTANT: To initiate a swap from Jstz:', 'warning');
                log('   Alice must have locked funds on Etherlink first!', 'info');
                log('   Use "Join" and paste Alice\'s hash.', 'system');
                log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
                
            } else {
                // No wallet connected - enable both
                state.connectedWallet = null;
                updateRedeemChainIndicator();
                
                // Re-enable both wallet buttons
                if (etherlinkBtn) {
                    etherlinkBtn.disabled = false;
                    etherlinkBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    etherlinkBtn.title = '';
                }
                if (jstzBtn) {
                    jstzBtn.disabled = false;
                    jstzBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    jstzBtn.title = '';
                }
                
                // Re-enable both chain options and reset to default (Etherlink active)
                if (chainEtherlinkBtn) {
                    chainEtherlinkBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainEtherlinkBtn.title = '';
                }
                if (chainJstzBtn) {
                    chainJstzBtn.classList.remove('opacity-40', 'pointer-events-none');
                    chainJstzBtn.title = '';
                }
                
                // Reset to default chain selection
                setChain('etherlink');
            }
        }
        
        /**
         * Disconnect wallet and reset UI
         */
        function disconnectWallet() {
            state.etherlinkAddress = null;
            state.jstzAddress = null;
            state.provider = null;
            state.signer = null;
            state.contract = null;
            state.connectedWallet = null;
            updateRedeemChainIndicator();
            
            // Reset Etherlink button
            const etherlinkBtn = document.getElementById('wallet-etherlink');
            const etherlinkText = document.getElementById('wallet-etherlink-text');
            const balanceSpan = document.getElementById('wallet-balance');
            if (etherlinkBtn) {
                etherlinkText.textContent = 'Connect Etherlink';
                balanceSpan.classList.add('hidden');
            }
            
            // Reset Jstz button
            const jstzBtn = document.getElementById('wallet-jstz');
            const jstzText = document.getElementById('wallet-jstz-text');
            if (jstzBtn && jstzText) {
                jstzText.textContent = 'Connect Jstz';
            }
            
            // Re-enable both wallet buttons
            updateWalletConnectionUI(null);
            
            log('Wallet disconnected', 'info');
        }
        
        // Update the network badge in header
        function updateNetworkBadge(chainId, networkName) {
            const badge = document.getElementById('network-badge');
            const dot = document.getElementById('network-dot');
            const name = document.getElementById('network-name');
            
            if (!badge || !dot || !name) return;
            
            name.textContent = networkName;
            
            // Color based on network
            if (chainId === 128123) {
                // Etherlink Testnet - Green (correct network)
                dot.className = 'w-2 h-2 rounded-full bg-ether-green animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-ether-green/50 cursor-pointer hover:border-ether-green transition';
                name.className = 'text-xs text-ether-green';
            } else if (chainId === 42793) {
                // Etherlink Mainnet - Blue
                dot.className = 'w-2 h-2 rounded-full bg-blue-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-blue-500/50 cursor-pointer hover:border-blue-500 transition';
                name.className = 'text-xs text-blue-400';
            } else if (chainId === 31337) {
                // Hardhat Local - Yellow
                dot.className = 'w-2 h-2 rounded-full bg-yellow-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-yellow-500/50 cursor-pointer hover:border-yellow-500 transition';
                name.className = 'text-xs text-yellow-400';
            } else {
                // Wrong network - Red with prominent "click to switch" indicator
                dot.className = 'w-2 h-2 rounded-full bg-red-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-red-500/20 border-2 border-red-500 cursor-pointer hover:bg-red-500/30 transition animate-pulse';
                name.className = 'text-xs text-red-400 font-bold';
                name.innerHTML = `${networkName} <span class="ml-1 text-[10px] bg-red-500 text-white px-1 rounded">âš ï¸ CLICK TO SWITCH</span>`;
                
                // Log warning message
                log(`âš ï¸ Wrong network detected! Click the red badge to switch to Etherlink Testnet`, 'error');
            }
        }
        
        // Fetch and log balance with debug info
        async function fetchAndLogBalance() {
            if (!state.provider || !state.etherlinkAddress) {
                console.log('[DEBUG] Cannot fetch balance - provider or address missing');
                return;
            }
            
            try {
                console.log('[DEBUG] Fetching native balance for:', state.etherlinkAddress);
                const balance = await state.provider.getBalance(state.etherlinkAddress);
                const balanceEth = ethers.utils.formatEther(balance);
                console.log('[DEBUG] Native balance (wei):', balance.toString());
                console.log('[DEBUG] Native balance (XTZ):', balanceEth);
                log(`Balance: ${parseFloat(balanceEth).toFixed(4)} XTZ`, 'info');
                
                // Update balance display
                const balanceDisplay = document.querySelector('.text-gray-500');
                if (balanceDisplay && balanceDisplay.textContent.includes('Balance:')) {
                    balanceDisplay.textContent = `Balance: ${parseFloat(balanceEth).toFixed(4)} XTZ`;
                }
            } catch (error) {
                console.error('[DEBUG] Error fetching balance:', error);
                log(`Error fetching balance: ${error.message}`, 'error');
            }
        }

        // Add Etherlink network to MetaMask
        async function addEtherlinkToMetaMask(chainId = 128123) {
            if (typeof window.ethereum === 'undefined') {
                log('MetaMask not installed', 'error');
                return false;
            }
            
            const networkConfig = NETWORK_CONFIG[chainId];
            if (!networkConfig) {
                log('Unknown network', 'error');
                return false;
            }

            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: '0x' + chainId.toString(16),
                        chainName: networkConfig.name,
                        nativeCurrency: {
                            name: 'Tezos',
                            symbol: 'XTZ',
                            decimals: 18
                        },
                        rpcUrls: [networkConfig.rpcUrl],
                        blockExplorerUrls: networkConfig.explorer ? [networkConfig.explorer] : null
                    }]
                });
                log(`${networkConfig.name} added to MetaMask!`, 'success');
                return true;
            } catch (error) {
                log(`Failed to add network: ${error.message}`, 'error');
                return false;
            }
        }

        // Switch MetaMask to Etherlink network
        async function switchToEtherlink(chainId = 128123) {
            if (typeof window.ethereum === 'undefined') return false;
            
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x' + chainId.toString(16) }]
                });
                return true;
            } catch (error) {
                // Chain not added, try to add it
                if (error.code === 4902) {
                    return await addEtherlinkToMetaMask(chainId);
                }
                log(`Failed to switch network: ${error.message}`, 'error');
                return false;
            }
        }

        // Get human-readable network name
        function getNetworkName(chainId) {
            switch (chainId) {
                case CHAIN_IDS.HARDHAT_LOCAL: return 'Hardhat Local';
                case CHAIN_IDS.ETHERLINK_MAINNET: return 'Etherlink Mainnet';
                case CHAIN_IDS.ETHERLINK_TESTNET: return 'Etherlink Testnet';
                default: return `Unknown (${chainId})`;
            }
        }

        // Check if token is available on current network
        function isTokenAvailable(tokenSymbol) {
            const token = TOKENS[tokenSymbol];
            if (!token) {
                console.log(`[DEBUG] Token ${tokenSymbol} not found in TOKENS`);
                return false;
            }
            if (!state.currentChainId) {
                console.log(`[DEBUG] No chainId set, defaulting to native only for ${tokenSymbol}`);
                return token.isNative;
            }
            const available = token.chains.includes(state.currentChainId);
            console.log(`[DEBUG] Token ${tokenSymbol}: chainId=${state.currentChainId}, supportedChains=[${token.chains.join(',')}], available=${available}`);
            return available;
        }

        // Get available tokens for current network
        function getAvailableTokens() {
            return Object.entries(TOKENS)
                .filter(([symbol, token]) => isTokenAvailable(symbol))
                .reduce((acc, [symbol, token]) => {
                    acc[symbol] = token;
                    return acc;
                }, {});
        }

        // Jstz API calls
        /**
         * Jstz Request Handler
         * Uses Jstz wallet extension if available, otherwise shows CLI commands
         */
        const encoder = new TextEncoder();
        const decoder = new TextDecoder('utf-8');
        
        // Read-only request to Jstz (no signature needed)
        async function jstzReadOnly(path) {
            const contractAddress = CONFIG.jstz.contractAddress;
            const rpcUrl = CONFIG.jstz.rpcUrl;
            
            console.log(`[JSTZ] Read-only: ${path}`);
            
            try {
                // Try direct HTTP call to the smart function endpoint
                // Jstz allows reading state without signing
                const response = await fetch(`${rpcUrl}/smart_functions/${contractAddress}/state${path}`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.log('[JSTZ] Direct read failed, trying alternative...');
            }
            
            // Fallback: return null to indicate we need CLI
            return null;
        }
        
        async function jstzRequest(method, path, body = null, requiresSignature = true) {
            const contractAddress = CONFIG.jstz.contractAddress;
            const rpcUrl = CONFIG.jstz.rpcUrl;
            
            log(`ðŸ“¤ Jstz: ${method} ${path}`, 'system');
            
            // For read operations, try without signature first
            if (!requiresSignature || path.startsWith('/swap/') || path === '/swaps') {
                log(`ðŸ“– Attempting read-only request...`, 'system');
                // For reads, we'll just return null and let the UI handle it
                // The user will need to check via CLI
                const cliCmd = `jstz run "jstz://${contractAddress}${path}" -n privatenet -m POST -d '{}'`;
                console.log('[JSTZ] Read CLI command:', cliCmd);
                
                // Return a "not found" response for verification - we can't read without executing
                // The user should verify via CLI or trust the process
                return { error: 'READ_ONLY_NOT_SUPPORTED', cliCommand: cliCmd };
            }
            
            // Check if extension is available
            const hasExtension = isJstzExtensionInstalled();
            
            if (!hasExtension) {
                // No extension - show CLI command
                const cliCmd = `jstz run "jstz://${contractAddress}${path}" -n privatenet -m POST -d '${JSON.stringify(body || {})}'`;
                log(`âš ï¸ Jstz wallet extension not detected`, 'warning');
                log(`ðŸ“‹ Run this CLI command instead:`, 'system');
                log(`<code class="bg-black/50 px-2 py-1 rounded text-xs break-all">${cliCmd}</code>`, 'info');
                
                // Return simulated response for demo
                return simulateJstzResponse(path, body);
            }
            
            // Extension available - use it!
            try {
                log(`ðŸ” Requesting signature from Jstz wallet...`, 'warning');
                
                // Build the operation - body must be Array of bytes as per wallet docs
                const bodyJson = body ? JSON.stringify(body) : '';
                const bodyBytes = bodyJson ? Array.from(encoder.encode(bodyJson)) : [];
                
                const operation = {
                    _type: 'RunFunction',
                    uri: `jstz://${contractAddress}${path}`,
                    method: 'POST',
                    headers: {},
                    body: bodyBytes, // Array of bytes as per wallet documentation
                    gasLimit: 100000
                };
                
                console.log('[JSTZ] Body JSON:', bodyJson);
                console.log('[JSTZ] Body bytes length:', bodyBytes.length);
                
                console.log('[JSTZ] Operation to sign:', operation);
                
                // Request signature from extension
                const signResponse = await requestJstzSignature(operation);
                
                log(`âœ… Signature received from ${signResponse.accountAddress.substring(0, 10)}...`, 'success');
                console.log('[JSTZ] Sign response:', signResponse);
                
                // Inject the signed operation using Jstz SDK (as per documentation)
                log(`ðŸ“¡ Injecting operation to Jstz privatenet...`, 'warning');
                
                const { operation: signedOperation, signature, accountAddress } = signResponse;
                console.log(`[JSTZ] Operation signed by: ${accountAddress}`);
                
                // Use the Jstz client SDK for injection
                if (window.JstzClient) {
                    const jstzClient = new window.JstzClient({
                        baseURL: rpcUrl,
                        timeout: 10000
                    });
                    
                    console.log('[JSTZ] Using SDK for injection, operation:', signedOperation);
                    
                    try {
                        const { result: { inner } } = await jstzClient.operations.injectAndPoll({
                            inner: signedOperation,
                            signature: signature
                        });
                        
                        console.log('[JSTZ] SDK injection result inner:', inner);
                        
                        // Parse response body
                        let returnedMessage = 'Success';
                        if (typeof inner === 'object' && inner && 'body' in inner) {
                            try {
                                returnedMessage = inner.body ? JSON.parse(decoder.decode(new Uint8Array(inner.body))) : 'No body';
                            } catch (e) {
                                returnedMessage = 'Response received';
                            }
                        } else if (typeof inner === 'string') {
                            returnedMessage = inner;
                        }
                        
                        log(`âœ… Jstz operation successful!`, 'success');
                        console.log('[JSTZ] Parsed response:', returnedMessage);
                        return returnedMessage;
                        
                    } catch (sdkError) {
                        console.error('[JSTZ] SDK injection error:', sdkError);
                        throw sdkError;
                    }
                }
                
                // Fallback to direct fetch if SDK not loaded
                console.log('[JSTZ] SDK not available, using direct fetch');
                log(`âš ï¸ Jstz SDK not loaded, trying direct injection...`, 'warning');
                
                const injectResponse = await fetch(`${rpcUrl}/operations`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        inner: signedOperation,
                        signature: signature
                    })
                });
                
                if (!injectResponse.ok) {
                    const errorText = await injectResponse.text();
                    throw new Error(`Injection failed: ${errorText}`);
                }
                
                const result = await injectResponse.json();
                console.log('[JSTZ] Injection result:', result);
                
                // Parse response body if present
                let parsedResult = result;
                if (result.result?.inner?.body) {
                    try {
                        const bodyBytes = new Uint8Array(result.result.inner.body);
                        parsedResult = JSON.parse(decoder.decode(bodyBytes));
                    } catch (e) {
                        // Keep original result
                    }
                }
                
                log(`âœ… Jstz operation successful!`, 'success');
                return parsedResult;
                
            } catch (error) {
                console.error('[JSTZ] Extension error:', error);
                log(`âŒ Jstz wallet error: ${error.message}`, 'error');
                
                // Show CLI modal as fallback
                const cliCmd = `jstz run "jstz://${contractAddress}${path}" -n privatenet -m POST -d '${JSON.stringify(body || {})}'`;
                
                log(`ðŸ’¡ Use the CLI command popup to complete this operation`, 'warning');
                showCLIModal(cliCmd, `The Jstz wallet extension failed. Run this command in your terminal to ${path.includes('initiate') ? 'initiate the swap' : path.includes('claim') ? 'claim the swap' : path.includes('refund') ? 'refund the swap' : 'execute the operation'}:`);
                
                // Return a special object indicating CLI fallback
                return { 
                    success: false, 
                    cliRequired: true, 
                    cliCommand: cliCmd,
                    error: error.message 
                };
            }
        }
        
        // Simulate Jstz response for demo when extension not available
        function simulateJstzResponse(path, body) {
            if (path === '/initiate') {
                return {
                    success: true,
                    event: 'SwapInitiated',
                    data: {
                        hashlock: body?.hashLock || body?.hashlock,
                        sender: state.jstzAddress || 'tz1...',
                        amount: body?.amount,
                        status: 'OPEN'
                    },
                    simulated: true
                };
            }
            
            if (path === '/claim') {
                return {
                    success: true,
                    event: 'SwapClaimed',
                    data: { hashlock: body?.hashLock || body?.hashlock },
                    simulated: true
                };
            }
            
            if (path === '/refund') {
                return {
                    success: true,
                    event: 'SwapRefunded',
                    simulated: true
                };
            }
            
            return { found: false, simulated: true };
        }
        

        // ============================================
        // TOKEN & BALANCE MANAGEMENT
        // ============================================

        // Get balance for a specific token
        async function getTokenBalance(tokenSymbol) {
            if (!state.provider || !state.etherlinkAddress) return '0';
            
            const token = TOKENS[tokenSymbol];
            if (!token) return '0';
            
            // Check if token is available on current network
            if (!isTokenAvailable(tokenSymbol)) {
                return 'N/A';
            }

            try {
                if (token.isNative) {
                    // Native XTZ balance
                    const balance = await state.provider.getBalance(state.etherlinkAddress);
                    return ethers.utils.formatUnits(balance, token.decimals);
                } else {
                    // ERC20 token balance - use getTokenAddress for per-network addresses
                    const tokenAddress = getTokenAddress(tokenSymbol);
                    if (!tokenAddress) return 'N/A';
                    
                    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, state.provider);
                    const balance = await tokenContract.balanceOf(state.etherlinkAddress);
                    return ethers.utils.formatUnits(balance, token.decimals);
                }
            } catch (error) {
                // Token contract doesn't exist on this network
                console.warn(`Token ${tokenSymbol} not available on current network`);
                return 'N/A';
            }
        }

        // Fetch all token balances
        async function fetchAllBalances() {
            if (!state.provider || !state.etherlinkAddress) return;

            const availableTokens = getAvailableTokens();
            const tokenCount = Object.keys(availableTokens).length;
            log(`Fetching balances for ${tokenCount} token(s)...`, 'system');
            
            for (const [symbol, token] of Object.entries(TOKENS)) {
                if (isTokenAvailable(symbol)) {
                    const balance = await getTokenBalance(symbol);
                    state.tokenBalances[symbol] = balance;
                } else {
                    state.tokenBalances[symbol] = 'N/A';
                }
            }

            // Update UI
            updateBalanceDisplay();
            renderTokenDropdown(); // Re-render with updated balances
            log('Balances updated', 'success');
        }

        // Update balance display in UI
        function updateBalanceDisplay() {
            const balanceEl = document.getElementById('selected-token-balance');
            const walletBalanceEl = document.getElementById('wallet-balance');
            
            if (balanceEl && state.selectedToken) {
                const balance = state.tokenBalances[state.selectedToken];
                if (balance === 'N/A' || !isTokenAvailable(state.selectedToken)) {
                    balanceEl.innerText = `Balance: N/A (not on this network)`;
                } else {
                    const formatted = parseFloat(balance || '0').toFixed(4);
                    balanceEl.innerText = `Balance: ${formatted} ${state.selectedToken}`;
                }
            }
            
            // Update wallet button with XTZ balance
            if (walletBalanceEl && state.tokenBalances['XTZ'] && state.tokenBalances['XTZ'] !== 'N/A') {
                const xtzBalance = parseFloat(state.tokenBalances['XTZ']).toFixed(2);
                walletBalanceEl.innerText = `${xtzBalance} XTZ`;
            }
        }

        // Select a token
        function selectToken(symbol) {
            const token = TOKENS[symbol];
            if (!token) return;

            state.selectedToken = symbol;
            
            // Update UI
            document.getElementById('asset-icon').src = token.icon;
            document.getElementById('asset-symbol').innerText = token.symbol;
            
            // Close dropdown
            toggleTokenSelector(false);
            
            // Update balance display
            updateBalanceDisplay();
            
            log(`Selected token: ${token.name} (${token.symbol})`, 'info');
        }

        // Toggle token selector dropdown
        function toggleTokenSelector(forceState = null) {
            const dropdown = document.getElementById('token-dropdown');
            if (!dropdown) return;

            state.tokenSelectorOpen = forceState !== null ? forceState : !state.tokenSelectorOpen;
            
            if (state.tokenSelectorOpen) {
                dropdown.classList.remove('hidden');
                dropdown.classList.add('flex');
            } else {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('flex');
            }
        }

        // Update the Redeem tab chain indicator based on connected wallet
        function updateRedeemChainIndicator() {
            const badge = document.getElementById('redeem-chain-badge');
            const claimChain = document.getElementById('claim-btn-chain');
            const refundChain = document.getElementById('refund-btn-chain');
            
            if (!badge) return;
            
            if (state.connectedWallet === 'etherlink') {
                badge.textContent = 'âŸ  Etherlink';
                badge.className = 'px-3 py-1 rounded-lg text-xs font-bold bg-ether-green/20 text-ether-green border border-ether-green/30';
                if (claimChain) claimChain.textContent = 'on Etherlink';
                if (refundChain) refundChain.textContent = 'on Etherlink';
            } else if (state.connectedWallet === 'jstz') {
                badge.textContent = 'âš¡ Jstz';
                badge.className = 'px-3 py-1 rounded-lg text-xs font-bold bg-jstz-accent/20 text-jstz-accent border border-jstz-accent/30';
                if (claimChain) claimChain.textContent = 'on Jstz';
                if (refundChain) refundChain.textContent = 'on Jstz';
            } else {
                badge.textContent = 'âš ï¸ Not Connected';
                badge.className = 'px-3 py-1 rounded-lg text-xs font-bold bg-red-500/20 text-red-400 border border-red-500/30';
                if (claimChain) claimChain.textContent = 'Connect wallet first';
                if (refundChain) refundChain.textContent = 'Connect wallet first';
            }
        }

        // Render token list in dropdown
        function renderTokenDropdown() {
            const dropdown = document.getElementById('token-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';
            
            for (const [symbol, token] of Object.entries(TOKENS)) {
                const balance = state.tokenBalances[symbol] || '0';
                const isAvailable = isTokenAvailable(symbol);
                const isSelected = symbol === state.selectedToken;
                
                // Format balance
                let formattedBalance;
                if (!isAvailable || balance === 'N/A') {
                    formattedBalance = 'N/A';
                } else {
                    formattedBalance = parseFloat(balance).toFixed(4);
                }
                
                const item = document.createElement('div');
                item.className = `flex items-center justify-between p-3 transition ${
                    isAvailable 
                        ? `hover:bg-white/10 cursor-pointer ${isSelected ? 'bg-ether-green/10' : ''}` 
                        : 'opacity-40 cursor-not-allowed'
                }`;
                
                if (isAvailable) {
                    item.onclick = () => selectToken(symbol);
                }
                
                const tokenAddr = getTokenAddress(symbol);
                item.innerHTML = `
                    <div class="flex items-center gap-3">
                        <img src="${token.icon}" class="w-8 h-8 rounded-full bg-white p-0.5 ${!isAvailable ? 'grayscale' : ''}" alt="${token.symbol}">
                        <div>
                            <div class="font-bold ${isAvailable ? 'text-white' : 'text-gray-500'}">${token.symbol}</div>
                            <div class="text-xs text-gray-400">${token.name}</div>
                            ${!isAvailable ? '<div class="text-[10px] text-yellow-500">Not on this network</div>' : ''}
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-sm font-mono ${isAvailable ? 'text-white' : 'text-gray-500'}">${formattedBalance}</div>
                        ${!token.isNative && tokenAddr ? `<div class="text-[10px] text-gray-500 truncate max-w-[80px]">${tokenAddr.substring(0, 10)}...</div>` : ''}
                    </div>
                `;
                dropdown.appendChild(item);
            }
        }

        // Add to MetaMask wallet
        async function addTokenToWallet(symbol) {
            const token = TOKENS[symbol];
            if (!token || token.isNative) {
                log('Cannot add native token to wallet', 'warning');
                return;
            }

            if (typeof window.ethereum === 'undefined') {
                log('MetaMask not detected', 'error');
                return;
            }

            try {
                await window.ethereum.request({
                    method: 'wallet_watchAsset',
                    params: {
                        type: 'ERC20',
                        options: {
                            address: token.address,
                            symbol: token.symbol,
                            decimals: token.decimals,
                            image: token.icon
                        }
                    }
                });
                log(`${token.symbol} added to wallet`, 'success');
            } catch (error) {
                log(`Failed to add token: ${error.message}`, 'error');
            }
        }

        function setChain(chain) {
            // Check if switching to a chain requires the correct wallet
            if (chain === 'etherlink' && state.connectedWallet === 'jstz') {
                log('âš ï¸ Cannot select Etherlink chain with Jstz wallet connected', 'warning');
                return;
            }
            if (chain === 'jstz' && state.connectedWallet === 'etherlink') {
                log('âš ï¸ Cannot select Jstz chain with Etherlink wallet connected', 'warning');
                return;
            }
            
            state.chain = chain;
            const btnEth = document.getElementById('chain-etherlink');
            const btnJstz = document.getElementById('chain-jstz');

            // Reset styles
            const activeClass = "border-ether-green bg-ether-green/10 text-white";
            const inactiveClass = "border-transparent text-gray-400 hover:text-white hover:bg-white/5";
            const grayedClass = "opacity-40 pointer-events-none";

            if (chain === 'etherlink') {
                btnEth.className = `relative py-3 rounded-lg transition-all group overflow-hidden ${activeClass}`;
                // Keep jstz grayed if etherlink wallet connected
                const jstzClass = state.connectedWallet === 'etherlink' 
                    ? `relative py-3 rounded-lg transition-all group ${inactiveClass} ${grayedClass}`
                    : `relative py-3 rounded-lg transition-all group ${inactiveClass}`;
                btnJstz.className = jstzClass;
                log("ðŸ“ Direction: Etherlink â†’ Jstz", 'info');
            } else {
                btnJstz.className = `relative py-3 rounded-lg transition-all group overflow-hidden border-jstz-accent bg-jstz-accent/10 text-white`;
                // Keep etherlink grayed if jstz wallet connected
                const ethClass = state.connectedWallet === 'jstz'
                    ? `relative py-3 rounded-lg transition-all group ${inactiveClass} ${grayedClass}`
                    : `relative py-3 rounded-lg transition-all group ${inactiveClass}`;
                btnEth.className = ethClass;
                log("ðŸ“ Direction: Jstz â†’ Etherlink", 'info');
            }
            
            // Update balance display for selected token
            updateBalanceDisplay();
        }

        function setTab(mode) {
            state.mode = mode;
            const btnCreate = document.getElementById('tab-create');
            const btnJoin = document.getElementById('tab-join');
            const btnRedeem = document.getElementById('tab-redeem');
            const btnMySwaps = document.getElementById('tab-myswaps');
            const actionBtn = document.getElementById('main-action-btn');
            const secretSection = document.getElementById('secret-section');
            const timelockInput = document.getElementById('timelock-input');
            
            // Content Sections
            const initiateJoinContent = document.getElementById('initiate-join-content');
            const redeemContent = document.getElementById('redeem-content');
            const myswapsContent = document.getElementById('myswaps-content');
            
            // Input Containers
            const secretContainer = document.getElementById('secret-container');
            const hashContainer = document.getElementById('hash-container');
            const proofInputs = document.getElementById('proof-inputs');
            const hashInput = document.getElementById('hash-input');
            const copyHashBtn = document.getElementById('copy-hash-btn');
            const regenSecretBtn = document.getElementById('regen-secret-btn');

            // Reset Button State
            actionBtn.disabled = false;
            actionBtn.onclick = executeAction;
            actionBtn.classList.remove('bg-ether-green', 'text-black');

            // Reset Tab Styles
            const inactiveStyle = "flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all";
            btnCreate.className = inactiveStyle;
            btnJoin.className = inactiveStyle;
            btnRedeem.className = inactiveStyle;
            btnMySwaps.className = inactiveStyle;
            
            // Hide all content sections
            initiateJoinContent.classList.add('hidden');
            redeemContent.classList.add('hidden');
            myswapsContent.classList.add('hidden');

            if (mode === 'redeem') {
                // REDEEM MODE
                btnRedeem.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-purple-600 shadow-lg transition-all";
                redeemContent.classList.remove('hidden');
                log("Switched to Redeem / Refund Mode", 'info');
                return;
            }
            
            if (mode === 'myswaps') {
                // MY SWAPS MODE
                btnMySwaps.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-gradient-to-r from-purple-600 to-pink-600 shadow-lg transition-all";
                myswapsContent.classList.remove('hidden');
                log("Switched to My Swaps", 'info');
                // Auto-load swaps when tab is opened
                loadMySwaps();
                return;
            }
            
            // INITIATE or JOIN MODE
            initiateJoinContent.classList.remove('hidden');

            if (mode === 'create') {
                btnCreate.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-ether-border shadow-lg transition-all";
                
                // SHOW Secret Gen UI
                secretSection.classList.remove('opacity-50', 'pointer-events-none', 'grayscale');
                secretContainer.style.display = 'block';
                proofInputs.classList.remove('grid-cols-1');
                proofInputs.classList.add('md:grid-cols-2');
                
                regenSecretBtn.style.display = 'block';
                copyHashBtn.style.display = 'block';
                
                // Hash Input Readonly
                hashInput.readOnly = true;
                hashInput.classList.add('text-gray-300');
                hashInput.classList.remove('text-white', 'bg-white/5');
                
                generateNewSecret();
                
                // Reset Timelock
                if(timelockInput) timelockInput.value = 60;

                actionBtn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right group-hover:translate-x-1 transition-transform"></i>`;
                actionBtn.className = "btn-primary w-full py-4 rounded-xl text-lg shadow-[0_0_20px_rgba(57,255,20,0.2)] flex items-center justify-center gap-2 group";
                
                log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”", 'system');
                log("ðŸ‘¤ MODE: ALICE (Initiator)", 'success');
                log("ðŸ“‹ You are CREATING a new swap", 'info');
                log("1ï¸âƒ£ Generate a secret and a hash", 'system');
                log("2ï¸âƒ£ Click 'Initiate Swap' to lock your funds", 'system');
                log("3ï¸âƒ£ Share the HASH with Bob (not the secret!)", 'system');
                log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”", 'system');
            } else {
                btnJoin.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-black bg-jstz-accent shadow-lg transition-all";
                
                // HIDE Secret Gen UI, SHOW Manual Hash Input
                secretSection.classList.remove('opacity-50', 'pointer-events-none', 'grayscale'); // Keep active for input
                secretContainer.style.display = 'none';
                proofInputs.classList.remove('md:grid-cols-2');
                proofInputs.classList.add('grid-cols-1');
                
                regenSecretBtn.style.display = 'none';
                copyHashBtn.style.display = 'none';
                
                // Make Hash Input Editable
                hashInput.readOnly = false;
                hashInput.value = "";
                hashInput.placeholder = "Paste HashLock here (0x...)";
                hashInput.classList.remove('text-gray-300');
                hashInput.classList.add('text-white', 'bg-white/5');
                hashInput.focus();

                // Enforce Timelock < Alice's (e.g. 30 mins)
                if(timelockInput) timelockInput.value = 30;

                actionBtn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                actionBtn.className = "w-full py-4 rounded-xl text-lg font-bold bg-jstz-accent text-black shadow-lg flex items-center justify-center gap-2 hover:brightness-110 transition-all";
                
                log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”", 'system');
                log("ðŸ‘¤ MODE: BOB (Participant)", 'warning');
                log("ðŸ“‹ You are RESPONDING to an existing swap", 'info');
                log("âš ï¸ PREREQUISITE: Alice must have ALREADY locked her funds!", 'warning');
                log("1ï¸âƒ£ Paste the HASH received from Alice", 'system');
                log("2ï¸âƒ£ The system verifies Alice has locked funds", 'system');
                log("3ï¸âƒ£ Click 'Match Swap' to lock your funds", 'system');
                log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”", 'system');
            }
        }

        function updateProgress(step) {
            state.step = step;
            const progressBar = document.getElementById('progress-bar');
            
            // Reset all
            [1,2,3,4].forEach(i => {
                const container = document.getElementById(`step-${i}`);
                const dot = container.querySelector('.step-dot');
                
                dot.classList.remove('active', 'completed');
                dot.innerHTML = i;
                
                if (i < step) {
                    dot.classList.add('completed');
                    dot.innerHTML = '<i class="fa-solid fa-check"></i>';
                } else if (i === step) {
                    dot.classList.add('active');
        }
            });

            // Bar width
            const percentage = ((step - 1) / 3) * 100;
            progressBar.style.width = `${percentage}%`;
        }

        // ============================================
        // REAL CONTRACT INTERACTIONS
        // ============================================

        // ALICE initiates swap on Etherlink (locks XTZ, Bob will match on Jstz)
        async function initiateAsAliceOnEtherlink() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const counterpartyInput = document.querySelector('input[placeholder="0x..."]');
            const timelockInput = document.getElementById('timelock-input');
            const timelockMins = parseInt(timelockInput?.value || 60);
            
            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("âŒ Please enter a valid amount (> 0)", 'error');
                return;
            }
            
            // 2. Validate hashlock exists and is properly formatted
            if (!state.hash || !isValidHashLock(state.hash)) {
                log("âŒ Invalid HashLock. Generate a new secret first.", 'error');
                return;
            }
            
            // 3. Validate secret exists (needed for claiming later)
            if (!state.secret) {
                log("âŒ Secret not found. Generate a new secret first.", 'error');
                return;
            }
            
            // 4. Validate timelock (minimum 5 minutes for safety)
            if (timelockMins < 5) {
                log("âŒ Timelock must be at least 5 minutes for safety", 'error');
                return;
            }

            // Connect if not connected
            if (!state.provider) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }

            // Check if contract is deployed on this network
            if (!state.contract) {
                const networkName = NETWORK_CONFIG[state.currentChainId]?.name || 'this network';
                log(`âŒ HTLC contract not deployed on ${networkName}!`, 'error');
                log('Deploy with: npx hardhat run scripts/deploy.js --network etherlinkTestnet', 'system');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking for duplicates...`;
            
            // ========== DUPLICATE CHECK ==========
            // 5. Check if swap with this hashlock already exists
            log('Checking if swap already exists...', 'warning');
            const existingSwap = await verifySwapOnEtherlink(state.hash);
            if (existingSwap.valid && existingSwap.swap) {
                log(`âŒ A swap with this HashLock already exists!`, 'error');
                log(`State: ${['OPEN', 'CLAIMED', 'EXPIRED'][existingSwap.swap.status]}`, 'info');
                log(`Generate a new secret to create a new swap.`, 'system');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log('âœ“ HashLock is unique', 'success');
            
            // ========== BALANCE CHECK ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking balance...`;
            
            // 6. Check user has enough balance
            const balance = await state.provider.getBalance(state.etherlinkAddress);
            const amountWei = ethers.utils.parseEther(amount);
            if (balance.lt(amountWei)) {
                const balanceEth = ethers.utils.formatEther(balance);
                log(`âŒ Insufficient balance!`, 'error');
                log(`Required: ${amount} XTZ, Available: ${parseFloat(balanceEth).toFixed(4)} XTZ`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log('âœ“ Sufficient balance', 'success');
            
            // ========== EXECUTE INITIATE ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Initiating Swap...`;

            try {
                const recipient = counterpartyInput?.value || ethers.constants.AddressZero;
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                
                log(`Initiating swap on Etherlink...`, 'warning');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`HashLock: ${state.hash.substring(0, 18)}...`, 'info');
                log(`Expiration: ${new Date(expiration * 1000).toLocaleTimeString()} (${timelockMins} mins)`, 'info');
                if (recipient !== ethers.constants.AddressZero) {
                    log(`Recipient: ${recipient.substring(0, 10)}...`, 'info');
                }

                const tx = await state.contract.initiateSwap(
                    recipient,
                    state.hash,
                    expiration,
                    { value: amountWei }
                );

                logTx(tx.hash, 'ðŸ“¤ Transaction sent');
                
                const receipt = await tx.wait();
                
                state.currentSwapId = state.hash;
                
                log(`âœ… Swap initiated on Etherlink!`, 'success');
                logTx(receipt.hash || tx.hash, 'âœ… Confirmed');
                log(`SwapId: ${state.currentSwapId.substring(0, 18)}...`, 'info');
                log(`Funds Locked: ${amount} ETH`, 'success');
                
                updateProgress(2);
                btn.innerHTML = `<span>Waiting for Bob on Jstz...</span>`;
                
                log(``, 'system');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                log(`ðŸŽ‰ SWAP INITIATED SUCCESSFULLY!`, 'success');
                log(``, 'system');
                log(`ðŸ“‹ NEXT STEP:`, 'warning');
                log(`   Share this HASH with Bob:`, 'info');
                log(`   ${state.hash}`, 'system');
                log(``, 'system');
                log(`ðŸ‘¤ BOB MUST:`, 'info');
                log(`   1. Connect with his Jstz wallet`, 'system');
                log(`   2. Click "Join" and paste the hash`, 'system');
                log(`   3. Click "Match Swap" to lock his funds`, 'system');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.currentSwapId, state.secret);
                log("Go to 'Redeem / Refund' tab to claim or refund later", 'system');
                
                // Enable claim button after Bob participates
                setTimeout(() => {
                    log("Ready to claim on Jstz (when Bob has locked funds)", 'system');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Waiting for Bob...</span>`;
                    // No onClick needed here, user should go to Redeem tab
                    updateProgress(3);
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // ALICE initiates swap on Jstz (locks XTZ, Bob will match on Etherlink)
        async function initiateAsAliceOnJstz() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const counterpartyInput = document.querySelector('input[placeholder="0x..."]');
            const timelockInput = document.getElementById('timelock-input');
            const timelockMins = parseInt(timelockInput?.value || 60);

            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("âŒ Please enter a valid amount (> 0)", 'error');
                return;
            }
            
            // 2. Validate we have a secret (Alice generates the secret)
            if (!state.secret || !state.hash) {
                log("âŒ Please generate a secret first (click 'Initiate' tab)", 'error');
                return;
            }
            
            // 3. Validate timelock (minimum 5 minutes for safety)
            if (timelockMins < 5) {
                log("âŒ Timelock must be at least 5 minutes for safety", 'error');
                return;
            }

            // 4. Connect Jstz if not connected
            if (!state.jstzAddress) {
                log('Connecting to Jstz wallet...', 'warning');
                const connected = await connectJstz();
                if (!connected) {
                    log('âŒ Failed to connect Jstz wallet', 'error');
                    return;
                }
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking for duplicates...`;

            // ========== CHECK FOR DUPLICATE ON JSTZ ==========
            // Note: We can't verify duplicates without CLI, so we skip this check
            // The Jstz smart function will reject if a duplicate exists
            log('âš ï¸ Skipping duplicate check (requires CLI verification)', 'warning');
            log('ðŸ’¡ The smart function will reject if hash already exists', 'system');

            // ========== INITIATE SWAP ON JSTZ ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Locking funds on Jstz...`;

            try {
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                const recipient = counterpartyInput?.value || '';
                
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                log(`ðŸ” ALICE INITIE SUR JSTZ`, 'warning');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`HashLock: ${state.hash.substring(0, 18)}...`, 'info');
                log(`Expiration: ${new Date(expiration * 1000).toLocaleTimeString()} (${timelockMins} mins)`, 'info');
                if (recipient) {
                    log(`Recipient (Bob): ${recipient.substring(0, 15)}...`, 'info');
                }
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                
                // Call Jstz smart function
                log(`Calling Jstz HTLC: /initiate`, 'system');
                
                const response = await jstzRequest('POST', '/initiate', {
                    hashlock: state.hash,
                    amount: amount,
                    expiration: expiration,
                    recipient: recipient || null
                });
                
                // Handle CLI fallback
                if (response && response.cliRequired) {
                    log(`âš ï¸ Complete the swap using the CLI command in the popup`, 'warning');
                    log(`ðŸ“‹ After running the CLI command, verify the swap was created`, 'info');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                    return;
                }
                
                if (!response || response.error) {
                    throw new Error(response?.error || 'Failed to initiate swap on Jstz');
                }
                
                // Store for later
                state.currentSwapId = state.hash;
                
                log(``, 'system');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                log(`ðŸŽ‰ SWAP INITIATED SUCCESSFULLY ON JSTZ!`, 'success');
                log(`ðŸ’° Funds locked: ${amount} XTZ`, 'success');
                log(``, 'system');
                log(`ðŸ“‹ NEXT STEP:`, 'warning');
                log(`   Share this HASH with Bob:`, 'info');
                log(`   ${state.hash}`, 'system');
                log(``, 'system');
                log(`ðŸ‘¤ BOB MUST:`, 'info');
                log(`   1. Connect with MetaMask (Etherlink)`, 'system');
                log(`   2. Click "Join" and paste the hash`, 'system');
                log(`   3. Click "Match Swap" to lock his funds`, 'system');
                log(``, 'system');
                log(`â° After Bob locks funds, you can claim on Etherlink!`, 'warning');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                
                updateProgress(2);
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.currentSwapId, state.secret);
                
                btn.innerHTML = `<span>Waiting for Bob on Etherlink...</span>`;
                
                setTimeout(() => {
                    log("Ready to claim on Etherlink (when Bob has locked)", 'system');
                    btn.disabled = false;
                    updateProgress(3);
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // BOB matches swap on Jstz (Alice already locked on Etherlink)
        async function matchAsBobOnJstz() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const hashInput = document.getElementById('hash-input');
            const hashlock = hashInput.value;
            const timelockInput = document.getElementById('timelock-input');
            const timelockMins = parseInt(timelockInput?.value || 30);

            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("âŒ Please enter a valid amount (> 0)", 'error');
                return;
            }

            // 2. Validate hashlock format
            if (!hashlock || !isValidHashLock(hashlock)) {
                log("âŒ Please enter a valid HashLock (0x + 64 hex characters)", 'error');
                log("Get the HashLock from Alice who initiated the swap", 'info');
                return;
            }
            
            // 3. Validate timelock (Bob's timelock should be shorter than Alice's)
            if (timelockMins < 2) {
                log("âŒ Timelock must be at least 2 minutes", 'error');
                return;
            }
            
            // 4. Warning if timelock is too long (should be shorter than Alice's)
            if (timelockMins >= 60) {
                log("âš ï¸ Warning: Your timelock should be shorter than Alice's for safety", 'warning');
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying Alice's swap...`;
            
            // ========== VERIFY ALICE'S SWAP EXISTS ==========
            // 5. Check that Alice has already locked funds on Etherlink with this hashlock
            log("Checking if Alice has locked funds on Etherlink...", 'warning');
            const aliceSwap = await verifySwapOnEtherlink(hashlock, SwapState.OPEN);
            
            if (!aliceSwap.valid) {
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                log(`âŒ ERROR: No swap found on Etherlink!`, 'error');
                log(``, 'system');
                log(`ðŸ“‹ What this means:`, 'warning');
                log(`   Alice has not yet locked her funds`, 'info');
                log(`   with this HashLock on Etherlink.`, 'info');
                log(``, 'system');
                log(`âœ… What you need to do:`, 'success');
                log(`   1. Ask Alice to initiate the swap first`, 'system');
                log(`   2. Alice must click "From Etherlink" with this hash`, 'system');
                log(`   3. Then come back here to "Match Swap"`, 'system');
                log(``, 'system');
                log(`ðŸ”‘ Expected HashLock: ${hashlock.substring(0, 20)}...`, 'info');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            log(`âœ“ Found Alice's swap: ${aliceSwap.swap.amount} XTZ locked`, 'success');
            log(`âœ“ Expires: ${aliceSwap.swap.expirationDate}`, 'success');
            
            // 6. Check Alice's swap hasn't expired
            if (aliceSwap.swap.isExpired) {
                log("âŒ Alice's swap has expired! Don't lock your funds.", 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            // 7. Check there's enough time for Bob's timelock to be shorter
            const aliceExpiration = aliceSwap.swap.expiration;
            const now = Math.floor(Date.now() / 1000);
            const aliceRemainingMins = Math.floor((aliceExpiration - now) / 60);
            
            if (timelockMins >= aliceRemainingMins) {
                log(`âŒ Your timelock (${timelockMins}m) must be shorter than Alice's remaining time (${aliceRemainingMins}m)`, 'error');
                log(`Recommended: Set timelock to ${Math.floor(aliceRemainingMins / 2)} minutes`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log(`âœ“ Timelock is safe (${timelockMins}m < ${aliceRemainingMins}m remaining)`, 'success');
            
            // ========== SKIP DUPLICATE CHECK ON JSTZ ==========
            // Note: Can't verify duplicates without CLI, Jstz smart function will reject if exists
            log('âš ï¸ Skipping Jstz duplicate check (will fail if hash exists)', 'warning');
            
            // ========== EXECUTE INITIATE ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Locking on Jstz...`;

            try {
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                
                log(`Initiating swap on Jstz...`, 'warning');
                log(`HashLock: ${hashlock.substring(0, 18)}...`, 'info');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`Timelock: ${timelockMins} minutes`, 'info');
                
                // Call Jstz smart function
                log(`Calling Jstz HTLC: jstz://htlc/initiate`, 'system');
                
                const response = await jstzRequest('POST', '/initiate', {
                    hashlock: hashlock,
                    amount: amount,
                    expiration: expiration,
                    recipient: null
                });
                
                // Handle CLI fallback
                if (response && response.cliRequired) {
                    log(`âš ï¸ Complete the swap using the CLI command in the popup`, 'warning');
                    log(`ðŸ“‹ After running the CLI command, verify the swap was created`, 'info');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                    return;
                }
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                state.currentSwapId = hashlock;
                state.hash = hashlock;
                
                log(``, 'system');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                log(`ðŸŽ‰ SWAP MATCHED SUCCESSFULLY!`, 'success');
                log(`ðŸ’° Funds locked: ${amount} XTZ`, 'success');
                log(``, 'system');
                log(`ðŸ“‹ NEXT STEPS:`, 'warning');
                log(`   1. Wait for Alice to claim your funds on Jstz`, 'info');
                log(`   2. When she claims, the SECRET will be revealed`, 'info');
                log(`   3. Use this secret to claim on Etherlink!`, 'info');
                log(``, 'system');
                log(`â° IMPORTANT: Claim before Alice's swap expires!`, 'warning');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                
                updateProgress(3);
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.hash, null);
                log("Go to 'Redeem / Refund' tab when the secret is revealed", 'system');
                
                btn.innerHTML = `<span>Waiting for Secret...</span>`;
                
                // Poll for secret revelation or enable manual claim
                setTimeout(() => {
                    log("Ready to claim on Etherlink (when Alice reveals the secret)", 'system');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Waiting for Secret...</span>`;
                    // No onClick needed here, user should go to Redeem tab
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // BOB matches swap on Etherlink (Alice already locked on Jstz)
        async function matchAsBobOnEtherlink() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const hashInput = document.getElementById('hash-input');
            const hashlock = hashInput.value;
            const timelockInput = document.getElementById('timelock-input');
            const timelockMins = parseInt(timelockInput?.value || 30);

            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("âŒ Please enter a valid amount (> 0)", 'error');
                return;
            }
            
            // 2. Validate hashlock (provided by Alice)
            if (!hashlock || !isValidHashLock(hashlock)) {
                log("âŒ Please enter Alice's HashLock (0x...)", 'error');
                return;
            }
            
            // 3. Validate timelock (Bob's timelock should be shorter than Alice's)
            if (timelockMins < 2) {
                log("âŒ Timelock must be at least 2 minutes", 'error');
                return;
            }
            
            // 4. Warning if timelock is too long (should be shorter than Alice's)
            if (timelockMins >= 60) {
                log("âš ï¸ Warning: Your timelock should be shorter than Alice's for safety", 'warning');
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying Alice's swap on Jstz...`;
            
            // ========== VERIFY ALICE'S SWAP EXISTS ON JSTZ ==========
            log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”", 'system');
            log("ðŸ” BOB VERIFYING ALICE'S SWAP ON JSTZ", 'warning');
            log("âš ï¸ Cannot auto-verify Jstz swap (extension limitation)", 'warning');
            log(`ðŸ’¡ Verify manually with CLI:`, 'system');
            log(`<code class="bg-black/50 px-2 py-1 rounded text-xs">jstz run "jstz://${CONFIG.jstz.contractAddress}/swap/${hashlock}" -n privatenet -m POST -d '{}'</code>`, 'info');
            log(``, 'system');
            log(`âš ï¸ IMPORTANT: Only proceed if you've verified Alice's swap exists!`, 'warning');
            log(`   Continuing without verification...`, 'info');
            log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
            
            // We can't verify, so we'll let the user proceed at their own risk
            // They should verify via CLI before proceeding
            // For safety, we'll still try to estimate a reasonable timelock
            const assumedAliceRemainingMins = 60; // Assume Alice has ~60 mins left
            
            if (timelockMins >= assumedAliceRemainingMins) {
                log(`âš ï¸ Your timelock (${timelockMins}m) may be too long`, 'warning');
                log(`Recommended: Set timelock to 30 minutes or less`, 'info');
            }
            
            // Skip the swap status/expiration checks since we can't verify via extension
            // The user should verify via CLI before proceeding

            // ========== CHECK FOR DUPLICATE ON ETHERLINK ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking for duplicates on Etherlink...`;
            
            const existingEthSwap = await verifySwapOnEtherlink(hashlock);
            if (existingEthSwap.valid && existingEthSwap.swap) {
                log(`âŒ A swap with this HashLock already exists on Etherlink!`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log('âœ“ HashLock is unique on Etherlink', 'success');

            // ========== CONNECT ETHERLINK IF NEEDED ==========
            if (!state.contract) {
                log('Connecting to Etherlink...', 'warning');
                const connected = await connectEtherlink();
                if (!connected) {
                    log('âŒ Failed to connect to Etherlink', 'error');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                    return;
                }
            }

            // ========== INITIATE SWAP ON ETHERLINK ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Locking funds on Etherlink...`;

            try {
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                log(`ðŸ” BOB MATCHE SUR ETHERLINK`, 'warning');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`HashLock: ${hashlock.substring(0, 18)}...`, 'info');
                log(`Expiration: ${new Date(expiration * 1000).toLocaleTimeString()} (${timelockMins} mins)`, 'info');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                
                log('Sending transaction to Etherlink...', 'warning');
                
                const tx = await state.contract.initiateSwap(
                    ethers.constants.AddressZero, // recipient - No specific recipient for flexibility
                    hashlock, // hashLock
                    expiration,
                    { value: ethers.utils.parseEther(amount) }
                );
                
                logTx(tx.hash, 'Transaction sent');
                log('Waiting for confirmation...', 'warning');
                
                const receipt = await tx.wait();
                
                // Store for later
                state.currentSwapId = hashlock;
                state.hash = hashlock;
                
                log(``, 'system');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                log(`ðŸŽ‰ SWAP MATCHED SUCCESSFULLY ON ETHERLINK!`, 'success');
                logTx(receipt.hash || tx.hash, 'âœ… Confirmed');
                log(`ðŸ’° Funds locked: ${amount} XTZ`, 'success');
                log(``, 'system');
                log(`ðŸ“‹ NEXT STEPS:`, 'warning');
                log(`   1. Wait for Alice to claim your funds on Etherlink`, 'info');
                log(`   2. When she claims, the SECRET will be revealed`, 'info');
                log(`   3. Use this secret to claim on Jstz!`, 'info');
                log(``, 'system');
                log(`â° IMPORTANT: Claim before Alice's swap expires!`, 'warning');
                log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
                
                updateProgress(3);
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.hash, null);
                
                btn.innerHTML = `<span>Waiting for Secret...</span>`;
                
                setTimeout(() => {
                    log("Ready to claim on Jstz (when Alice reveals the secret)", 'system');
                    btn.disabled = false;
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // Alice claims on Jstz (reveals secret)
        async function claimOnJstz() {
            const btn = document.getElementById('main-action-btn');
            const hashLock = state.currentSwapId || state.hash;
            const secret = state.secret;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate inputs
            if (!hashLock || !isValidHashLock(hashLock)) {
                log('âŒ Invalid or missing HashLock', 'error');
                return;
            }
            
            if (!secret) {
                log('âŒ Secret is required to claim', 'error');
                return;
            }
            
            // 2. Verify secret matches the hashlock
            if (!verifySecretMatchesHash(secret, hashLock)) {
                log('âŒ Secret does not match HashLock!', 'error');
                log('The provided secret hash does not equal the hashlock', 'error');
                return;
            }
            log('âœ“ Secret matches HashLock', 'success');
            
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying swap on Jstz...`;
            
            // 3. Try to verify swap exists on Jstz (may fail due to extension limitation)
            log('Verifying swap exists on Jstz...', 'warning');
            const verification = await verifySwapOnJstz(hashLock);
            
            if (!verification.valid) {
                // Can't verify - but allow to proceed anyway (Jstz will reject if invalid)
                log(`âš ï¸ Cannot auto-verify: ${verification.error}`, 'warning');
                log('Proceeding anyway - Jstz will reject if swap does not exist', 'info');
            }
            
            // Only check swap details if verification succeeded
            if (verification.valid && verification.swap) {
                const swap = verification.swap;
                log(`âœ“ Swap found on Jstz: ${swap.amount} XTZ locked`, 'success');
                
                // 4. Check if swap is already claimed or refunded (Jstz uses string status)
                if (swap.status === 'CLAIMED') {
                    log('âŒ Swap has already been claimed!', 'error');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Claim on Jstz</span>`;
                    return;
                }
                
                if (swap.status === 'REFUNDED') {
                    log('âŒ Swap has been refunded!', 'error');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Claim on Jstz</span>`;
                    return;
                }
                
                // 5. Check timelock hasn't expired
                if (swap.isExpired) {
                    log('âŒ Swap has expired! Cannot claim after timelock.', 'error');
                    log(`Expired at: ${swap.expirationDate}`, 'info');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Claim on Jstz</span>`;
                    return;
                }
                log(`âœ“ Timelock valid until: ${swap.expirationDate}`, 'success');
            } else {
                log(`âš ï¸ Skipping swap validation (will be checked by Jstz)`, 'warning');
            }
            
            // ========== EXECUTE CLAIM ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Claiming on Jstz...`;

            try {
                log(`Claiming on Jstz with secret...`, 'warning');
                log(`Secret: ${secret.substring(0, 18)}...`, 'system');
                
                // Call Jstz smart function to claim
                log(`Calling Jstz HTLC: jstz://htlc/claim`, 'system');
                
                const response = await jstzRequest('POST', '/claim', {
                    hashlock: hashLock,
                    secret: secret
                });
                
                // Handle CLI fallback
                if (response && response.cliRequired) {
                    log(`âš ï¸ Complete the claim using the CLI command in the popup`, 'warning');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Claim on Jstz</span>`;
                    return;
                }
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                log(`âœ… Claimed on Jstz!`, 'success');
                log(`Secret revealed: ${secret.substring(0, 18)}...`, 'system');
                log(`Alice has received XTZ!`, 'success');
                
                updateProgress(4);
                
                btn.innerHTML = `<i class="fa-solid fa-check-circle"></i> Swap Complete`;
                btn.classList.add('bg-ether-green', 'text-black');
                btn.disabled = true;

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
            }
        }

        // ============================================
        // SWAP VERIFICATION FUNCTIONS
        // ============================================
        
        // Swap states enum (matching Solidity contract)
        // Must match Solidity enum: enum SwapStatus { OPEN, CLAIMED, EXPIRED }
        const SwapState = {
            OPEN: 0,       // Swap is active, funds locked
            CLAIMED: 1,    // Swap was claimed
            EXPIRED: 2     // Swap was refunded/expired
        };
        
        // Verify swap exists and is in correct state on Etherlink
        // Uses read-only provider to avoid changing wallet connection state
        async function verifySwapOnEtherlink(swapId, expectedState = null) {
            try {
                // Use read-only provider to check swap without connecting wallet
                const rpcUrl = NETWORK_CONFIG[128123].rpcUrl;
                const htlcAddress = NETWORK_CONFIG[128123].htlcAddress;
                
                console.log('[VERIFY] Using RPC:', rpcUrl);
                console.log('[VERIFY] Contract address:', htlcAddress);
                console.log('[VERIFY] Swap ID:', swapId);
                
                const readOnlyProvider = new ethers.providers.JsonRpcProvider(rpcUrl);
                const readOnlyContract = new ethers.Contract(
                    htlcAddress,
                    CONFIG.etherlink.abi,
                    readOnlyProvider
                );
                
                console.log('[VERIFY] Checking swap on Etherlink (read-only)...');
                const swap = await readOnlyContract.getSwap(swapId);
                console.log('[VERIFY] Raw swap result:', swap);
                
                console.log('[VERIFY] Swap data:', {
                    sender: swap.sender,
                    recipient: swap.recipient,
                    amount: swap.amount?.toString(),
                    hashLock: swap.hashLock,
                    expiration: swap.expiration?.toString(),
                    status: swap.status
                });
                
                // Check if swap exists (sender is not zero address)
                if (swap.sender === ethers.constants.AddressZero) {
                    return { 
                        valid: false, 
                        error: 'Swap does not exist on Etherlink',
                        swap: null
                    };
                }
                
                // Check status if expected state provided (OPEN=0, CLAIMED=1, EXPIRED=2)
                if (expectedState !== null && swap.status !== expectedState) {
                    const stateNames = ['OPEN', 'CLAIMED', 'EXPIRED'];
                    return {
                        valid: false,
                        error: `Swap is ${stateNames[swap.status]}, expected ${stateNames[expectedState]}`,
                        swap
                    };
                }
                
                // Check expiration for claim (must not be expired)
                const now = Math.floor(Date.now() / 1000);
                const isExpired = now >= swap.expiration.toNumber();
                
                return {
                    valid: true,
                    swap: {
                        sender: swap.sender,
                        recipient: swap.recipient,
                        amount: ethers.utils.formatEther(swap.amount),
                        hashLock: swap.hashLock,
                        expiration: swap.expiration.toNumber(),
                        expirationDate: new Date(swap.expiration.toNumber() * 1000).toLocaleString(),
                        status: swap.status,
                        isExpired
                    }
                };
                
            } catch (error) {
                console.error('[VERIFY] Error:', error);
                return { 
                    valid: false, 
                    error: `Failed to verify swap: ${error.message}` 
                };
            }
        }
        
        // Verify swap exists and is in correct state on Jstz
        // NOTE: Jstz requires signed transactions even for reads, so we can't verify without CLI
        async function verifySwapOnJstz(hashLock) {
            console.log('[VERIFY] Checking swap on Jstz:', hashLock);
            
            // Since Jstz requires signatures even for reads, we return "cannot verify"
            // and let the user proceed (they'll get an error from Jstz if swap doesn't exist)
            log(`âš ï¸ Cannot verify Jstz swap without CLI (extension limitation)`, 'warning');
            log(`ðŸ’¡ Use CLI to verify: jstz run "jstz://${CONFIG.jstz.contractAddress}/swap/${hashLock}" -n privatenet -m POST -d '{}'`, 'system');
            
            // Return "unknown" state - let the user proceed
            return {
                valid: false,
                cannotVerify: true,
                error: 'Cannot verify Jstz swap via extension - use CLI',
                swap: null
            };
        }
        
        // Validate hashlock format
        function isValidHashLock(hashLock) {
            if (!hashLock) return false;
            // Must be 0x followed by 64 hex characters (32 bytes)
            return /^0x[a-fA-F0-9]{64}$/.test(hashLock);
        }
        
        // Validate secret matches hashlock using SHA-256 (cross-chain compatible)
        function verifySecretMatchesHash(secret, hashLock) {
            if (!secret || !hashLock) return false;
            try {
                const computedHash = ethers.utils.sha256(secret);
                const matches = computedHash.toLowerCase() === hashLock.toLowerCase();
                console.log('[VERIFY] Secret verification (SHA-256):', {
                    secret: secret.substring(0, 18) + '...',
                    computedHash,
                    expectedHash: hashLock,
                    matches
                });
                return matches;
            } catch (error) {
                console.error('[VERIFY] Secret verification error:', error);
                return false;
            }
        }

        // Pre-fill Redeem/Refund form
        function prefillRedeemForm(swapId, secret) {
            const swapIdInput = document.getElementById('swap-id-input');
            const secretInput = document.getElementById('secret-input-claim');
            
            if (swapIdInput && swapId) {
                swapIdInput.value = swapId;
            }
            if (secretInput && secret) {
                secretInput.value = secret;
            }
            
            // Optional: auto-switch to redeem tab? Maybe too intrusive.
            // setTab('redeem');
            log('Swap details saved for Redeem/Refund tab', 'info');
        }

        // ============================================
        // MY SWAPS FUNCTIONALITY
        // ============================================
        
        // Store loaded swaps
        state.mySwaps = [];
        let swapTimerInterval = null;
        
        // Status labels and colors
        // Note: Status 2 in contract means REFUNDED (after refundSwap was called)
        const SWAP_STATUS = {
            0: { label: 'OPEN', color: 'text-green-400', bg: 'bg-green-400/20', icon: 'fa-lock' },
            1: { label: 'CLAIMED', color: 'text-blue-400', bg: 'bg-blue-400/20', icon: 'fa-check-circle' },
            2: { label: 'REFUNDED', color: 'text-orange-400', bg: 'bg-orange-400/20', icon: 'fa-rotate-left' }
        };
        
        // Load all swaps for the connected address
        async function loadMySwaps() {
            if (!state.contract || !state.etherlinkAddress) {
                log('Connect wallet first to see your swaps', 'warning');
                document.getElementById('swaps-empty').classList.remove('hidden');
                document.getElementById('swaps-list').innerHTML = '';
                document.getElementById('swaps-loading').classList.add('hidden');
                return;
            }
            
            const loadingEl = document.getElementById('swaps-loading');
            const emptyEl = document.getElementById('swaps-empty');
            const listEl = document.getElementById('swaps-list');
            
            loadingEl.classList.remove('hidden');
            emptyEl.classList.add('hidden');
            listEl.innerHTML = '';
            
            try {
                console.log('[MY SWAPS] Loading swaps for:', state.etherlinkAddress);
                
                // Get current block number
                const currentBlock = await state.provider.getBlockNumber();
                // Search in chunks of 499 blocks (Etherlink limit is 500!)
                const CHUNK_SIZE = 499;
                const MAX_BLOCKS_BACK = 3000; // ~30 min on Etherlink
                const fromBlock = Math.max(0, currentBlock - MAX_BLOCKS_BACK);
                
                console.log('[MY SWAPS] Searching blocks', fromBlock, 'to', currentBlock);
                
                // Query in chunks to avoid RPC limits
                const filter = state.contract.filters.SwapInitiated();
                let allEvents = [];
                
                for (let start = fromBlock; start < currentBlock; start += CHUNK_SIZE) {
                    const end = Math.min(start + CHUNK_SIZE - 1, currentBlock);
                    try {
                        const events = await state.contract.queryFilter(filter, start, end);
                        allEvents = allEvents.concat(events);
                        console.log(`[MY SWAPS] Scanned blocks ${start}-${end}: ${events.length} events`);
                    } catch (e) {
                        console.warn(`[MY SWAPS] Chunk ${start}-${end} failed:`, e.message);
                    }
                }
                
                console.log('[MY SWAPS] Total events found:', allEvents.length);
                
                // Debug: show all events
                if (allEvents.length > 0) {
                    console.log('[MY SWAPS] All events:');
                    allEvents.forEach((e, i) => {
                        console.log(`  Event ${i}: sender=${e.args.sender}, recipient=${e.args.recipient}, swapId=${e.args.swapId}`);
                    });
                }
                
                // Filter events where user is sender OR recipient
                const userAddress = state.etherlinkAddress.toLowerCase();
                console.log('[MY SWAPS] Looking for user address:', userAddress);
                
                const userEvents = allEvents.filter(e => {
                    const senderMatch = e.args.sender.toLowerCase() === userAddress;
                    const recipientMatch = e.args.recipient.toLowerCase() === userAddress;
                    return senderMatch || recipientMatch;
                });
                
                console.log('[MY SWAPS] User events:', userEvents.length);
                
                // Get unique swap IDs
                const uniqueSwapIds = [...new Set(userEvents.map(e => e.args.swapId))];
                
                // Also fetch SwapRefunded and SwapClaimed events to get tx hashes
                const refundFilter = state.contract.filters.SwapRefunded();
                const claimFilter = state.contract.filters.SwapClaimed();
                let refundEvents = [];
                let claimEvents = [];
                
                for (let start = fromBlock; start < currentBlock; start += CHUNK_SIZE) {
                    const end = Math.min(start + CHUNK_SIZE - 1, currentBlock);
                    try {
                        const refunds = await state.contract.queryFilter(refundFilter, start, end);
                        const claims = await state.contract.queryFilter(claimFilter, start, end);
                        refundEvents = refundEvents.concat(refunds);
                        claimEvents = claimEvents.concat(claims);
                    } catch (e) {
                        // Silently continue
                    }
                }
                
                // Create lookup maps for tx hashes
                const refundTxMap = {};
                refundEvents.forEach(e => {
                    refundTxMap[e.args.swapId] = e.transactionHash;
                });
                
                const claimTxMap = {};
                claimEvents.forEach(e => {
                    claimTxMap[e.args.swapId] = e.transactionHash;
                });
                
                console.log('[MY SWAPS] Found swap IDs:', uniqueSwapIds);
                
                // Get current details for each swap
                state.mySwaps = [];
                for (const swapId of uniqueSwapIds) {
                    try {
                        const [recipient, sender, amount, expiration, hashLock, status] = await state.contract.getSwap(swapId);
                        
                        // Only include if not zero address (swap exists)
                        if (sender !== ethers.constants.AddressZero) {
                            state.mySwaps.push({
                                swapId,
                                recipient,
                                sender,
                                amount: ethers.utils.formatEther(amount),
                                expiration: expiration.toNumber(),
                                hashLock,
                                status,
                                isInitiator: sender.toLowerCase() === state.etherlinkAddress.toLowerCase(),
                                refundTxHash: refundTxMap[swapId] || null,
                                claimTxHash: claimTxMap[swapId] || null
                            });
                        }
                    } catch (e) {
                        console.warn('[MY SWAPS] Error fetching swap:', swapId, e);
                    }
                }
                
                // Sort by expiration (closest first)
                state.mySwaps.sort((a, b) => a.expiration - b.expiration);
                
                loadingEl.classList.add('hidden');
                
                if (state.mySwaps.length === 0) {
                    emptyEl.classList.remove('hidden');
                    log(`No swaps found for ${state.etherlinkAddress.substring(0, 10)}...`, 'info');
                } else {
                    emptyEl.classList.add('hidden');
                    renderSwapsList();
                    startSwapTimers();
                    log(`Found ${state.mySwaps.length} swap(s)`, 'success');
                }
                
            } catch (error) {
                console.error('[MY SWAPS] Error:', error);
                loadingEl.classList.add('hidden');
                emptyEl.classList.remove('hidden');
                log(`Error loading swaps: ${error.message}`, 'error');
            }
        }
        
        // Render all swaps in the list
        function renderSwapsList() {
            const listEl = document.getElementById('swaps-list');
            listEl.innerHTML = state.mySwaps.map(swap => renderSwapCard(swap)).join('');
        }
        
        // Render a single swap card
        function renderSwapCard(swap) {
            const statusInfo = SWAP_STATUS[swap.status] || SWAP_STATUS[0];
            const now = Math.floor(Date.now() / 1000);
            const isExpired = now >= swap.expiration;
            const timeRemaining = swap.expiration - now;
            const role = swap.isInitiator ? 'Initiator (Alice)' : 'Participant (Bob)';
            const roleColor = swap.isInitiator ? 'text-ether-green' : 'text-jstz-accent';
            
            // Get explorer URL
            const networkConfig = NETWORK_CONFIG[state.currentChainId];
            const explorerUrl = networkConfig?.explorer || '';
            
            // Determine tx hash to show (refund or claim)
            const txHash = swap.refundTxHash || swap.claimTxHash;
            const txType = swap.refundTxHash ? 'Refund' : (swap.claimTxHash ? 'Claim' : null);
            
            return `
                <div class="bg-gradient-to-r from-white/5 to-transparent rounded-xl p-4 border border-white/10 hover:border-white/20 transition-all">
                    <div class="flex items-start justify-between mb-3">
                        <div class="flex items-center gap-2">
                            <span class="px-2 py-1 rounded-md text-xs font-bold ${statusInfo.color} ${statusInfo.bg}">
                                <i class="fa-solid ${statusInfo.icon} mr-1"></i>
                                ${statusInfo.label}
                            </span>
                            <span class="text-xs ${roleColor} font-medium">${role}</span>
                        </div>
                        <div class="text-right">
                            <div class="text-lg font-bold text-white">${parseFloat(swap.amount).toFixed(4)} XTZ</div>
                        </div>
                    </div>
                    
                    <div class="space-y-2 text-xs">
                        <div class="flex items-center justify-between">
                            <span class="text-gray-500">Swap ID:</span>
                            <div class="flex items-center gap-2">
                                <code class="text-gray-300 font-mono">${swap.swapId.substring(0, 12)}...${swap.swapId.slice(-8)}</code>
                                <button onclick="copySwapId('${swap.swapId}')" class="text-gray-500 hover:text-white transition" title="Copy Swap ID">
                                    <i class="fa-regular fa-copy"></i>
                                </button>
                                ${explorerUrl ? `
                                <a href="${explorerUrl}/address/${CONFIG.etherlink.contractAddress}" target="_blank" class="text-gray-500 hover:text-ether-green transition" title="View on Explorer">
                                    <i class="fa-solid fa-external-link"></i>
                                </a>
                                ` : ''}
                            </div>
                        </div>
                        
                        <div class="flex items-center justify-between">
                            <span class="text-gray-500">Counterparty:</span>
                            <code class="text-gray-300 font-mono">${swap.isInitiator ? swap.recipient.substring(0, 8) : swap.sender.substring(0, 8)}...</code>
                        </div>
                        
                        <div class="flex items-center justify-between">
                            <span class="text-gray-500">Timelock:</span>
                            <span id="timer-${swap.swapId.substring(0, 10)}" class="${isExpired ? 'text-red-400' : 'text-yellow-400'} font-mono">
                                ${formatTimeRemaining(timeRemaining)}
                            </span>
                        </div>
                        
                        ${txHash && explorerUrl ? `
                        <div class="flex items-center justify-between mt-2 pt-2 border-t border-white/5">
                            <span class="text-gray-500">${txType} TX:</span>
                            <a href="${explorerUrl}/tx/${txHash}" target="_blank" class="flex items-center gap-1 text-ether-green hover:underline">
                                <code class="font-mono">${txHash.substring(0, 8)}...${txHash.slice(-6)}</code>
                                <i class="fa-solid fa-external-link text-[10px]"></i>
                            </a>
                        </div>
                        ` : ''}
                    </div>
                    
                    ${swap.status === 0 ? `
                    <div class="mt-3 pt-3 border-t border-white/10 flex gap-2">
                        ${isExpired && swap.isInitiator ? `
                        <button onclick="quickRefund('${swap.swapId}')" class="flex-1 py-2 rounded-lg text-xs font-semibold bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white transition">
                            <i class="fa-solid fa-rotate-left mr-1"></i>
                            Refund Now
                        </button>
                        ` : `
                        <button onclick="useSwapInRedeem('${swap.swapId}')" class="flex-1 py-2 rounded-lg text-xs font-semibold bg-white/5 hover:bg-white/10 text-gray-300 hover:text-white transition">
                            <i class="fa-solid fa-arrow-right-to-bracket mr-1"></i>
                            ${swap.isInitiator ? 'View Details' : 'Claim'}
                        </button>
                        `}
                    </div>
                    ` : ''}
                </div>
            `;
        }
        
        // Format time remaining
        function formatTimeRemaining(seconds) {
            if (seconds <= 0) return 'EXPIRED';
            
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${mins}m`;
            if (mins > 0) return `${mins}m ${secs}s`;
            return `${secs}s`;
        }
        
        // Start timers to update countdown
        function startSwapTimers() {
            // Clear existing interval
            if (swapTimerInterval) {
                clearInterval(swapTimerInterval);
            }
            
            // Update every second
            swapTimerInterval = setInterval(() => {
                const now = Math.floor(Date.now() / 1000);
                state.mySwaps.forEach(swap => {
                    const timerEl = document.getElementById(`timer-${swap.swapId.substring(0, 10)}`);
                    if (timerEl) {
                        const remaining = swap.expiration - now;
                        timerEl.textContent = formatTimeRemaining(remaining);
                        timerEl.className = remaining <= 0 ? 'text-red-400 font-mono' : 
                                           remaining < 300 ? 'text-orange-400 font-mono animate-pulse' : 
                                           'text-yellow-400 font-mono';
                    }
                });
            }, 1000);
        }
        
        // Copy swap ID to clipboard
        function copySwapId(swapId) {
            navigator.clipboard.writeText(swapId);
            log(`Copied Swap ID: ${swapId.substring(0, 18)}...`, 'success');
        }
        
        // Use swap in Redeem tab
        function useSwapInRedeem(swapId) {
            const swap = state.mySwaps.find(s => s.swapId === swapId);
            if (swap) {
                document.getElementById('swap-id-input').value = swapId;
                
                // If user is initiator and has the secret stored, pre-fill it
                if (swap.isInitiator && state.secret && state.hash === swapId) {
                    document.getElementById('secret-input-claim').value = state.secret;
                }
                
                setTab('redeem');
                log(`Loaded swap ${swapId.substring(0, 12)}... into Redeem tab`, 'info');
            }
        }
        
        // Quick refund directly from My Swaps
        async function quickRefund(swapId) {
            if (!state.contract || !state.signer) {
                log('Connect wallet first!', 'error');
                return;
            }
            
            const swap = state.mySwaps.find(s => s.swapId === swapId);
            if (!swap) {
                log('Swap not found', 'error');
                return;
            }
            
            // Use custom modal instead of confirm()
            const modalText = document.getElementById('confirm-modal-text');
            const modalBtn = document.getElementById('confirm-modal-btn');
            
            modalText.innerText = `Refund ${swap.amount} XTZ from swap ${swapId.substring(0, 8)}...?`;
            
            // Set up confirm action
            modalBtn.onclick = async () => {
                closeConfirmModal();
                await performRefund(swapId, swap.amount);
            };
            
            openConfirmModal();
        }
        
        async function performRefund(swapId, amount) {
            try {
                log(`Refunding swap ${swapId.substring(0, 12)}...`, 'info');
                
                const tx = await state.contract.refundSwap(swapId);
                logTx(tx.hash, 'ðŸ“¤ Transaction sent');
                
                const receipt = await tx.wait();
                log(`âœ… Refund successful!`, 'success');
                logTx(tx.hash, 'âœ… Refund confirmed');
                log(`${amount} XTZ returned to your wallet`, 'success');
                
                // Show success modal with link
                const networkConfig = NETWORK_CONFIG[state.currentChainId];
                if (networkConfig?.explorer) {
                    const txUrl = `${networkConfig.explorer}/tx/${tx.hash}`;
                    showSuccessNotification(amount, tx.hash, txUrl);
                }
                
                // Reload swaps to update the list
                setTimeout(() => loadMySwaps(), 2000);
                
            } catch (error) {
                console.error('Refund error:', error);
                if (error.message.includes('NotYetExpired')) {
                    log('âŒ Swap has not expired yet', 'error');
                } else if (error.message.includes('OnlySender')) {
                    log('âŒ Only the original sender can refund', 'error');
                } else if (error.message.includes('SwapNotActive')) {
                    log('âŒ Swap is no longer active (already claimed or refunded)', 'error');
                } else {
                    log(`âŒ Refund failed: ${error.message}`, 'error');
                }
            }
        }
        
        // Success notification with tx link
        function showSuccessNotification(amount, txHash, txUrl) {
            const modal = document.getElementById('confirm-modal');
            const content = document.getElementById('confirm-modal-content');
            const text = document.getElementById('confirm-modal-text');
            const btn = document.getElementById('confirm-modal-btn');
            
            // Update modal for success state
            content.innerHTML = `
                <div class="text-center mb-6">
                    <div class="w-16 h-16 bg-green-500/20 rounded-full flex items-center justify-center mx-auto mb-4">
                        <i class="fa-solid fa-check text-3xl text-green-400"></i>
                    </div>
                    <h3 class="text-xl font-bold text-white mb-2">Refund Successful!</h3>
                    <p class="text-gray-400 text-sm mb-4">${amount} XTZ has been returned to your wallet</p>
                    <div class="bg-black/30 rounded-lg p-3 text-xs">
                        <p class="text-gray-500 mb-1">Transaction Hash:</p>
                        <code class="text-ether-green font-mono">${txHash.substring(0, 20)}...${txHash.slice(-8)}</code>
                    </div>
                </div>
                
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="closeConfirmModal(); resetConfirmModal();" class="py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 text-gray-300 font-semibold transition-all">
                        Close
                    </button>
                    <a href="${txUrl}" target="_blank" class="py-3 px-4 rounded-xl bg-gradient-to-r from-ether-green to-emerald-500 text-black font-bold text-center transition-all hover:opacity-90">
                        <i class="fa-solid fa-external-link mr-1"></i>
                        View TX
                    </a>
                </div>
            `;
            
            openConfirmModal();
        }
        
        // Reset modal to default state
        function resetConfirmModal() {
            const content = document.getElementById('confirm-modal-content');
            content.innerHTML = `
                <div class="text-center mb-6">
                    <div class="w-16 h-16 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-4">
                        <i class="fa-solid fa-rotate-left text-2xl text-red-500"></i>
                    </div>
                    <h3 class="text-xl font-bold text-white mb-2">Confirm Refund</h3>
                    <p class="text-gray-400 text-sm" id="confirm-modal-text">Are you sure you want to refund this swap?</p>
                </div>
                
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="closeConfirmModal()" class="py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 text-gray-300 font-semibold transition-all">
                        Cancel
                    </button>
                    <button id="confirm-modal-btn" class="py-3 px-4 rounded-xl bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-bold shadow-lg shadow-red-500/20 transition-all">
                        Confirm Refund
                    </button>
                </div>
            `;
        }
        
        // Modal Helpers
        function openConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            const content = document.getElementById('confirm-modal-content');
            modal.classList.remove('hidden');
            // Small delay for transition
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                content.classList.remove('scale-95');
                content.classList.add('scale-100');
            }, 10);
        }
        
        function closeConfirmModal() {
            const modal = document.getElementById('confirm-modal');
            const content = document.getElementById('confirm-modal-content');
            modal.classList.add('opacity-0');
            content.classList.remove('scale-100');
            content.classList.add('scale-95');
            
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        // Unified claim function
        async function claimSwap() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            const secret = document.getElementById('secret-input-claim')?.value || state.secret;
            
            if (!swapId) {
                log('Please enter a Swap ID / HashLock', 'error');
                return;
            }
            
            if (!secret) {
                log('Please enter the secret to claim', 'error');
                return;
            }
            
            // Store for use in claim functions
            state.currentSwapId = swapId;
            state.secret = secret;
            
            // Determine which chain to claim on based on CONNECTED WALLET
            if (state.connectedWallet === 'etherlink') {
                // Connected to Etherlink (MetaMask) â†’ Claim on Etherlink
                log('ðŸ“ Connected to Etherlink - claiming on Etherlink...', 'warning');
                await claimOnEtherlink();
            } else if (state.connectedWallet === 'jstz') {
                // Connected to Jstz â†’ Claim on Jstz
                log('ðŸ“ Connected to Jstz - claiming on Jstz...', 'warning');
                await claimOnJstz();
            } else {
                log('âŒ Please connect a wallet first (Etherlink or Jstz)', 'error');
                return;
            }
        }
        
        // Unified refund function
        async function refundSwap() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            if (!swapId) {
                log('Please enter a Swap ID / HashLock', 'error');
                return;
            }
            
            state.currentSwapId = swapId;
            
            // Determine which chain to refund on based on CONNECTED WALLET
            if (state.connectedWallet === 'etherlink') {
                log('ðŸ“ Connected to Etherlink - refunding on Etherlink...', 'warning');
                await refundOnEtherlink();
            } else if (state.connectedWallet === 'jstz') {
                log('ðŸ“ Connected to Jstz - refunding on Jstz...', 'warning');
                await refundOnJstz();
            } else {
                log('âŒ Please connect a wallet first (Etherlink or Jstz)', 'error');
                return;
            }
        }
        
        // Refund on Etherlink (after timelock expires)
        async function refundOnEtherlink() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate swap ID
            if (!swapId || !isValidHashLock(swapId)) {
                log('âŒ Invalid or missing Swap ID', 'error');
                return;
            }
            state.currentSwapId = swapId;
            
            if (!state.contract) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }
            
            if (!state.contract) {
                log('âŒ HTLC contract not available', 'error');
                return;
            }
            
            const btn = document.getElementById('refund-btn');
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
            
            // 2. Verify swap exists on Etherlink and is ACTIVE
            log('Verifying swap on Etherlink...', 'warning');
            const verification = await verifySwapOnEtherlink(swapId, SwapState.OPEN);
            
            if (!verification.valid) {
                log(`âŒ ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`âœ“ Swap found: ${swap.amount} XTZ`, 'success');
            
            // 3. Verify caller is the original sender (can only refund your own swap)
            if (swap.sender.toLowerCase() !== state.etherlinkAddress.toLowerCase()) {
                log('âŒ Only the original sender can refund this swap', 'error');
                log(`Sender: ${swap.sender}`, 'info');
                log(`Your address: ${state.etherlinkAddress}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('âœ“ You are the original sender', 'success');
            
            // 4. Check timelock HAS expired (required for refund)
            if (!swap.isExpired) {
                const now = Math.floor(Date.now() / 1000);
                const remaining = swap.expiration - now;
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                log(`âŒ Cannot refund yet - timelock has not expired`, 'error');
                log(`Time remaining: ${mins}m ${secs}s`, 'warning');
                log(`Expires at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('âœ“ Timelock has expired, refund allowed', 'success');
            
            // ========== EXECUTE REFUND ==========
            try {
                log('Executing refund on Etherlink...', 'warning');
                log(`Swap ID: ${swapId.substring(0, 18)}...`, 'info');
                
                const tx = await state.contract.refundSwap(swapId);
                logTx(tx.hash, 'ðŸ“¤ Transaction sent');
                
                const receipt = await tx.wait();
                
                if (receipt.status !== 1) {
                    throw new Error('Transaction failed on-chain');
                }
                
                log('âœ… Refund successful on Etherlink!', 'success');
                logTx(tx.hash, 'âœ… Refund confirmed');
                log(`${swap.amount} XTZ returned to your wallet`, 'success');
                
                // hideClaimRefundSection(); // No longer needed in redeem tab
                updateProgress(1);
                
            } catch (error) {
                let errorMsg = error.message;
                if (error.message.includes('NotYetExpired') || error.message.includes('not yet expired')) {
                    errorMsg = 'Timelock has not expired yet';
                } else if (error.message.includes('OnlySender') || error.message.includes('not sender')) {
                    errorMsg = 'Only the original sender can refund';
                } else if (error.message.includes('SwapNotActive')) {
                    errorMsg = 'Swap is not active (already claimed or refunded)';
                }
                log(`âŒ Refund error: ${errorMsg}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
            }
        }
        
        // Refund on Jstz
        async function refundOnJstz() {
            const hashLock = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate hashlock
            if (!hashLock || !isValidHashLock(hashLock)) {
                log('âŒ Invalid or missing HashLock', 'error');
                return;
            }
            state.currentSwapId = hashLock;
            
            const btn = document.getElementById('refund-btn');
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
            
            // 2. Verify swap exists on Jstz
            log('Verifying swap on Jstz...', 'warning');
            const verification = await verifySwapOnJstz(hashLock);
            
            if (!verification.valid) {
                log(`âŒ ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`âœ“ Swap found: ${swap.amount} XTZ`, 'success');
            
            // 3. Check if already claimed or refunded (Etherlink: OPEN=0, CLAIMED=1, EXPIRED=2)
            if (swap.status === SwapState.CLAIMED || swap.status === 1) {
                log('âŒ Swap has already been claimed!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            if (swap.status === SwapState.EXPIRED || swap.status === 2) {
                log('âŒ Swap has already been refunded!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            // 4. Check timelock HAS expired (required for refund)
            if (!swap.isExpired) {
                const now = Math.floor(Date.now() / 1000);
                const remaining = swap.expiration - now;
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                log(`âŒ Cannot refund yet - timelock has not expired`, 'error');
                log(`Time remaining: ${mins}m ${secs}s`, 'warning');
                log(`Expires at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('âœ“ Timelock has expired, refund allowed', 'success');
            
            // ========== EXECUTE REFUND ==========
            log('Executing refund on Jstz...', 'warning');
            
            try {
                const response = await jstzRequest('POST', '/refund', {
                    hashlock: hashLock
                });
                
                // Handle CLI fallback
                if (response && response.cliRequired) {
                    log(`âš ï¸ Complete the refund using the CLI command in the popup`, 'warning');
                    return;
                }
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                log('âœ… Refund successful on Jstz!', 'success');
                log(`${swap.amount} XTZ returned to your wallet`, 'success');
                // hideClaimRefundSection(); // No longer needed
                updateProgress(1);
                
            } catch (error) {
                log(`âŒ Refund error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
            }
        }

        // Bob claims on Etherlink (uses revealed secret)
        async function claimOnEtherlink() {
            const btn = document.getElementById('main-action-btn');
            const swapId = state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate swap ID
            if (!swapId || !isValidHashLock(swapId)) {
                log('âŒ Invalid or missing Swap ID', 'error');
                return;
            }
            
            // 2. Get secret (prompt if not available)
            let secret = state.secret;
            if (!secret) {
                secret = document.getElementById('secret-input-claim')?.value;
            }
            if (!secret) {
                secret = prompt("Enter the revealed secret (0x...):");
                if (!secret) {
                    log("âŒ Secret is required to claim", 'error');
                    return;
                }
            }
            state.secret = secret;
            
            // 3. Verify secret format
            if (!isValidHashLock(secret)) {
                log('âŒ Invalid secret format (must be 0x + 64 hex chars)', 'error');
                return;
            }
            
            // 4. Verify secret matches the hashlock
            if (!verifySecretMatchesHash(secret, swapId)) {
                log('âŒ Secret does not match Swap ID (HashLock)!', 'error');
                log('Make sure you have the correct secret from Alice', 'error');
                return;
            }
            log('âœ“ Secret matches HashLock', 'success');

            if (!state.contract) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }
            
            if (!state.contract) {
                log('âŒ HTLC contract not available', 'error');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying swap on Etherlink...`;
            
            // 5. Verify swap exists on Etherlink and is ACTIVE
            log('Verifying swap exists on Etherlink...', 'warning');
            const verification = await verifySwapOnEtherlink(swapId, SwapState.OPEN);
            
            if (!verification.valid) {
                log(`âŒ ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`âœ“ Swap found: ${swap.amount} XTZ locked by ${swap.sender.substring(0,10)}...`, 'success');
            
            // 6. Check timelock hasn't expired
            if (swap.isExpired) {
                log('âŒ Swap has expired! Cannot claim after timelock.', 'error');
                log(`Expired at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
                return;
            }
            log(`âœ“ Timelock valid until: ${swap.expirationDate}`, 'success');
            
            // ========== EXECUTE CLAIM ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Claiming on Etherlink...`;

            try {
                log(`Claiming on Etherlink with secret...`, 'warning');
                
                // Convert secret to bytes
                const secretBytes = ethers.utils.arrayify(secret);
                
                const tx = await state.contract.claimSwap(swapId, secretBytes);

                logTx(tx.hash, 'ðŸ“¤ Transaction sent');
                
                const receipt = await tx.wait();
                
                // Verify transaction was successful
                if (receipt.status !== 1) {
                    throw new Error('Transaction failed on-chain');
                }
                
                log(`âœ… Claimed on Etherlink!`, 'success');
                logTx(tx.hash, 'âœ… Claim confirmed');
                log(`Bob has received ${swap.amount} XTZ!`, 'success');
                
                updateProgress(4);
                
                btn.innerHTML = `<i class="fa-solid fa-check-circle"></i> Swap Complete`;
                btn.classList.add('bg-green-500');
                btn.disabled = true;

            } catch (error) {
                // Parse contract revert reasons
                let errorMsg = error.message;
                if (error.message.includes('SwapNotActive')) {
                    errorMsg = 'Swap is not active (already claimed or refunded)';
                } else if (error.message.includes('InvalidHashLock')) {
                    errorMsg = 'Invalid secret - does not match hashlock';
                } else if (error.message.includes('SwapExpired')) {
                    errorMsg = 'Swap has expired';
                }
                log(`âŒ Error: ${errorMsg}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
            }
        }

        // Main action dispatcher
        async function executeAction() {
            if (state.mode === 'create') {
                // ALICE INITIATES - creates new swap with her secret
                if (state.connectedWallet === 'etherlink') {
                    // Alice locks on Etherlink, Bob will match on Jstz
                    await initiateAsAliceOnEtherlink();
                } else if (state.connectedWallet === 'jstz') {
                    // Alice locks on Jstz, Bob will match on Etherlink
                    await initiateAsAliceOnJstz();
                } else {
                    log('âŒ Please connect a wallet first', 'error');
                }
            } else {
                // BOB JOINS - matches existing swap with Alice's hash
                if (state.connectedWallet === 'jstz') {
                    // Alice locked on Etherlink, Bob matches on Jstz
                    await matchAsBobOnJstz();
                } else if (state.connectedWallet === 'etherlink') {
                    // Alice locked on Jstz, Bob matches on Etherlink
                    await matchAsBobOnEtherlink();
                } else {
                    log('âŒ Please connect a wallet first', 'error');
                }
            }
        }
        
        // Alias for backwards compatibility
        async function initiateOnEtherlink() {
            await initiateAsAliceOnEtherlink();
        }
        
        async function initiateOnJstz() {
            await matchAsBobOnJstz();
        }

        // Legacy functions for compatibility
        async function revealSecret() {
            await claimOnJstz();
        }

        async function claimWithSecret() {
            await claimOnEtherlink();
        }

        function copyToClipboard(id) {
            const el = document.getElementById(id);
            el.select();
            navigator.clipboard.writeText(el.value);
            log(`Copied ${id} to clipboard.`, 'info');
        }

        // Init
        generateNewSecret();
        updateProgress(1);
        renderTokenDropdown(); // Initialize token dropdown
        log("Atomic Swap ready. Connect wallets to begin.", 'system');
        log(`Etherlink Contract: ${CONFIG.etherlink.contractAddress}`, 'info');
        log(`Jstz Function: ${CONFIG.jstz.functionAddress}`, 'info');
        log(`Tokens available: ${Object.keys(TOKENS).join(', ')}`, 'info');
        
        // Close token dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('token-dropdown');
            const assetSelector = e.target.closest('[onclick="toggleTokenSelector()"]');
            if (!assetSelector && !e.target.closest('#token-dropdown')) {
                toggleTokenSelector(false);
            }
        });

        // Wallet Events - Real connections
        document.getElementById('wallet-etherlink').addEventListener('click', async (e) => {
            const btn = e.currentTarget;
            const textEl = document.getElementById('wallet-etherlink-text');
            const balanceEl = document.getElementById('wallet-balance');
            
            // Check if already connected - toggle disconnect
            if (state.etherlinkAddress) {
                state.etherlinkAddress = null;
                state.provider = null;
                state.signer = null;
                state.contract = null;
                textEl.innerText = 'Connect Etherlink';
                balanceEl.classList.add('hidden');
                btn.classList.remove('border-ether-green', 'text-ether-green', 'bg-ether-green/10');
                updateWalletConnectionUI(null);
                updateNetworkBadge(null, 'Not Connected');
                log('Etherlink wallet disconnected', 'info');
                return;
            }
            
            // Check if other wallet is connected
            if (state.jstzAddress) {
                log('âš ï¸ Disconnect Jstz wallet first', 'warning');
                return;
            }
            
            textEl.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin mr-1"></i> Connecting...`;
            
            const connected = await connectEtherlink();
            
            if (connected) {
                const shortAddr = `${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`;
                textEl.innerText = shortAddr;
                btn.classList.add('border-ether-green', 'text-ether-green', 'bg-ether-green/10');
                
                // Fetch and display balances
                await fetchAllBalances();
                
                // Show balance next to address
                if (state.tokenBalances['XTZ']) {
                    const xtzBalance = parseFloat(state.tokenBalances['XTZ']).toFixed(2);
                    balanceEl.innerText = `${xtzBalance} XTZ`;
                    balanceEl.classList.remove('hidden');
                }
                
                // Update token dropdown with balances
                renderTokenDropdown();
            } else {
                textEl.innerText = 'Connect Etherlink';
            }
        });

        document.getElementById('wallet-jstz').addEventListener('click', async (e) => {
            const btn = e.currentTarget;
            const textEl = document.getElementById('wallet-jstz-text');
            
            // Check if already connected
            if (state.jstzAddress) {
                // Disconnect
                state.jstzAddress = null;
                textEl.innerText = 'Connect Jstz';
                btn.classList.remove('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                updateWalletConnectionUI(null);
                log('Jstz wallet disconnected', 'info');
                return;
            }
            
            // Check if other wallet is connected
            if (state.etherlinkAddress) {
                log('âš ï¸ Disconnect Etherlink wallet first', 'warning');
                return;
            }
            
            // Jstz connection - try extension first, fallback to simulated
            try {
                if (isJstzExtensionInstalled()) {
                    log('ðŸ” Connecting to Jstz wallet extension...', 'warning');
                    
                    const addressData = await getJstzAddress();
                    console.log('[JSTZ] Address response:', addressData);
                    
                    // Handle different response formats
                    if (typeof addressData === 'string') {
                        state.jstzAddress = addressData;
                    } else if (addressData && typeof addressData === 'object') {
                        state.jstzAddress = addressData.address || addressData.accountAddress || addressData.data?.address || JSON.stringify(addressData);
                    } else {
                        throw new Error('Invalid address response from wallet');
                    }
                    
                    // Safely create short address
                    const addr = String(state.jstzAddress);
                    const shortAddr = addr.length > 10 ? `${addr.substring(0, 6)}...${addr.slice(-3)}` : addr;
                    textEl.innerText = shortAddr;
                    btn.classList.add('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                    
                    updateWalletConnectionUI('jstz');
                    
                    log(`âœ… Jstz wallet connected: ${state.jstzAddress}`, 'success');
                    log('Transactions will be signed by your wallet extension', 'system');
                } else {
                    // No extension - use simulated mode
                    state.jstzAddress = 'tz1gyq6Er4ntjHFaXsVbUKnSEqvEiez4HFTP';
                    textEl.innerText = 'tz1...FTP (demo)';
                    btn.classList.add('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                    
                    updateWalletConnectionUI('jstz');
                    
                    log(`âš ï¸ Jstz wallet extension not found`, 'warning');
                    log(`Using demo mode - CLI commands will be shown`, 'system');
                    log(`Install wallet: <a href="https://github.com/jstz-dev/dev-wallet/releases" target="_blank" class="text-ether-green hover:underline">github.com/jstz-dev/dev-wallet</a>`, 'info');
                }
            } catch (error) {
                console.error('[JSTZ] Connection error:', error);
                log(`âŒ Jstz connection error: ${error.message}`, 'error');
                
                // Fallback to demo mode
                state.jstzAddress = 'tz1gyq6Er4ntjHFaXsVbUKnSEqvEiez4HFTP';
                textEl.innerText = 'tz1...FTP (demo)';
                btn.classList.add('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
                updateWalletConnectionUI('jstz');
                log('Falling back to demo mode', 'system');
            }
        });

        // Listen for MetaMask network/account changes
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('chainChanged', async (chainId) => {
                const newChainId = parseInt(chainId, 16);
                console.log('[DEBUG] Network changed to chainId:', newChainId);
                log(`Network changed! Reconnecting...`, 'warning');
                
                // Reconnect with new network
                await connectEtherlink();
                await fetchAllBalances();
                renderTokenDropdown();
            });
            
            window.ethereum.on('accountsChanged', async (accounts) => {
                console.log('[DEBUG] Account changed to:', accounts[0]);
                if (accounts.length > 0) {
                    log(`Account changed! Reconnecting...`, 'warning');
                    await connectEtherlink();
                    await fetchAllBalances();
                    
                    // Update wallet button
                    const textEl = document.getElementById('wallet-etherlink-text');
                    if (textEl) {
                        const shortAddr = `${accounts[0].substring(0, 6)}...${accounts[0].slice(-4)}`;
                        textEl.innerText = shortAddr;
                    }
                } else {
                    log(`Wallet disconnected`, 'warning');
                    updateNetworkBadge(0, 'Not Connected');
                }
            });
            
            console.log('[DEBUG] MetaMask event listeners attached');
        }

    </script>
    <!-- Notification Modal -->
    <div id="confirm-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center opacity-0 transition-opacity duration-300">
        <div class="bg-[#111111] border border-white/10 rounded-2xl p-6 max-w-sm w-full mx-4 shadow-2xl transform scale-95 transition-transform duration-300" id="confirm-modal-content">
            <div class="text-center mb-6">
                <div class="w-16 h-16 bg-red-500/10 rounded-full flex items-center justify-center mx-auto mb-4">
                    <i class="fa-solid fa-rotate-left text-2xl text-red-500"></i>
                </div>
                <h3 class="text-xl font-bold text-white mb-2">Confirm Refund</h3>
                <p class="text-gray-400 text-sm" id="confirm-modal-text">Are you sure you want to refund this swap?</p>
            </div>
            
            <div class="grid grid-cols-2 gap-3">
                <button onclick="closeConfirmModal()" class="py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 text-gray-300 font-semibold transition-all">
                    Cancel
                </button>
                <button id="confirm-modal-btn" class="py-3 px-4 rounded-xl bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-bold shadow-lg shadow-red-500/20 transition-all">
                    Confirm Refund
                </button>
            </div>
        </div>
    </div>
    
    <!-- CLI Command Modal -->
    <div id="cli-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center">
        <div class="bg-[#0a0a0a] border border-jstz-accent/30 rounded-2xl p-6 max-w-2xl w-full mx-4 shadow-2xl shadow-jstz-accent/10">
            <div class="flex items-center justify-between mb-4">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-jstz-accent/10 rounded-full flex items-center justify-center">
                        <i class="fa-solid fa-terminal text-jstz-accent"></i>
                    </div>
                    <div>
                        <h3 class="text-lg font-bold text-white">Jstz CLI Command</h3>
                        <p class="text-xs text-gray-400">Wallet extension unavailable - use CLI instead</p>
                    </div>
                </div>
                <button onclick="closeCLIModal()" class="text-gray-400 hover:text-white transition-colors">
                    <i class="fa-solid fa-xmark text-xl"></i>
                </button>
            </div>
            
            <div class="mb-4">
                <p class="text-sm text-gray-300 mb-3" id="cli-modal-description">
                    The Jstz wallet extension is not responding. Run this command in your terminal:
                </p>
                
                <div class="relative">
                    <pre id="cli-modal-command" class="bg-black border border-white/10 rounded-xl p-4 text-sm text-green-400 font-mono overflow-x-auto whitespace-pre-wrap break-all"></pre>
                    <button onclick="copyCLICommand()" class="absolute top-2 right-2 px-3 py-1 bg-jstz-accent/20 hover:bg-jstz-accent/30 text-jstz-accent rounded-lg text-xs font-semibold transition-colors flex items-center gap-1">
                        <i class="fa-regular fa-copy"></i>
                        <span id="copy-cli-btn-text">Copy</span>
                    </button>
                </div>
            </div>
            
            <div class="bg-yellow-500/10 border border-yellow-500/20 rounded-xl p-3 mb-4">
                <div class="flex items-start gap-2">
                    <i class="fa-solid fa-circle-info text-yellow-500 mt-0.5"></i>
                    <div class="text-xs text-yellow-200">
                        <strong>Instructions:</strong>
                        <ol class="list-decimal list-inside mt-1 space-y-1 text-yellow-200/80">
                            <li>Copy the command above</li>
                            <li>Open a terminal</li>
                            <li>Paste and run the command</li>
                            <li>Check the output for success/error</li>
                        </ol>
                    </div>
                </div>
            </div>
            
            <div class="bg-blue-500/10 border border-blue-500/20 rounded-xl p-3 mb-4">
                <div class="flex items-start gap-2">
                    <i class="fa-solid fa-download text-blue-400 mt-0.5"></i>
                    <div class="text-xs text-blue-200">
                        <strong>Don't have Jstz CLI installed?</strong>
                        <p class="mt-1 text-blue-200/80">
                            Install it with: <code class="bg-blue-500/20 px-1 rounded">npm i -g @jstz-dev/cli</code>
                        </p>
                        <a href="https://jstz.tezos.com/installation" target="_blank" class="inline-flex items-center gap-1 mt-2 text-blue-400 hover:text-blue-300 underline">
                            <i class="fa-solid fa-external-link text-[10px]"></i>
                            View full installation guide
                        </a>
                    </div>
                </div>
            </div>
            
            <div class="flex gap-3">
                <button onclick="closeCLIModal()" class="flex-1 py-3 px-4 rounded-xl bg-white/5 hover:bg-white/10 text-gray-300 font-semibold transition-all">
                    Close
                </button>
                <button onclick="copyCLICommand()" class="flex-1 py-3 px-4 rounded-xl bg-gradient-to-r from-jstz-accent to-yellow-400 hover:brightness-110 text-black font-bold shadow-lg transition-all flex items-center justify-center gap-2">
                    <i class="fa-regular fa-copy"></i>
                    Copy Command
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // CLI Modal functions
        function showCLIModal(command, description = null) {
            const modal = document.getElementById('cli-modal');
            const commandEl = document.getElementById('cli-modal-command');
            const descEl = document.getElementById('cli-modal-description');
            
            commandEl.textContent = command;
            if (description) {
                descEl.textContent = description;
            }
            
            modal.classList.remove('hidden');
            modal.style.opacity = '0';
            setTimeout(() => modal.style.opacity = '1', 10);
        }
        
        function closeCLIModal() {
            const modal = document.getElementById('cli-modal');
            modal.style.opacity = '0';
            setTimeout(() => modal.classList.add('hidden'), 300);
        }
        
        function copyCLICommand() {
            const commandEl = document.getElementById('cli-modal-command');
            const btnText = document.getElementById('copy-cli-btn-text');
            
            navigator.clipboard.writeText(commandEl.textContent).then(() => {
                btnText.textContent = 'Copied!';
                setTimeout(() => btnText.textContent = 'Copy', 2000);
            });
        }
    </script>
</body>
</html>

