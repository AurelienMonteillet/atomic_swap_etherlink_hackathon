<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Etherlink x Jstz | Atomic Swap</title>
    
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        ether: {
                            green: '#80F89B', // Etherlink Brand Green (approx)
                            dark: '#020202',
                            card: '#111111',
                            border: '#222222',
                            text: '#e2e8f0'
                        },
                        jstz: {
                            accent: '#FFD700' // Gold/Yellow for Jstz
                        }
                    },
                    fontFamily: {
                        sans: ['"Plus Jakarta Sans"', 'Inter', 'sans-serif'],
                        mono: ['"JetBrains Mono"', 'monospace'],
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 6s ease-in-out infinite',
                    },
                    keyframes: {
                        float: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' },
                        }
                    }
                }
            }
        }
    </script>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <style>
        body {
            background-color: #020202;
            /* Etherlink-style diagonal glow */
            background-image: 
                radial-gradient(circle at 20% 0%, rgba(128, 248, 155, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 100%, rgba(128, 248, 155, 0.05) 0%, transparent 50%);
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #80F89B; }

        .glass-card {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
        }

        .neon-text {
            text-shadow: 0 0 20px rgba(128, 248, 155, 0.4);
        }
        
        .input-field {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        .input-field:focus {
            border-color: #80F89B;
            box-shadow: 0 0 15px rgba(128, 248, 155, 0.1);
        }

        .btn-primary {
            background: #80F89B;
            color: #000;
            font-weight: 600;
            letter-spacing: -0.02em;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .btn-primary::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transition: 0.5s;
        }
        .btn-primary:hover::after {
            left: 100%;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(128, 248, 155, 0.3);
            background: #6ee786;
        }

        .step-line-bg {
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 0;
            transform: translateY(-50%);
        }
        .step-progress {
            position: absolute;
            top: 50%;
            left: 0;
            height: 1px;
            background: #80F89B;
            box-shadow: 0 0 10px rgba(128, 248, 155, 0.5);
            z-index: 0;
            transform: translateY(-50%);
            width: 0%;
            transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .step-dot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            z-index: 1;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: #111;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #666;
        }
        
        .step-dot.active {
            background: #80F89B;
            color: #000;
            border-color: #80F89B;
            box-shadow: 0 0 20px rgba(128, 248, 155, 0.3);
            transform: scale(1.1);
        }

        .step-dot.completed {
            background: #000;
            color: #80F89B;
            border-color: #80F89B;
        }

        .step-label {
            position: absolute;
            top: 45px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.02em;
            color: #666;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        .step-dot.active + .step-label {
            color: #80F89B;
            text-shadow: 0 0 10px rgba(128, 248, 155, 0.3);
        }
        .step-dot.completed + .step-label {
            color: #e2e8f0;
        }

        /* Secret Blur */
        .secret-blur {
            filter: blur(8px);
            cursor: pointer;
            transition: filter 0.3s;
            user-select: none;
        }
        .secret-blur:hover, .secret-blur.revealed {
            filter: blur(0);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Navigation -->
    <nav class="w-full border-b border-white/5 bg-ether-card/50 backdrop-blur-md fixed top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
        <div class="flex items-center gap-3">
                    <!-- Logo Placeholder -->
                    <div class="w-8 h-8 rounded bg-ether-green flex items-center justify-center text-black font-bold text-lg shadow-[0_0_15px_rgba(128,248,155,0.4)]">
                        <i class="fa-solid fa-arrow-right-arrow-left"></i>
                    </div>
                    <span class="text-xl font-bold tracking-tight text-white">Etherlink <span class="text-gray-500 mx-1">x</span> <span class="text-jstz-accent">Jstz</span></span>
                </div>
                
                <div class="hidden md:flex items-center space-x-4">
                    <div id="network-badge" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-white/10 cursor-pointer hover:border-ether-green/50 transition" onclick="switchToEtherlink(128123)" title="Click to switch to Etherlink Testnet">
                        <div id="network-dot" class="w-2 h-2 rounded-full bg-gray-500"></div>
                        <span id="network-name" class="text-xs text-gray-400">Not Connected</span>
                    </div>
                    <button id="wallet-etherlink" class="flex items-center gap-2 px-4 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 transition text-sm font-medium">
                        <i class="fa-brands fa-ethereum text-ether-green"></i>
                        <span id="wallet-etherlink-text">Connect Etherlink</span>
                        <span id="wallet-balance" class="hidden text-ether-green font-mono text-xs"></span>
                    </button>
                    <button id="wallet-jstz" class="flex items-center gap-2 px-4 py-2 rounded-lg bg-white/5 hover:bg-white/10 border border-white/10 transition text-sm font-medium">
                        <i class="fa-solid fa-bolt text-jstz-accent"></i>
                        <span id="wallet-jstz-text">Connect Jstz</span>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="flex-grow pt-24 pb-12 px-4 flex flex-col items-center justify-center relative overflow-hidden">
        
        <!-- Decorative Elements -->
        <div class="absolute top-1/4 left-10 w-64 h-64 bg-green-500/10 rounded-full blur-3xl animate-pulse-slow"></div>
        <div class="absolute bottom-1/4 right-10 w-96 h-96 bg-yellow-500/5 rounded-full blur-3xl animate-pulse-slow" style="animation-delay: 1.5s;"></div>

        <div class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-12 gap-8 z-10">
            
            <!-- Left Column: Swap Interface -->
            <div class="lg:col-span-7 flex flex-col gap-6">
                
                <!-- Progress Stepper -->
                <div class="glass-card rounded-2xl p-8 relative overflow-hidden">
                    <div class="flex justify-between items-center mb-8">
                        <h3 class="text-xs font-bold text-gray-400 uppercase tracking-[0.2em]">Swap Status</h3>
                        <div class="flex items-center gap-2 text-[10px] text-gray-500">
                            <div class="w-1.5 h-1.5 rounded-full bg-ether-green animate-pulse"></div>
                            LIVE
                        </div>
                    </div>

                    <div class="relative px-4 pb-4">
                        <div class="step-line-bg"></div>
                        <div class="step-progress" id="progress-bar"></div>
                        
                        <div class="flex justify-between items-center relative z-10">
                            <div class="relative group cursor-default" id="step-1">
                                <div class="step-dot">1</div>
                                <span class="step-label">Initiate</span>
                            </div>
                            <div class="relative group cursor-default" id="step-2">
                                <div class="step-dot">2</div>
                                <span class="step-label">Participate</span>
                            </div>
                            <div class="relative group cursor-default" id="step-3">
                                <div class="step-dot">3</div>
                                <span class="step-label">Redeem</span>
                            </div>
                            <div class="relative group cursor-default" id="step-4">
                                <div class="step-dot">4</div>
                                <span class="step-label">Complete</span>
                        </div>
                        </div>
                    </div>
                </div>

                <!-- Main Swap Card -->
                <div class="glass-card rounded-2xl p-1">
                    <!-- Tabs -->
                    <div class="grid grid-cols-3 gap-1 p-1 bg-black/20 rounded-t-xl">
                        <button onclick="setTab('create')" id="tab-create" class="flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-ether-border shadow-lg transition-all">
                            Initiate (Alice)
                        </button>
                        <button onclick="setTab('join')" id="tab-join" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            Join (Bob)
                        </button>
                        <button onclick="setTab('redeem')" id="tab-redeem" class="flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all">
                            Redeem / Refund
                        </button>
                    </div>

                    <div class="p-6 sm:p-8">
                        
                        <!-- INITIATE & JOIN CONTENT -->
                        <div id="initiate-join-content" class="space-y-6">
                            <!-- Chain Selection -->
                            <div class="grid grid-cols-2 gap-4 p-1 bg-black/20 rounded-xl">
                            <button onclick="setChain('etherlink')" id="chain-etherlink" class="relative py-3 rounded-lg border border-ether-green bg-ether-green/10 text-white transition-all group overflow-hidden">
                                <div class="flex items-center justify-center gap-2 relative z-10">
                                    <i class="fa-brands fa-ethereum text-ether-green"></i>
                                    <span class="text-sm font-bold">From Etherlink</span>
                                    <i class="fa-solid fa-arrow-right text-gray-500 text-xs"></i>
                                    <i class="fa-solid fa-layer-group text-gray-500 text-xs"></i>
                                </div>
                                <div class="absolute inset-0 bg-ether-green/5 opacity-0 group-hover:opacity-100 transition"></div>
                            </button>
                            <button onclick="setChain('jstz')" id="chain-jstz" class="relative py-3 rounded-lg border border-transparent text-gray-400 hover:text-white hover:bg-white/5 transition-all group">
                                <div class="flex items-center justify-center gap-2 relative z-10">
                                    <i class="fa-solid fa-layer-group text-jstz-accent"></i>
                                    <span class="text-sm font-bold">From Jstz</span>
                                    <i class="fa-solid fa-arrow-right text-gray-500 text-xs"></i>
                                    <i class="fa-brands fa-ethereum text-gray-500 text-xs"></i>
                                </div>
                            </button>
                        </div>

                        <!-- Secret Generator Section -->
                        <div id="secret-section" class="p-5 rounded-xl bg-gradient-to-br from-white/5 to-transparent border border-white/5 relative overflow-hidden group transition-all duration-300">
                            <div class="absolute top-0 right-0 p-3 opacity-50 group-hover:opacity-100 transition">
                                <i class="fa-solid fa-lock text-ether-green"></i>
                            </div>
                            <label class="text-xs font-bold text-ether-green uppercase tracking-widest mb-3 block">
                                <i class="fa-solid fa-key mr-1"></i> Cryptographic Proof
                            </label>
                            
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="proof-inputs">
                                <div id="secret-container">
                                    <span class="text-[10px] text-gray-400 uppercase block mb-1">Secret (Preimage) - <span class="text-red-400">Keep Safe</span></span>
                                    <div class="relative">
                                        <input type="text" id="secret-input" class="w-full input-field rounded-lg p-3 text-sm font-mono text-white secret-blur" readonly value="Generating...">
                                        <button onclick="copyToClipboard('secret-input')" class="absolute right-2 top-2 text-gray-500 hover:text-white"><i class="fa-regular fa-copy"></i></button>
                                    </div>
                                </div>
                                <div id="hash-container">
                                    <span class="text-[10px] text-gray-400 uppercase block mb-1">HashLock (Public)</span>
                                    <div class="relative">
                                        <input type="text" id="hash-input" class="w-full input-field rounded-lg p-3 text-sm font-mono text-gray-300" readonly value="Waiting...">
                                        <button id="copy-hash-btn" onclick="copyToClipboard('hash-input')" class="absolute right-2 top-2 text-gray-500 hover:text-white"><i class="fa-regular fa-copy"></i></button>
                                    </div>
                                </div>
                            </div>
                            <button id="regen-secret-btn" onclick="generateNewSecret()" class="mt-3 text-xs text-gray-400 hover:text-white underline decoration-dotted underline-offset-4">
                                Generate New Secret
                            </button>
                        </div>

                        <!-- Input Fields -->
                        <div class="space-y-4">
                            <div class="grid grid-cols-2 gap-4">
                                <div class="relative">
                                    <label class="block text-sm text-gray-400 mb-1">Asset</label>
                                    <div onclick="toggleTokenSelector()" class="flex items-center gap-2 input-field rounded-lg p-3 cursor-pointer hover:bg-white/10 transition">
                                        <img src="https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026" class="w-6 h-6 rounded-full bg-white p-0.5" id="asset-icon">
                                        <span class="font-bold text-white" id="asset-symbol">XTZ</span>
                                        <i class="fa-solid fa-chevron-down ml-auto text-xs text-gray-500"></i>
                                    </div>
                                    <!-- Token Dropdown -->
                                    <div id="token-dropdown" class="hidden absolute top-full left-0 right-0 mt-1 bg-ether-card border border-white/10 rounded-lg shadow-xl z-50 flex-col max-h-60 overflow-y-auto">
                                        <!-- Tokens will be rendered here by JS -->
                                    </div>
                                </div>
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">Amount</label>
                                    <input type="number" id="amount-input" placeholder="0.00" class="w-full input-field rounded-lg p-3 text-white font-mono focus:outline-none">
                                    <div id="selected-token-balance" class="text-xs text-gray-500 mt-1">Balance: -- </div>
                                </div>
                            </div>

                <div>
                    <label class="block text-sm text-gray-400 mb-1 flex items-center gap-1">
                        Counterparty Address
                        <div class="relative group">
                            <span class="w-4 h-4 inline-flex items-center justify-center rounded-full bg-white/10 text-[10px] text-gray-400 cursor-help hover:bg-white/20 transition">?</span>
                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-2 bg-gray-900 border border-white/20 rounded-lg text-xs text-gray-300 w-64 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-50 shadow-xl">
                                <div class="font-semibold text-white mb-1">Who receives the funds?</div>
                                <p><strong>As Alice (Initiator):</strong> Enter Bob's address on the destination chain (Jstz). This is who can claim your locked funds.</p>
                                <p class="mt-1"><strong>As Bob (Participant):</strong> Enter Alice's address on Etherlink. This is who can claim your locked funds.</p>
                                <p class="mt-1 text-gray-500">Leave empty if unknown (uses zero address).</p>
                                <div class="absolute top-full left-1/2 -translate-x-1/2 border-8 border-transparent border-t-gray-900"></div>
                            </div>
                        </div>
                    </label>
                    <input type="text" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                </div>

                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm text-gray-400 mb-1">Timelock (Mins)</label>
                                    <input type="number" value="60" class="w-full input-field rounded-lg p-3 text-white font-mono focus:outline-none">
                                </div>
                                <div class="flex items-end">
                                    <div class="text-xs text-gray-500 mb-3">
                                        <i class="fa-regular fa-clock mr-1"></i> Funds revert if not claimed.
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Action Button -->
                        <button onclick="executeAction()" id="main-action-btn" class="btn-primary w-full py-4 rounded-xl text-lg shadow-[0_0_20px_rgba(57,255,20,0.2)] flex items-center justify-center gap-2 group">
                            <span>Initiate Swap</span>
                            <i class="fa-solid fa-arrow-right group-hover:translate-x-1 transition-transform"></i>
                        </button>
                        </div> <!-- End initiate-join-content -->

                        <!-- REDEEM / REFUND CONTENT -->
                        <div id="redeem-content" class="hidden space-y-6">
                            <div class="bg-black/20 rounded-xl p-4 border border-white/5">
                                <p class="text-sm text-gray-400 mb-4 text-center">
                                    <i class="fa-solid fa-circle-info mr-2"></i>
                                    Enter the Swap ID (HashLock) to claim or refund funds.
                                </p>
                                
                                <!-- Swap ID Input -->
                                <div class="mb-4">
                                    <label class="block text-xs text-gray-400 mb-1 flex items-center gap-1">
                                        Swap ID / HashLock
                                        <div class="relative group">
                                            <span class="w-3 h-3 inline-flex items-center justify-center rounded-full bg-white/10 text-[8px] text-gray-400 cursor-help">?</span>
                                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 border border-white/20 rounded text-[10px] text-gray-300 w-48 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50">
                                                The HashLock used when initiating the swap
                                            </div>
                                        </div>
                                    </label>
                                    <input type="text" id="swap-id-input" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                                </div>
                                
                                <!-- Secret Input -->
                                <div class="mb-6">
                                    <label class="block text-xs text-gray-400 mb-1 flex items-center gap-1">
                                        Secret (Required for Claim)
                                        <div class="relative group">
                                            <span class="w-3 h-3 inline-flex items-center justify-center rounded-full bg-white/10 text-[8px] text-gray-400 cursor-help">?</span>
                                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-900 border border-white/20 rounded text-[10px] text-gray-300 w-48 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all z-50">
                                                The preimage/secret revealed by Alice to claim funds
                                            </div>
                                        </div>
                                    </label>
                                    <input type="text" id="secret-input-claim" placeholder="0x..." class="w-full input-field rounded-lg p-3 text-white font-mono text-sm focus:outline-none">
                                </div>

                                <!-- Action Buttons -->
                                <div class="grid grid-cols-2 gap-4">
                                    <button onclick="claimSwap()" id="claim-btn" class="py-4 px-4 rounded-xl bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-500 hover:to-emerald-500 text-white font-semibold flex flex-col items-center justify-center gap-1 transition-all shadow-lg shadow-green-500/20 group">
                                        <div class="flex items-center gap-2">
                                            <i class="fa-solid fa-hand-holding-dollar text-lg"></i>
                                            <span>Claim Funds</span>
                                        </div>
                                        <span class="text-[10px] opacity-70 font-normal">Using Secret</span>
                                    </button>
                                    
                                    <button onclick="refundSwap()" id="refund-btn" class="py-4 px-4 rounded-xl bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-500 hover:to-orange-500 text-white font-semibold flex flex-col items-center justify-center gap-1 transition-all shadow-lg shadow-red-500/20 group">
                                        <div class="flex items-center gap-2">
                                            <i class="fa-solid fa-rotate-left text-lg"></i>
                                            <span>Refund</span>
                                        </div>
                                        <span class="text-[10px] opacity-70 font-normal">After Timeout</span>
                                    </button>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
        </div>

            <!-- Right Column: Info & Console -->
            <div class="lg:col-span-5 flex flex-col gap-6">
                
                <!-- Network Status -->
                <div class="glass-card rounded-2xl p-6">
                    <h3 class="text-sm font-mono text-gray-400 mb-4 uppercase tracking-wider">Network Bridge</h3>
            
                    <div class="flex items-center justify-between relative">
                        <!-- Left: Etherlink -->
                        <div class="text-center z-10">
                            <div class="w-14 h-14 rounded-2xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 flex items-center justify-center mx-auto mb-2 shadow-lg relative overflow-hidden group">
                                <div class="absolute inset-0 bg-green-500/10 group-hover:bg-green-500/20 transition"></div>
                                <i class="fa-brands fa-ethereum text-2xl text-green-400"></i>
                            </div>
                            <div class="text-sm font-bold text-gray-200">Etherlink</div>
                            <div class="text-[10px] text-green-500">Connected</div>
                        </div>

                        <!-- Center: Animation -->
                        <div class="flex-1 h-px bg-slate-700 mx-4 relative">
                            <div class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-8 h-8 rounded-full bg-slate-900 border border-slate-700 flex items-center justify-center z-20">
                                <i class="fa-solid fa-arrow-right-arrow-left text-gray-500 text-xs"></i>
                    </div>
                            <div class="absolute top-0 left-0 h-full w-1/2 bg-gradient-to-r from-transparent to-green-500 opacity-50 animate-pulse"></div>
                        </div>

                        <!-- Right: Jstz -->
                        <div class="text-center z-10">
                            <div class="w-14 h-14 rounded-2xl bg-gradient-to-br from-slate-800 to-slate-900 border border-slate-700 flex items-center justify-center mx-auto mb-2 shadow-lg relative overflow-hidden group">
                                <div class="absolute inset-0 bg-yellow-500/10 group-hover:bg-yellow-500/20 transition"></div>
                                <i class="fa-solid fa-layer-group text-2xl text-jstz-accent"></i>
                    </div>
                            <div class="text-sm font-bold text-gray-200">Jstz</div>
                            <div class="text-[10px] text-gray-500">Waiting...</div>
                        </div>
                    </div>
                </div>

                <!-- Terminal / Logs -->
                <div class="glass-card rounded-2xl flex flex-col flex-grow overflow-hidden h-96 lg:h-auto border-t-4 border-t-ether-green">
                    <div class="bg-black/40 p-3 flex items-center justify-between border-b border-white/5">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full bg-red-500/50"></div>
                            <div class="w-3 h-3 rounded-full bg-yellow-500/50"></div>
                            <div class="w-3 h-3 rounded-full bg-green-500/50"></div>
                        </div>
                        <div class="text-[10px] font-mono text-gray-500">swap_daemon.js</div>
                    </div>
                    <div id="terminal-body" class="p-4 font-mono text-xs space-y-2 overflow-y-auto flex-grow bg-black/20 max-h-[400px]">
                        <div class="text-gray-500">Last login: <span id="login-time"></span> on tty1</div>
                        <div class="text-green-500/50">Initializing atomic swap protocol...</div>
                        <div class="text-green-500/50">Loaded JS environment.</div>
                        <div class="text-white">> Ready.</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="border-t border-white/5 bg-black/20 py-6 mt-auto">
        <div class="max-w-7xl mx-auto px-4 text-center">
            <p class="text-xs text-gray-500">Built for Etherlink Internal Hackathon</p>
        </div>
    </footer>

    <script>
        // --- REAL CONTRACT INTEGRATION ---

        // Contract Configuration - Per Network
        const NETWORK_CONFIG = {
            // Hardhat Local
            31337: {
                name: 'Hardhat Local',
                rpcUrl: 'http://127.0.0.1:8545',
                htlcAddress: '0x5FbDB2315678afecb367f032d93F642f64180aa3', // Deploy locally
                explorer: null
            },
            // Etherlink Testnet (Ghostnet)
            128123: {
                name: 'Etherlink Testnet',
                rpcUrl: 'https://node.ghostnet.etherlink.com',
                htlcAddress: '0x32a57e30880174145cb002f526487Cb74d0FCF46',
                explorer: 'https://testnet.explorer.etherlink.com'
            },
            // Etherlink Mainnet
            42793: {
                name: 'Etherlink Mainnet',
                rpcUrl: 'https://node.mainnet.etherlink.com',
                htlcAddress: null, // TODO: Deploy and fill this
                explorer: 'https://explorer.etherlink.com'
            }
        };

        // Default to testnet for real testing
        const DEFAULT_CHAIN_ID = 128123; // Etherlink Testnet

        const CONFIG = {
            // Current Etherlink config (will be updated based on connected network)
            etherlink: {
                contractAddress: NETWORK_CONFIG[DEFAULT_CHAIN_ID]?.htlcAddress || '0x5FbDB2315678afecb367f032d93F642f64180aa3',
                rpcUrl: NETWORK_CONFIG[DEFAULT_CHAIN_ID]?.rpcUrl || 'http://127.0.0.1:8545',
                chainId: DEFAULT_CHAIN_ID,
                abi: [
                    "function initiateSwap(address recipient, bytes32 hashLock, uint256 expiration) external payable returns (bytes32)",
                    "function claimSwap(bytes32 swapId, bytes calldata secret) external returns (bool)",
                    "function refundSwap(bytes32 swapId) external returns (bool)",
                    "function getSwap(bytes32 swapId) external view returns (address recipient, address sender, uint256 amount, uint256 expiration, bytes32 hashLock, uint8 status)",
                    "function swapPresent(bytes32 swapId) external view returns (bool)",
                    "event SwapInitiated(bytes32 indexed swapId, address payable sender, address recipient, uint256 amount, bytes32 hashLock, uint256 expiration)",
                    "event SwapClaimed(bytes32 indexed swapId, address claimer, bytes secret)",
                    "event SwapRefunded(bytes32 indexed swapId, address sender, uint256 amount)"
                ]
            },
            // Jstz HTLC Smart Function
            jstz: {
                functionUrl: 'http://localhost:8932', // Jstz sandbox RPC
                functionAddress: 'jstz://htlc/'
            }
        };

        // ERC20 ABI for token interactions
        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function symbol() view returns (string)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)"
        ];

        // Network Chain IDs
        const CHAIN_IDS = {
            HARDHAT_LOCAL: 31337,
            ETHERLINK_MAINNET: 42793,
            ETHERLINK_TESTNET: 128123
        };

        // Etherlink Tokens - Simplified for POC
        // Only XTZ (native) and WXTZ (wrapped) for atomic swap demonstration
        const TOKENS = {
            XTZ: {
                symbol: 'XTZ',
                name: 'Tezos (Native)',
                address: null, // Native token
                decimals: 18,
                icon: 'https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026',
                isNative: true,
                chains: [CHAIN_IDS.HARDHAT_LOCAL, CHAIN_IDS.ETHERLINK_MAINNET, CHAIN_IDS.ETHERLINK_TESTNET]
            },
            WXTZ: {
                symbol: 'WXTZ',
                name: 'Wrapped XTZ',
                // Addresses per network
                addresses: {
                    [CHAIN_IDS.ETHERLINK_MAINNET]: '0xc9B53AB2679f573e480d01e0f49e2B5CFB7a3EAb',
                    [CHAIN_IDS.ETHERLINK_TESTNET]: '0xB1Ea698633d57705e93b0E40c1077d46CD6A51d8'
                },
                decimals: 18,
                icon: 'https://cryptologos.cc/logos/tezos-xtz-logo.svg?v=026',
                isNative: false,
                chains: [CHAIN_IDS.ETHERLINK_MAINNET, CHAIN_IDS.ETHERLINK_TESTNET]
            }
        };

        // Helper to get token address for current network
        function getTokenAddress(tokenSymbol) {
            const token = TOKENS[tokenSymbol];
            if (!token || token.isNative) return null;
            
            // If token has per-network addresses
            if (token.addresses && state.currentChainId) {
                return token.addresses[state.currentChainId] || null;
            }
            // Fallback to single address
            return token.address || null;
        }

        // State
        const state = {
            mode: 'create', // 'create' | 'join'
            step: 1,
            secret: null,
            secretBytes: null,
            hash: null,
            chain: 'etherlink', // 'etherlink' (From Etherlink) | 'jstz' (From Jstz)
            etherlinkWallet: null,
            etherlinkAddress: null,
            jstzAddress: null,
            provider: null,
            signer: null,
            contract: null,
            currentSwapId: null,
            selectedToken: 'XTZ', // Default token
            tokenBalances: {},
            tokenSelectorOpen: false,
            currentChainId: null // Current network chain ID
        };

        // Utils
        const log = (msg, type = 'info') => {
            const term = document.getElementById('terminal-body');
            const line = document.createElement('div');
            const time = new Date().toLocaleTimeString([], {hour12: false});
            
            let color = 'text-gray-300';
            if (type === 'success') color = 'text-ether-green';
            if (type === 'error') color = 'text-red-400';
            if (type === 'warning') color = 'text-yellow-400';
            if (type === 'system') color = 'text-blue-400';

            line.className = `${color} hover:bg-white/5 p-0.5 rounded`;
            line.innerHTML = `<span class="opacity-50 mr-2">[${time}]</span>${msg}`;
            
            term.appendChild(line);
            term.scrollTop = term.scrollHeight;
        };

        document.getElementById('login-time').innerText = new Date().toDateString();

        // Generate secret using ethers.js keccak256 for compatibility
        function generateNewSecret() {
            // Generate 32 random bytes as secret
            const randomBytes = ethers.utils.randomBytes(32);
            const secret = ethers.utils.hexlify(randomBytes);
            
            // Hash using keccak256 (same as Solidity)
            const hash = ethers.utils.keccak256(randomBytes);
            
            state.secret = secret;
            state.secretBytes = randomBytes;
            state.hash = hash;
            
            document.getElementById('secret-input').value = secret;
            document.getElementById('hash-input').value = hash;
            
            log(`Generated new Preimage/Hash pair.`, 'system');
            log(`Hash: ${hash.substring(0, 18)}...`, 'system');
        }

        // Connect to Etherlink (MetaMask or local)
        async function connectEtherlink() {
            try {
                console.log('[DEBUG] Starting Etherlink connection...');
                
                if (typeof window.ethereum !== 'undefined') {
                    // Use MetaMask
                    console.log('[DEBUG] MetaMask detected, requesting accounts...');
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    state.provider = new ethers.providers.Web3Provider(window.ethereum);
                    state.signer = state.provider.getSigner();
                    state.etherlinkAddress = await state.signer.getAddress();
                    console.log('[DEBUG] Connected address:', state.etherlinkAddress);
                    log(`MetaMask connected: ${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`, 'success');
                } else {
                    // Fallback to local Hardhat node
                    console.log('[DEBUG] No MetaMask, falling back to local node');
                    state.provider = new ethers.providers.JsonRpcProvider(CONFIG.etherlink.rpcUrl);
                    state.signer = state.provider.getSigner(0);
                    state.etherlinkAddress = await state.signer.getAddress();
                    log(`Connected to local node: ${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`, 'success');
                }
                
                // Get current chain ID
                const network = await state.provider.getNetwork();
                state.currentChainId = network.chainId;
                console.log('[DEBUG] Connected to chainId:', state.currentChainId);
                
                // Log network info
                const networkConfig = NETWORK_CONFIG[state.currentChainId];
                const networkName = networkConfig?.name || getNetworkName(state.currentChainId);
                log(`Network: ${networkName} (chainId: ${state.currentChainId})`, 'info');
                
                // Update network badge in header
                updateNetworkBadge(state.currentChainId, networkName);
                
                // Check if we're on the wrong network
                const isEtherlinkNetwork = [128123, 42793, 31337].includes(state.currentChainId);
                if (!isEtherlinkNetwork) {
                    log(`⚠️ Wrong network! You are on ${networkName} (chainId: ${state.currentChainId})`, 'warning');
                    log(`Click the network badge to switch to Etherlink Testnet`, 'system');
                    console.log('[DEBUG] Wrong network detected. Expected Etherlink (128123, 42793, or 31337), got:', state.currentChainId);
                }
                
                // Get HTLC contract address for this network
                const htlcAddress = networkConfig?.htlcAddress;
                if (!htlcAddress) {
                    log(`⚠️ HTLC contract not deployed on ${networkName}!`, 'warning');
                    log(`Deploy with: npx hardhat run scripts/deploy.js --network etherlinkTestnet`, 'system');
                    console.log('[DEBUG] No HTLC address for chainId:', state.currentChainId);
                }
                
                // Initialize contract (if address exists)
                if (htlcAddress) {
                    state.contract = new ethers.Contract(
                        htlcAddress,
                        CONFIG.etherlink.abi,
                        state.signer
                    );
                    log(`HTLC Contract: ${htlcAddress.substring(0, 10)}...`, 'success');
                    console.log('[DEBUG] Contract initialized at:', htlcAddress);
                } else {
                    state.contract = null;
                }
                
                // Fetch and log balance
                await fetchAndLogBalance();
                
                return true;
            } catch (error) {
                console.error('[DEBUG] Connection error:', error);
                log(`Etherlink connection failed: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Update the network badge in header
        function updateNetworkBadge(chainId, networkName) {
            const badge = document.getElementById('network-badge');
            const dot = document.getElementById('network-dot');
            const name = document.getElementById('network-name');
            
            if (!badge || !dot || !name) return;
            
            name.textContent = networkName;
            
            // Color based on network
            if (chainId === 128123) {
                // Etherlink Testnet - Green (correct network)
                dot.className = 'w-2 h-2 rounded-full bg-ether-green animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-ether-green/50 cursor-pointer hover:border-ether-green transition';
                name.className = 'text-xs text-ether-green';
            } else if (chainId === 42793) {
                // Etherlink Mainnet - Blue
                dot.className = 'w-2 h-2 rounded-full bg-blue-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-blue-500/50 cursor-pointer hover:border-blue-500 transition';
                name.className = 'text-xs text-blue-400';
            } else if (chainId === 31337) {
                // Hardhat Local - Yellow
                dot.className = 'w-2 h-2 rounded-full bg-yellow-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-yellow-500/50 cursor-pointer hover:border-yellow-500 transition';
                name.className = 'text-xs text-yellow-400';
            } else {
                // Wrong network - Red
                dot.className = 'w-2 h-2 rounded-full bg-red-500 animate-pulse';
                badge.className = 'flex items-center gap-2 px-3 py-1.5 rounded-full bg-ether-dark border border-red-500/50 cursor-pointer hover:border-red-500 transition';
                name.className = 'text-xs text-red-400';
            }
        }
        
        // Fetch and log balance with debug info
        async function fetchAndLogBalance() {
            if (!state.provider || !state.etherlinkAddress) {
                console.log('[DEBUG] Cannot fetch balance - provider or address missing');
                return;
            }
            
            try {
                console.log('[DEBUG] Fetching native balance for:', state.etherlinkAddress);
                const balance = await state.provider.getBalance(state.etherlinkAddress);
                const balanceEth = ethers.utils.formatEther(balance);
                console.log('[DEBUG] Native balance (wei):', balance.toString());
                console.log('[DEBUG] Native balance (XTZ):', balanceEth);
                log(`Balance: ${parseFloat(balanceEth).toFixed(4)} XTZ`, 'info');
                
                // Update balance display
                const balanceDisplay = document.querySelector('.text-gray-500');
                if (balanceDisplay && balanceDisplay.textContent.includes('Balance:')) {
                    balanceDisplay.textContent = `Balance: ${parseFloat(balanceEth).toFixed(4)} XTZ`;
                }
            } catch (error) {
                console.error('[DEBUG] Error fetching balance:', error);
                log(`Error fetching balance: ${error.message}`, 'error');
            }
        }

        // Add Etherlink network to MetaMask
        async function addEtherlinkToMetaMask(chainId = 128123) {
            if (typeof window.ethereum === 'undefined') {
                log('MetaMask not installed', 'error');
                return false;
            }
            
            const networkConfig = NETWORK_CONFIG[chainId];
            if (!networkConfig) {
                log('Unknown network', 'error');
                return false;
            }

            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: '0x' + chainId.toString(16),
                        chainName: networkConfig.name,
                        nativeCurrency: {
                            name: 'Tezos',
                            symbol: 'XTZ',
                            decimals: 18
                        },
                        rpcUrls: [networkConfig.rpcUrl],
                        blockExplorerUrls: networkConfig.explorer ? [networkConfig.explorer] : null
                    }]
                });
                log(`${networkConfig.name} added to MetaMask!`, 'success');
                return true;
            } catch (error) {
                log(`Failed to add network: ${error.message}`, 'error');
                return false;
            }
        }

        // Switch MetaMask to Etherlink network
        async function switchToEtherlink(chainId = 128123) {
            if (typeof window.ethereum === 'undefined') return false;
            
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x' + chainId.toString(16) }]
                });
                return true;
            } catch (error) {
                // Chain not added, try to add it
                if (error.code === 4902) {
                    return await addEtherlinkToMetaMask(chainId);
                }
                log(`Failed to switch network: ${error.message}`, 'error');
                return false;
            }
        }

        // Get human-readable network name
        function getNetworkName(chainId) {
            switch (chainId) {
                case CHAIN_IDS.HARDHAT_LOCAL: return 'Hardhat Local';
                case CHAIN_IDS.ETHERLINK_MAINNET: return 'Etherlink Mainnet';
                case CHAIN_IDS.ETHERLINK_TESTNET: return 'Etherlink Testnet';
                default: return `Unknown (${chainId})`;
            }
        }

        // Check if token is available on current network
        function isTokenAvailable(tokenSymbol) {
            const token = TOKENS[tokenSymbol];
            if (!token) {
                console.log(`[DEBUG] Token ${tokenSymbol} not found in TOKENS`);
                return false;
            }
            if (!state.currentChainId) {
                console.log(`[DEBUG] No chainId set, defaulting to native only for ${tokenSymbol}`);
                return token.isNative;
            }
            const available = token.chains.includes(state.currentChainId);
            console.log(`[DEBUG] Token ${tokenSymbol}: chainId=${state.currentChainId}, supportedChains=[${token.chains.join(',')}], available=${available}`);
            return available;
        }

        // Get available tokens for current network
        function getAvailableTokens() {
            return Object.entries(TOKENS)
                .filter(([symbol, token]) => isTokenAvailable(symbol))
                .reduce((acc, [symbol, token]) => {
                    acc[symbol] = token;
                    return acc;
                }, {});
        }

        // Jstz API calls
        async function jstzRequest(method, path, body = null) {
            const url = `${CONFIG.jstz.functionUrl}${path}`;
            const options = {
                method,
                headers: { 'Content-Type': 'application/json' }
            };
            if (body) options.body = JSON.stringify(body);
            
            try {
                const response = await fetch(url, options);
                return await response.json();
            } catch (error) {
                log(`Jstz request failed: ${error.message}`, 'error');
                throw error;
            }
        }

        // ============================================
        // TOKEN & BALANCE MANAGEMENT
        // ============================================

        // Get balance for a specific token
        async function getTokenBalance(tokenSymbol) {
            if (!state.provider || !state.etherlinkAddress) return '0';
            
            const token = TOKENS[tokenSymbol];
            if (!token) return '0';
            
            // Check if token is available on current network
            if (!isTokenAvailable(tokenSymbol)) {
                return 'N/A';
            }

            try {
                if (token.isNative) {
                    // Native XTZ balance
                    const balance = await state.provider.getBalance(state.etherlinkAddress);
                    return ethers.utils.formatUnits(balance, token.decimals);
                } else {
                    // ERC20 token balance - use getTokenAddress for per-network addresses
                    const tokenAddress = getTokenAddress(tokenSymbol);
                    if (!tokenAddress) return 'N/A';
                    
                    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, state.provider);
                    const balance = await tokenContract.balanceOf(state.etherlinkAddress);
                    return ethers.utils.formatUnits(balance, token.decimals);
                }
            } catch (error) {
                // Token contract doesn't exist on this network
                console.warn(`Token ${tokenSymbol} not available on current network`);
                return 'N/A';
            }
        }

        // Fetch all token balances
        async function fetchAllBalances() {
            if (!state.provider || !state.etherlinkAddress) return;

            const availableTokens = getAvailableTokens();
            const tokenCount = Object.keys(availableTokens).length;
            log(`Fetching balances for ${tokenCount} token(s)...`, 'system');
            
            for (const [symbol, token] of Object.entries(TOKENS)) {
                if (isTokenAvailable(symbol)) {
                    const balance = await getTokenBalance(symbol);
                    state.tokenBalances[symbol] = balance;
                } else {
                    state.tokenBalances[symbol] = 'N/A';
                }
            }

            // Update UI
            updateBalanceDisplay();
            renderTokenDropdown(); // Re-render with updated balances
            log('Balances updated', 'success');
        }

        // Update balance display in UI
        function updateBalanceDisplay() {
            const balanceEl = document.getElementById('selected-token-balance');
            const walletBalanceEl = document.getElementById('wallet-balance');
            
            if (balanceEl && state.selectedToken) {
                const balance = state.tokenBalances[state.selectedToken];
                if (balance === 'N/A' || !isTokenAvailable(state.selectedToken)) {
                    balanceEl.innerText = `Balance: N/A (not on this network)`;
                } else {
                    const formatted = parseFloat(balance || '0').toFixed(4);
                    balanceEl.innerText = `Balance: ${formatted} ${state.selectedToken}`;
                }
            }
            
            // Update wallet button with XTZ balance
            if (walletBalanceEl && state.tokenBalances['XTZ'] && state.tokenBalances['XTZ'] !== 'N/A') {
                const xtzBalance = parseFloat(state.tokenBalances['XTZ']).toFixed(2);
                walletBalanceEl.innerText = `${xtzBalance} XTZ`;
            }
        }

        // Select a token
        function selectToken(symbol) {
            const token = TOKENS[symbol];
            if (!token) return;

            state.selectedToken = symbol;
            
            // Update UI
            document.getElementById('asset-icon').src = token.icon;
            document.getElementById('asset-symbol').innerText = token.symbol;
            
            // Close dropdown
            toggleTokenSelector(false);
            
            // Update balance display
            updateBalanceDisplay();
            
            log(`Selected token: ${token.name} (${token.symbol})`, 'info');
        }

        // Toggle token selector dropdown
        function toggleTokenSelector(forceState = null) {
            const dropdown = document.getElementById('token-dropdown');
            if (!dropdown) return;

            state.tokenSelectorOpen = forceState !== null ? forceState : !state.tokenSelectorOpen;
            
            if (state.tokenSelectorOpen) {
                dropdown.classList.remove('hidden');
                dropdown.classList.add('flex');
            } else {
                dropdown.classList.add('hidden');
                dropdown.classList.remove('flex');
            }
        }

        // Render token list in dropdown
        function renderTokenDropdown() {
            const dropdown = document.getElementById('token-dropdown');
            if (!dropdown) return;

            dropdown.innerHTML = '';
            
            for (const [symbol, token] of Object.entries(TOKENS)) {
                const balance = state.tokenBalances[symbol] || '0';
                const isAvailable = isTokenAvailable(symbol);
                const isSelected = symbol === state.selectedToken;
                
                // Format balance
                let formattedBalance;
                if (!isAvailable || balance === 'N/A') {
                    formattedBalance = 'N/A';
                } else {
                    formattedBalance = parseFloat(balance).toFixed(4);
                }
                
                const item = document.createElement('div');
                item.className = `flex items-center justify-between p-3 transition ${
                    isAvailable 
                        ? `hover:bg-white/10 cursor-pointer ${isSelected ? 'bg-ether-green/10' : ''}` 
                        : 'opacity-40 cursor-not-allowed'
                }`;
                
                if (isAvailable) {
                    item.onclick = () => selectToken(symbol);
                }
                
                const tokenAddr = getTokenAddress(symbol);
                item.innerHTML = `
                    <div class="flex items-center gap-3">
                        <img src="${token.icon}" class="w-8 h-8 rounded-full bg-white p-0.5 ${!isAvailable ? 'grayscale' : ''}" alt="${token.symbol}">
                        <div>
                            <div class="font-bold ${isAvailable ? 'text-white' : 'text-gray-500'}">${token.symbol}</div>
                            <div class="text-xs text-gray-400">${token.name}</div>
                            ${!isAvailable ? '<div class="text-[10px] text-yellow-500">Not on this network</div>' : ''}
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-sm font-mono ${isAvailable ? 'text-white' : 'text-gray-500'}">${formattedBalance}</div>
                        ${!token.isNative && tokenAddr ? `<div class="text-[10px] text-gray-500 truncate max-w-[80px]">${tokenAddr.substring(0, 10)}...</div>` : ''}
                    </div>
                `;
                dropdown.appendChild(item);
            }
        }

        // Add to MetaMask wallet
        async function addTokenToWallet(symbol) {
            const token = TOKENS[symbol];
            if (!token || token.isNative) {
                log('Cannot add native token to wallet', 'warning');
                return;
            }

            if (typeof window.ethereum === 'undefined') {
                log('MetaMask not detected', 'error');
                return;
            }

            try {
                await window.ethereum.request({
                    method: 'wallet_watchAsset',
                    params: {
                        type: 'ERC20',
                        options: {
                            address: token.address,
                            symbol: token.symbol,
                            decimals: token.decimals,
                            image: token.icon
                        }
                    }
                });
                log(`${token.symbol} added to wallet`, 'success');
            } catch (error) {
                log(`Failed to add token: ${error.message}`, 'error');
            }
        }

        function setChain(chain) {
            state.chain = chain;
            const btnEth = document.getElementById('chain-etherlink');
            const btnJstz = document.getElementById('chain-jstz');

            // Reset styles
            const activeClass = "border-ether-green bg-ether-green/10 text-white";
            const inactiveClass = "border-transparent text-gray-400 hover:text-white hover:bg-white/5";

            if (chain === 'etherlink') {
                btnEth.className = `relative py-3 rounded-lg transition-all group overflow-hidden ${activeClass}`;
                btnJstz.className = `relative py-3 rounded-lg transition-all group ${inactiveClass}`;
                log("Direction: Etherlink -> Jstz selected.", 'info');
            } else {
                btnJstz.className = `relative py-3 rounded-lg transition-all group overflow-hidden border-jstz-accent bg-jstz-accent/10 text-white`;
                btnEth.className = `relative py-3 rounded-lg transition-all group ${inactiveClass}`;
                log("Direction: Jstz -> Etherlink selected.", 'info');
            }
            
            // Update balance display for selected token
            updateBalanceDisplay();
        }

        function setTab(mode) {
            state.mode = mode;
            const btnCreate = document.getElementById('tab-create');
            const btnJoin = document.getElementById('tab-join');
            const btnRedeem = document.getElementById('tab-redeem');
            const actionBtn = document.getElementById('main-action-btn');
            const secretSection = document.getElementById('secret-section');
            const timelockInput = document.querySelector('input[type="number"][value="60"]');
            
            // Content Sections
            const initiateJoinContent = document.getElementById('initiate-join-content');
            const redeemContent = document.getElementById('redeem-content');
            
            // Input Containers
            const secretContainer = document.getElementById('secret-container');
            const hashContainer = document.getElementById('hash-container');
            const proofInputs = document.getElementById('proof-inputs');
            const hashInput = document.getElementById('hash-input');
            const copyHashBtn = document.getElementById('copy-hash-btn');
            const regenSecretBtn = document.getElementById('regen-secret-btn');

            // Reset Button State
            actionBtn.disabled = false;
            actionBtn.onclick = executeAction;
            actionBtn.classList.remove('bg-ether-green', 'text-black');

            // Reset Tab Styles
            const inactiveStyle = "flex-1 py-3 rounded-lg text-sm font-semibold text-gray-400 hover:text-white hover:bg-white/5 transition-all";
            btnCreate.className = inactiveStyle;
            btnJoin.className = inactiveStyle;
            btnRedeem.className = inactiveStyle;

            if (mode === 'redeem') {
                // REDEEM MODE
                btnRedeem.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-purple-600 shadow-lg transition-all";
                
                // Show Redeem content, hide Initiate content
                initiateJoinContent.classList.add('hidden');
                redeemContent.classList.remove('hidden');
                
                log("Switched to Redeem / Refund Mode", 'info');
                return;
            }
            
            // INITIATE or JOIN MODE
            initiateJoinContent.classList.remove('hidden');
            redeemContent.classList.add('hidden');

            if (mode === 'create') {
                btnCreate.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-white bg-ether-border shadow-lg transition-all";
                
                // SHOW Secret Gen UI
                secretSection.classList.remove('opacity-50', 'pointer-events-none', 'grayscale');
                secretContainer.style.display = 'block';
                proofInputs.classList.remove('grid-cols-1');
                proofInputs.classList.add('md:grid-cols-2');
                
                regenSecretBtn.style.display = 'block';
                copyHashBtn.style.display = 'block';
                
                // Hash Input Readonly
                hashInput.readOnly = true;
                hashInput.classList.add('text-gray-300');
                hashInput.classList.remove('text-white', 'bg-white/5');
                
                generateNewSecret();
                
                // Reset Timelock
                if(timelockInput) timelockInput.value = 60;

                actionBtn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right group-hover:translate-x-1 transition-transform"></i>`;
                actionBtn.className = "btn-primary w-full py-4 rounded-xl text-lg shadow-[0_0_20px_rgba(57,255,20,0.2)] flex items-center justify-center gap-2 group";
                
                log("Switched to Initiator Mode (Alice)", 'info');
            } else {
                btnJoin.className = "flex-1 py-3 rounded-lg text-sm font-semibold text-black bg-jstz-accent shadow-lg transition-all";
                
                // HIDE Secret Gen UI, SHOW Manual Hash Input
                secretSection.classList.remove('opacity-50', 'pointer-events-none', 'grayscale'); // Keep active for input
                secretContainer.style.display = 'none';
                proofInputs.classList.remove('md:grid-cols-2');
                proofInputs.classList.add('grid-cols-1');
                
                regenSecretBtn.style.display = 'none';
                copyHashBtn.style.display = 'none';
                
                // Make Hash Input Editable
                hashInput.readOnly = false;
                hashInput.value = "";
                hashInput.placeholder = "Paste HashLock here (0x...)";
                hashInput.classList.remove('text-gray-300');
                hashInput.classList.add('text-white', 'bg-white/5');
                hashInput.focus();

                // Enforce Timelock < Alice's (e.g. 30 mins)
                if(timelockInput) timelockInput.value = 30;

                actionBtn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                actionBtn.className = "w-full py-4 rounded-xl text-lg font-bold bg-jstz-accent text-black shadow-lg flex items-center justify-center gap-2 hover:brightness-110 transition-all";
                
                log("Switched to Participant Mode (Bob). Enter HashLock manually.", 'info');
            }
        }

        function updateProgress(step) {
            state.step = step;
            const progressBar = document.getElementById('progress-bar');
            
            // Reset all
            [1,2,3,4].forEach(i => {
                const container = document.getElementById(`step-${i}`);
                const dot = container.querySelector('.step-dot');
                
                dot.classList.remove('active', 'completed');
                dot.innerHTML = i;
                
                if (i < step) {
                    dot.classList.add('completed');
                    dot.innerHTML = '<i class="fa-solid fa-check"></i>';
                } else if (i === step) {
                    dot.classList.add('active');
        }
            });

            // Bar width
            const percentage = ((step - 1) / 3) * 100;
            progressBar.style.width = `${percentage}%`;
        }

        // ============================================
        // REAL CONTRACT INTERACTIONS
        // ============================================

        // Initiate swap on Etherlink (Alice locks ETH)
        async function initiateOnEtherlink() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const counterpartyInput = document.querySelector('input[placeholder="0x..."]');
            const timelockInput = document.querySelector('input[type="number"][value="60"]') || document.querySelector('input[type="number"]');
            const timelockMins = parseInt(timelockInput?.value || 60);
            
            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("❌ Please enter a valid amount (> 0)", 'error');
                return;
            }
            
            // 2. Validate hashlock exists and is properly formatted
            if (!state.hash || !isValidHashLock(state.hash)) {
                log("❌ Invalid HashLock. Generate a new secret first.", 'error');
                return;
            }
            
            // 3. Validate secret exists (needed for claiming later)
            if (!state.secret) {
                log("❌ Secret not found. Generate a new secret first.", 'error');
                return;
            }
            
            // 4. Validate timelock (minimum 5 minutes for safety)
            if (timelockMins < 5) {
                log("❌ Timelock must be at least 5 minutes for safety", 'error');
                return;
            }

            // Connect if not connected
            if (!state.provider) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }

            // Check if contract is deployed on this network
            if (!state.contract) {
                const networkName = NETWORK_CONFIG[state.currentChainId]?.name || 'this network';
                log(`❌ HTLC contract not deployed on ${networkName}!`, 'error');
                log('Deploy with: npx hardhat run scripts/deploy.js --network etherlinkTestnet', 'system');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking for duplicates...`;
            
            // ========== DUPLICATE CHECK ==========
            // 5. Check if swap with this hashlock already exists
            log('Checking if swap already exists...', 'warning');
            const existingSwap = await verifySwapOnEtherlink(state.hash);
            if (existingSwap.valid && existingSwap.swap) {
                log(`❌ A swap with this HashLock already exists!`, 'error');
                log(`State: ${['EMPTY', 'ACTIVE', 'CLAIMED', 'REFUNDED'][existingSwap.swap.state]}`, 'info');
                log(`Generate a new secret to create a new swap.`, 'system');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log('✓ HashLock is unique', 'success');
            
            // ========== BALANCE CHECK ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking balance...`;
            
            // 6. Check user has enough balance
            const balance = await state.provider.getBalance(state.etherlinkAddress);
            const amountWei = ethers.utils.parseEther(amount);
            if (balance.lt(amountWei)) {
                const balanceEth = ethers.utils.formatEther(balance);
                log(`❌ Insufficient balance!`, 'error');
                log(`Required: ${amount} XTZ, Available: ${parseFloat(balanceEth).toFixed(4)} XTZ`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log('✓ Sufficient balance', 'success');
            
            // ========== EXECUTE INITIATE ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Initiating Swap...`;

            try {
                const recipient = counterpartyInput?.value || ethers.constants.AddressZero;
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                
                log(`Initiating swap on Etherlink...`, 'warning');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`HashLock: ${state.hash.substring(0, 18)}...`, 'info');
                log(`Expiration: ${new Date(expiration * 1000).toLocaleTimeString()} (${timelockMins} mins)`, 'info');
                if (recipient !== ethers.constants.AddressZero) {
                    log(`Recipient: ${recipient.substring(0, 10)}...`, 'info');
                }

                const tx = await state.contract.initiateSwap(
                    recipient,
                    state.hash,
                    expiration,
                    { value: amountWei }
                );

                log(`Transaction sent: ${tx.hash.substring(0, 18)}...`, 'warning');
                
                const receipt = await tx.wait();
                
                state.currentSwapId = state.hash;
                
                log(`✅ Swap initiated on Etherlink!`, 'success');
                log(`Contract: ${CONFIG.etherlink.contractAddress.substring(0, 10)}...`, 'success');
                log(`SwapId: ${state.currentSwapId.substring(0, 18)}...`, 'success');
                log(`Funds Locked: ${amount} ETH`, 'success');
                
                updateProgress(2);
                btn.innerHTML = `<span>Waiting for Bob on Jstz...</span>`;
                
                log(`Share this HashLock with Bob: ${state.hash}`, 'system');
                log(`Bob must lock funds on Jstz with the same HashLock`, 'info');
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.currentSwapId, state.secret);
                log("Go to 'Redeem / Refund' tab to claim or refund later", 'system');
                
                // Enable claim button after Bob participates
                setTimeout(() => {
                    log("Ready to claim on Jstz (when Bob has locked funds)", 'system');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Waiting for Bob...</span>`;
                    // No onClick needed here, user should go to Redeem tab
                    updateProgress(3);
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Initiate Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // Initiate swap on Jstz (Bob locks XTZ)
        async function initiateOnJstz() {
            const btn = document.getElementById('main-action-btn');
            const amount = document.getElementById('amount-input').value;
            const hashInput = document.getElementById('hash-input');
            const hashlock = hashInput.value;
            const timelockInput = document.querySelector('input[type="number"]');
            const timelockMins = parseInt(timelockInput?.value || 30);

            // ========== INPUT VALIDATION ==========
            
            // 1. Validate amount
            if (!amount || parseFloat(amount) <= 0) {
                log("❌ Please enter a valid amount (> 0)", 'error');
                return;
            }

            // 2. Validate hashlock format
            if (!hashlock || !isValidHashLock(hashlock)) {
                log("❌ Please enter a valid HashLock (0x + 64 hex characters)", 'error');
                log("Get the HashLock from Alice who initiated the swap", 'info');
                return;
            }
            
            // 3. Validate timelock (Bob's timelock should be shorter than Alice's)
            if (timelockMins < 2) {
                log("❌ Timelock must be at least 2 minutes", 'error');
                return;
            }
            
            // 4. Warning if timelock is too long (should be shorter than Alice's)
            if (timelockMins >= 60) {
                log("⚠️ Warning: Your timelock should be shorter than Alice's for safety", 'warning');
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying Alice's swap...`;
            
            // ========== VERIFY ALICE'S SWAP EXISTS ==========
            // 5. Check that Alice has already locked funds on Etherlink with this hashlock
            log("Checking if Alice has locked funds on Etherlink...", 'warning');
            const aliceSwap = await verifySwapOnEtherlink(hashlock, SwapState.ACTIVE);
            
            if (!aliceSwap.valid) {
                log(`❌ Alice's swap not found on Etherlink!`, 'error');
                log(`Make sure Alice has initiated the swap first with this HashLock`, 'system');
                log(`HashLock: ${hashlock.substring(0, 30)}...`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            log(`✓ Found Alice's swap: ${aliceSwap.swap.amount} XTZ locked`, 'success');
            log(`✓ Expires: ${aliceSwap.swap.expirationDate}`, 'success');
            
            // 6. Check Alice's swap hasn't expired
            if (aliceSwap.swap.isExpired) {
                log("❌ Alice's swap has expired! Don't lock your funds.", 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            // 7. Check there's enough time for Bob's timelock to be shorter
            const aliceExpiration = aliceSwap.swap.expiration;
            const now = Math.floor(Date.now() / 1000);
            const aliceRemainingMins = Math.floor((aliceExpiration - now) / 60);
            
            if (timelockMins >= aliceRemainingMins) {
                log(`❌ Your timelock (${timelockMins}m) must be shorter than Alice's remaining time (${aliceRemainingMins}m)`, 'error');
                log(`Recommended: Set timelock to ${Math.floor(aliceRemainingMins / 2)} minutes`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            log(`✓ Timelock is safe (${timelockMins}m < ${aliceRemainingMins}m remaining)`, 'success');
            
            // ========== CHECK FOR DUPLICATE ON JSTZ ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Checking for duplicates on Jstz...`;
            
            // 8. Check if swap with this hashlock already exists on Jstz
            const existingJstzSwap = await verifySwapOnJstz(hashlock);
            if (existingJstzSwap.valid && existingJstzSwap.swap) {
                log(`❌ A swap with this HashLock already exists on Jstz!`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
                return;
            }
            
            // ========== EXECUTE INITIATE ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Locking on Jstz...`;

            try {
                const expiration = Math.floor(Date.now() / 1000) + (timelockMins * 60);
                
                log(`Initiating swap on Jstz...`, 'warning');
                log(`HashLock: ${hashlock.substring(0, 18)}...`, 'info');
                log(`Amount: ${amount} XTZ`, 'info');
                log(`Timelock: ${timelockMins} minutes`, 'info');
                
                // Call Jstz smart function
                log(`Calling Jstz HTLC: jstz://htlc/initiate`, 'system');
                
                const response = await jstzRequest('POST', '/initiate', {
                    hashLock: hashlock,
                    amount: amount,
                    receiver: aliceSwap.swap.sender, // Alice's address
                    expiration: expiration
                });
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                state.currentSwapId = hashlock;
                state.hash = hashlock;
                
                log(`✅ Swap initiated on Jstz!`, 'success');
                log(`Funds Locked: ${amount} XTZ`, 'success');
                
                updateProgress(3);
                log(`Waiting for Alice to reveal secret...`, 'info');
                
                // Pre-fill values for redeem tab
                prefillRedeemForm(state.hash, null);
                log("Go to 'Redeem / Refund' tab to claim (when secret revealed)", 'system');
                
                btn.innerHTML = `<span>Waiting for Secret...</span>`;
                
                // Poll for secret revelation or enable manual claim
                setTimeout(() => {
                    log("Ready to claim on Etherlink (when Alice reveals secret)", 'system');
                    btn.disabled = false;
                    btn.innerHTML = `<span>Waiting for Secret...</span>`;
                    // No onClick needed here, user should go to Redeem tab
                }, 2000);

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Match Swap</span><i class="fa-solid fa-arrow-right"></i>`;
            }
        }

        // Alice claims on Jstz (reveals secret)
        async function claimOnJstz() {
            const btn = document.getElementById('main-action-btn');
            const hashLock = state.currentSwapId || state.hash;
            const secret = state.secret;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate inputs
            if (!hashLock || !isValidHashLock(hashLock)) {
                log('❌ Invalid or missing HashLock', 'error');
                return;
            }
            
            if (!secret) {
                log('❌ Secret is required to claim', 'error');
                return;
            }
            
            // 2. Verify secret matches the hashlock
            if (!verifySecretMatchesHash(secret, hashLock)) {
                log('❌ Secret does not match HashLock!', 'error');
                log('The provided secret hash does not equal the hashlock', 'error');
                return;
            }
            log('✓ Secret matches HashLock', 'success');
            
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying swap on Jstz...`;
            
            // 3. Verify swap exists on Jstz and is ACTIVE
            log('Verifying swap exists on Jstz...', 'warning');
            const verification = await verifySwapOnJstz(hashLock);
            
            if (!verification.valid) {
                log(`❌ ${verification.error}`, 'error');
                log('Bob must lock funds on Jstz before you can claim!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`✓ Swap found on Jstz: ${swap.amount} XTZ locked`, 'success');
            
            // 4. Check if swap is already claimed or refunded
            if (swap.state === 'CLAIMED' || swap.state === 2) {
                log('❌ Swap has already been claimed!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            
            if (swap.state === 'REFUNDED' || swap.state === 3) {
                log('❌ Swap has been refunded!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            
            // 5. Check timelock hasn't expired
            if (swap.isExpired) {
                log('❌ Swap has expired! Cannot claim after timelock.', 'error');
                log(`Expired at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
                return;
            }
            log(`✓ Timelock valid until: ${swap.expirationDate}`, 'success');
            
            // ========== EXECUTE CLAIM ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Claiming on Jstz...`;

            try {
                log(`Claiming on Jstz with secret...`, 'warning');
                log(`Secret: ${secret.substring(0, 18)}...`, 'system');
                
                // Call Jstz smart function to claim
                log(`Calling Jstz HTLC: jstz://htlc/claim`, 'system');
                
                const response = await jstzRequest('POST', '/claim', {
                    hashLock: hashLock,
                    secret: secret
                });
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                log(`✅ Claimed on Jstz!`, 'success');
                log(`Secret revealed: ${secret}`, 'system');
                log(`Alice has received XTZ!`, 'success');
                
                updateProgress(4);
                
                btn.innerHTML = `<i class="fa-solid fa-check-circle"></i> Swap Complete`;
                btn.classList.add('bg-ether-green', 'text-black');
                btn.disabled = true;

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Jstz</span>`;
            }
        }

        // ============================================
        // SWAP VERIFICATION FUNCTIONS
        // ============================================
        
        // Swap states enum (matching Solidity contract)
        const SwapState = {
            EMPTY: 0,      // Swap doesn't exist
            ACTIVE: 1,     // Swap is active, funds locked
            CLAIMED: 2,    // Swap was claimed
            REFUNDED: 3    // Swap was refunded
        };
        
        // Verify swap exists and is in correct state on Etherlink
        async function verifySwapOnEtherlink(swapId, expectedState = null) {
            if (!state.contract) {
                const connected = await connectEtherlink();
                if (!connected) {
                    return { valid: false, error: 'Could not connect to Etherlink' };
                }
            }
            
            if (!state.contract) {
                return { valid: false, error: 'HTLC contract not available on this network' };
            }
            
            try {
                console.log('[VERIFY] Checking swap on Etherlink:', swapId);
                const swap = await state.contract.getSwap(swapId);
                
                console.log('[VERIFY] Swap data:', {
                    sender: swap.sender,
                    receiver: swap.receiver,
                    amount: swap.amount?.toString(),
                    hashLock: swap.hashLock,
                    expiration: swap.expiration?.toString(),
                    state: swap.state
                });
                
                // Check if swap exists (sender is not zero address)
                if (swap.sender === ethers.constants.AddressZero) {
                    return { 
                        valid: false, 
                        error: 'Swap does not exist on Etherlink',
                        swap: null
                    };
                }
                
                // Check state if expected state provided
                if (expectedState !== null && swap.state !== expectedState) {
                    const stateNames = ['EMPTY', 'ACTIVE', 'CLAIMED', 'REFUNDED'];
                    return {
                        valid: false,
                        error: `Swap is ${stateNames[swap.state]}, expected ${stateNames[expectedState]}`,
                        swap
                    };
                }
                
                // Check expiration for claim (must not be expired)
                const now = Math.floor(Date.now() / 1000);
                const isExpired = now >= swap.expiration.toNumber();
                
                return {
                    valid: true,
                    swap: {
                        sender: swap.sender,
                        receiver: swap.receiver,
                        amount: ethers.utils.formatEther(swap.amount),
                        hashLock: swap.hashLock,
                        expiration: swap.expiration.toNumber(),
                        expirationDate: new Date(swap.expiration.toNumber() * 1000).toLocaleString(),
                        state: swap.state,
                        isExpired
                    }
                };
                
            } catch (error) {
                console.error('[VERIFY] Error:', error);
                return { 
                    valid: false, 
                    error: `Failed to verify swap: ${error.message}` 
                };
            }
        }
        
        // Verify swap exists and is in correct state on Jstz
        async function verifySwapOnJstz(hashLock) {
            try {
                console.log('[VERIFY] Checking swap on Jstz:', hashLock);
                
                const response = await jstzRequest('GET', `/swap/${hashLock}`);
                
                if (!response || response.error) {
                    return {
                        valid: false,
                        error: response?.error || 'Swap does not exist on Jstz',
                        swap: null
                    };
                }
                
                console.log('[VERIFY] Jstz swap data:', response);
                
                const now = Math.floor(Date.now() / 1000);
                const isExpired = now >= response.expiration;
                
                return {
                    valid: true,
                    swap: {
                        sender: response.sender,
                        receiver: response.receiver,
                        amount: response.amount,
                        hashLock: response.hashLock,
                        expiration: response.expiration,
                        expirationDate: new Date(response.expiration * 1000).toLocaleString(),
                        state: response.state,
                        isExpired
                    }
                };
                
            } catch (error) {
                console.error('[VERIFY] Jstz error:', error);
                return {
                    valid: false,
                    error: `Failed to verify swap on Jstz: ${error.message}`,
                    swap: null
                };
            }
        }
        
        // Validate hashlock format
        function isValidHashLock(hashLock) {
            if (!hashLock) return false;
            // Must be 0x followed by 64 hex characters (32 bytes)
            return /^0x[a-fA-F0-9]{64}$/.test(hashLock);
        }
        
        // Validate secret matches hashlock
        function verifySecretMatchesHash(secret, hashLock) {
            if (!secret || !hashLock) return false;
            try {
                const computedHash = ethers.utils.keccak256(secret);
                const matches = computedHash.toLowerCase() === hashLock.toLowerCase();
                console.log('[VERIFY] Secret verification:', {
                    secret: secret.substring(0, 18) + '...',
                    computedHash,
                    expectedHash: hashLock,
                    matches
                });
                return matches;
            } catch (error) {
                console.error('[VERIFY] Secret verification error:', error);
                return false;
            }
        }

        // Pre-fill Redeem/Refund form
        function prefillRedeemForm(swapId, secret) {
            const swapIdInput = document.getElementById('swap-id-input');
            const secretInput = document.getElementById('secret-input-claim');
            
            if (swapIdInput && swapId) {
                swapIdInput.value = swapId;
            }
            if (secretInput && secret) {
                secretInput.value = secret;
            }
            
            // Optional: auto-switch to redeem tab? Maybe too intrusive.
            // setTab('redeem');
            log('Swap details saved for Redeem/Refund tab', 'info');
        }

        // Unified claim function
        async function claimSwap() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            const secret = document.getElementById('secret-input-claim')?.value || state.secret;
            
            if (!swapId) {
                log('Please enter a Swap ID / HashLock', 'error');
                return;
            }
            
            if (!secret) {
                log('Please enter the secret to claim', 'error');
                return;
            }
            
            // Store for use in claim functions
            state.currentSwapId = swapId;
            state.secret = secret;
            
            // Determine which chain to claim on based on current mode and chain selection
            if (state.selectedChain === 'etherlink') {
                // If we're set to Etherlink, we're Bob claiming on Etherlink
                log('Claiming on Etherlink...', 'warning');
                await claimOnEtherlink();
            } else {
                // If we're set to Jstz, we're Alice claiming on Jstz
                log('Claiming on Jstz...', 'warning');
                await claimOnJstz();
            }
        }
        
        // Unified refund function
        async function refundSwap() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            if (!swapId) {
                log('Please enter a Swap ID / HashLock', 'error');
                return;
            }
            
            state.currentSwapId = swapId;
            
            if (state.selectedChain === 'etherlink') {
                await refundOnEtherlink();
            } else {
                await refundOnJstz();
            }
        }
        
        // Refund on Etherlink (after timelock expires)
        async function refundOnEtherlink() {
            const swapId = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate swap ID
            if (!swapId || !isValidHashLock(swapId)) {
                log('❌ Invalid or missing Swap ID', 'error');
                return;
            }
            state.currentSwapId = swapId;
            
            if (!state.contract) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }
            
            if (!state.contract) {
                log('❌ HTLC contract not available', 'error');
                return;
            }
            
            const btn = document.getElementById('refund-btn');
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
            
            // 2. Verify swap exists on Etherlink and is ACTIVE
            log('Verifying swap on Etherlink...', 'warning');
            const verification = await verifySwapOnEtherlink(swapId, SwapState.ACTIVE);
            
            if (!verification.valid) {
                log(`❌ ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`✓ Swap found: ${swap.amount} XTZ`, 'success');
            
            // 3. Verify caller is the original sender (can only refund your own swap)
            if (swap.sender.toLowerCase() !== state.etherlinkAddress.toLowerCase()) {
                log('❌ Only the original sender can refund this swap', 'error');
                log(`Sender: ${swap.sender}`, 'info');
                log(`Your address: ${state.etherlinkAddress}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('✓ You are the original sender', 'success');
            
            // 4. Check timelock HAS expired (required for refund)
            if (!swap.isExpired) {
                const now = Math.floor(Date.now() / 1000);
                const remaining = swap.expiration - now;
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                log(`❌ Cannot refund yet - timelock has not expired`, 'error');
                log(`Time remaining: ${mins}m ${secs}s`, 'warning');
                log(`Expires at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('✓ Timelock has expired, refund allowed', 'success');
            
            // ========== EXECUTE REFUND ==========
            try {
                log('Executing refund on Etherlink...', 'warning');
                log(`Swap ID: ${swapId.substring(0, 18)}...`, 'info');
                
                const tx = await state.contract.refundSwap(swapId);
                log(`Transaction sent: ${tx.hash.substring(0, 18)}...`, 'warning');
                
                const receipt = await tx.wait();
                
                if (receipt.status !== 1) {
                    throw new Error('Transaction failed on-chain');
                }
                
                log('✅ Refund successful on Etherlink!', 'success');
                log(`${swap.amount} XTZ returned to your wallet`, 'success');
                
                // hideClaimRefundSection(); // No longer needed in redeem tab
                updateProgress(1);
                
            } catch (error) {
                let errorMsg = error.message;
                if (error.message.includes('NotYetExpired') || error.message.includes('not yet expired')) {
                    errorMsg = 'Timelock has not expired yet';
                } else if (error.message.includes('OnlySender') || error.message.includes('not sender')) {
                    errorMsg = 'Only the original sender can refund';
                } else if (error.message.includes('SwapNotActive')) {
                    errorMsg = 'Swap is not active (already claimed or refunded)';
                }
                log(`❌ Refund error: ${errorMsg}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
            }
        }
        
        // Refund on Jstz
        async function refundOnJstz() {
            const hashLock = document.getElementById('swap-id-input')?.value || state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate hashlock
            if (!hashLock || !isValidHashLock(hashLock)) {
                log('❌ Invalid or missing HashLock', 'error');
                return;
            }
            state.currentSwapId = hashLock;
            
            const btn = document.getElementById('refund-btn');
            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i>`;
            
            // 2. Verify swap exists on Jstz
            log('Verifying swap on Jstz...', 'warning');
            const verification = await verifySwapOnJstz(hashLock);
            
            if (!verification.valid) {
                log(`❌ ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`✓ Swap found: ${swap.amount} XTZ`, 'success');
            
            // 3. Check if already claimed or refunded
            if (swap.state === 'CLAIMED' || swap.state === 2) {
                log('❌ Swap has already been claimed!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            if (swap.state === 'REFUNDED' || swap.state === 3) {
                log('❌ Swap has already been refunded!', 'error');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            
            // 4. Check timelock HAS expired (required for refund)
            if (!swap.isExpired) {
                const now = Math.floor(Date.now() / 1000);
                const remaining = swap.expiration - now;
                const mins = Math.floor(remaining / 60);
                const secs = remaining % 60;
                log(`❌ Cannot refund yet - timelock has not expired`, 'error');
                log(`Time remaining: ${mins}m ${secs}s`, 'warning');
                log(`Expires at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
                return;
            }
            log('✓ Timelock has expired, refund allowed', 'success');
            
            // ========== EXECUTE REFUND ==========
            log('Executing refund on Jstz...', 'warning');
            
            try {
                const response = await jstzRequest('POST', '/refund', {
                    hashLock: hashLock
                });
                
                if (response && response.error) {
                    throw new Error(response.error);
                }
                
                log('✅ Refund successful on Jstz!', 'success');
                log(`${swap.amount} XTZ returned to your wallet`, 'success');
                // hideClaimRefundSection(); // No longer needed
                updateProgress(1);
                
            } catch (error) {
                log(`❌ Refund error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<i class="fa-solid fa-rotate-left"></i><span>Refund</span>`;
            }
        }

        // Bob claims on Etherlink (uses revealed secret)
        async function claimOnEtherlink() {
            const btn = document.getElementById('main-action-btn');
            const swapId = state.currentSwapId || state.hash;
            
            // ========== SECURITY CHECKS ==========
            
            // 1. Validate swap ID
            if (!swapId || !isValidHashLock(swapId)) {
                log('❌ Invalid or missing Swap ID', 'error');
                return;
            }
            
            // 2. Get secret (prompt if not available)
            let secret = state.secret;
            if (!secret) {
                secret = document.getElementById('secret-input-claim')?.value;
            }
            if (!secret) {
                secret = prompt("Enter the revealed secret (0x...):");
                if (!secret) {
                    log("❌ Secret is required to claim", 'error');
                    return;
                }
            }
            state.secret = secret;
            
            // 3. Verify secret format
            if (!isValidHashLock(secret)) {
                log('❌ Invalid secret format (must be 0x + 64 hex chars)', 'error');
                return;
            }
            
            // 4. Verify secret matches the hashlock
            if (!verifySecretMatchesHash(secret, swapId)) {
                log('❌ Secret does not match Swap ID (HashLock)!', 'error');
                log('Make sure you have the correct secret from Alice', 'error');
                return;
            }
            log('✓ Secret matches HashLock', 'success');

            if (!state.contract) {
                const connected = await connectEtherlink();
                if (!connected) return;
            }
            
            if (!state.contract) {
                log('❌ HTLC contract not available', 'error');
                return;
            }

            btn.disabled = true;
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Verifying swap on Etherlink...`;
            
            // 5. Verify swap exists on Etherlink and is ACTIVE
            log('Verifying swap exists on Etherlink...', 'warning');
            const verification = await verifySwapOnEtherlink(swapId, SwapState.ACTIVE);
            
            if (!verification.valid) {
                log(`❌ ${verification.error}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
                return;
            }
            
            const swap = verification.swap;
            log(`✓ Swap found: ${swap.amount} XTZ locked by ${swap.sender.substring(0,10)}...`, 'success');
            
            // 6. Check timelock hasn't expired
            if (swap.isExpired) {
                log('❌ Swap has expired! Cannot claim after timelock.', 'error');
                log(`Expired at: ${swap.expirationDate}`, 'info');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
                return;
            }
            log(`✓ Timelock valid until: ${swap.expirationDate}`, 'success');
            
            // ========== EXECUTE CLAIM ==========
            btn.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin"></i> Claiming on Etherlink...`;

            try {
                log(`Claiming on Etherlink with secret...`, 'warning');
                
                // Convert secret to bytes
                const secretBytes = ethers.utils.arrayify(secret);
                
                const tx = await state.contract.claimSwap(swapId, secretBytes);

                log(`Transaction sent: ${tx.hash.substring(0, 18)}...`, 'warning');
                
                const receipt = await tx.wait();
                
                // Verify transaction was successful
                if (receipt.status !== 1) {
                    throw new Error('Transaction failed on-chain');
                }
                
                log(`✅ Claimed on Etherlink!`, 'success');
                log(`Bob has received ${swap.amount} XTZ!`, 'success');
                log(`Transaction: ${tx.hash}`, 'system');
                
                updateProgress(4);
                
                btn.innerHTML = `<i class="fa-solid fa-check-circle"></i> Swap Complete`;
                btn.classList.add('bg-green-500');
                btn.disabled = true;

            } catch (error) {
                // Parse contract revert reasons
                let errorMsg = error.message;
                if (error.message.includes('SwapNotActive')) {
                    errorMsg = 'Swap is not active (already claimed or refunded)';
                } else if (error.message.includes('InvalidHashLock')) {
                    errorMsg = 'Invalid secret - does not match hashlock';
                } else if (error.message.includes('SwapExpired')) {
                    errorMsg = 'Swap has expired';
                }
                log(`❌ Error: ${errorMsg}`, 'error');
                btn.disabled = false;
                btn.innerHTML = `<span>Claim on Etherlink</span>`;
            }
        }

        // Main action dispatcher
        async function executeAction() {
            if (state.mode === 'create') {
                // Alice initiates
                if (state.chain === 'etherlink') {
                    await initiateOnEtherlink();
                } else {
                    await initiateOnJstz();
                }
            } else {
                // Bob joins
                if (state.chain === 'etherlink') {
                    await initiateOnJstz(); // Bob locks on opposite chain
                } else {
                    await initiateOnEtherlink();
                }
            }
        }

        // Legacy functions for compatibility
        async function revealSecret() {
            await claimOnJstz();
        }

        async function claimWithSecret() {
            await claimOnEtherlink();
        }

        function copyToClipboard(id) {
            const el = document.getElementById(id);
            el.select();
            navigator.clipboard.writeText(el.value);
            log(`Copied ${id} to clipboard.`, 'info');
        }

        // Init
        generateNewSecret();
        updateProgress(1);
        renderTokenDropdown(); // Initialize token dropdown
        log("Atomic Swap ready. Connect wallets to begin.", 'system');
        log(`Etherlink Contract: ${CONFIG.etherlink.contractAddress}`, 'info');
        log(`Jstz Function: ${CONFIG.jstz.functionAddress}`, 'info');
        log(`Tokens available: ${Object.keys(TOKENS).join(', ')}`, 'info');
        
        // Close token dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('token-dropdown');
            const assetSelector = e.target.closest('[onclick="toggleTokenSelector()"]');
            if (!assetSelector && !e.target.closest('#token-dropdown')) {
                toggleTokenSelector(false);
            }
        });

        // Wallet Events - Real connections
        document.getElementById('wallet-etherlink').addEventListener('click', async (e) => {
            const btn = e.currentTarget;
            const textEl = document.getElementById('wallet-etherlink-text');
            const balanceEl = document.getElementById('wallet-balance');
            
            textEl.innerHTML = `<i class="fa-solid fa-circle-notch fa-spin mr-1"></i> Connecting...`;
            
            const connected = await connectEtherlink();
            
            if (connected) {
                const shortAddr = `${state.etherlinkAddress.substring(0, 6)}...${state.etherlinkAddress.slice(-4)}`;
                textEl.innerText = shortAddr;
                btn.classList.add('border-ether-green', 'text-ether-green', 'bg-ether-green/10');
                
                // Fetch and display balances
                await fetchAllBalances();
                
                // Show balance next to address
                if (state.tokenBalances['XTZ']) {
                    const xtzBalance = parseFloat(state.tokenBalances['XTZ']).toFixed(2);
                    balanceEl.innerText = `${xtzBalance} XTZ`;
                    balanceEl.classList.remove('hidden');
                }
                
                // Update token dropdown with balances
                renderTokenDropdown();
            } else {
                textEl.innerText = 'Connect Etherlink';
            }
        });

        document.getElementById('wallet-jstz').addEventListener('click', async (e) => {
            const btn = e.currentTarget;
            const textEl = document.getElementById('wallet-jstz-text');
            
            // Jstz connection (simulated - real implementation needs jstz CLI auth)
            state.jstzAddress = 'tz1gyq6Er4ntjHFaXsVbUKnSEqvEiez4HFTP';
            textEl.innerText = 'tz1...FTP';
            btn.classList.add('border-jstz-accent', 'text-jstz-accent', 'bg-jstz-accent/10');
            log(`Jstz identity connected: ${state.jstzAddress}`, 'success');
        });

        // Listen for MetaMask network/account changes
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.on('chainChanged', async (chainId) => {
                const newChainId = parseInt(chainId, 16);
                console.log('[DEBUG] Network changed to chainId:', newChainId);
                log(`Network changed! Reconnecting...`, 'warning');
                
                // Reconnect with new network
                await connectEtherlink();
                await fetchAllBalances();
                renderTokenDropdown();
            });
            
            window.ethereum.on('accountsChanged', async (accounts) => {
                console.log('[DEBUG] Account changed to:', accounts[0]);
                if (accounts.length > 0) {
                    log(`Account changed! Reconnecting...`, 'warning');
                    await connectEtherlink();
                    await fetchAllBalances();
                    
                    // Update wallet button
                    const textEl = document.getElementById('wallet-etherlink-text');
                    if (textEl) {
                        const shortAddr = `${accounts[0].substring(0, 6)}...${accounts[0].slice(-4)}`;
                        textEl.innerText = shortAddr;
                    }
                } else {
                    log(`Wallet disconnected`, 'warning');
                    updateNetworkBadge(0, 'Not Connected');
                }
            });
            
            console.log('[DEBUG] MetaMask event listeners attached');
        }

    </script>
</body>
</html>
